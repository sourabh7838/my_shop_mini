import { existsSync } from 'fs';
import { promisify } from 'util';
import { resolve } from 'path';
import glob from 'glob';

const defaultGraphQLProjectName = 'GraphQL';

// temporary utility until `graphql-config` supports this function natively
// see: https://github.com/prisma/graphql-config/pull/113
function resolvePathRelativeToConfig(project, relativePath) {
  return resolve(project.dirpath, relativePath);
}
function resolveProjectName(project, defaultName = defaultGraphQLProjectName) {
  // eslint-disable-next-line no-console
  console.warn('Deprecation: Use of `resolveProjectName` has been deprecated. Please use `project.name` instead.');
  return project.name || defaultName;
}
function resolveSchemaPath(project, ignoreMissing = false) {
  // schemaPath is nullable in graphql-config even though it cannot actually be
  // omitted. This function simplifies access to the schema without
  // requiring a type guard.
  if (!project.schema) {
    // this case should never happen with a properly formatted config file.
    // graphql-config currently does not perform any validation so it's possible
    // for a mal-formed schema to be loaded at runtime.
    throw new Error(`Missing GraphQL schema for project '${project.name}'`);
  }

  // resolve fully qualified schemaPath
  const schemaPath = resolve(project.dirpath, project.schema);
  if (ignoreMissing) {
    return schemaPath;
  }
  if (!existsSync(schemaPath)) {
    const forProject = project.name ? ` for project '${project.name}'` : '';
    throw new Error([`Schema not found${forProject}.`, `Expected to find the schema at '${schemaPath}' but the path does not exist.`, `Check '${project.filepath}' and verify that schemaPath is configured correctly${forProject}.`].join(' '));
  }
  return schemaPath;
}
function getGraphQLProjects(config) {
  var _projects$;
  const projects = Object.values((config === null || config === void 0 ? void 0 : config.projects) || {});
  if (projects.length > 1) {
    // multi-project configuration, return an array of projects
    return projects;
  }
  if (projects[0] && (_projects$ = projects[0]) !== null && _projects$ !== void 0 && _projects$.schema) {
    // single project configuration, return an array of the single project
    return projects;
  }
  let defaultProject;
  try {
    defaultProject = config.getDefault();
    return [defaultProject];
  } catch {
    // invalid project configuration
    throw new Error(`No projects defined in '${config.filepath}'`);
  }
}
function getGraphQLSchemaPaths(config) {
  return getGraphQLProjects(config).reduce((schemas, project) => {
    return schemas.concat(resolveSchemaPath(project));
  }, []);
}
async function getGraphQLProjectIncludedFilePaths(projectConfig) {
  const [includes, excludes] = getIncludesExcludesFromConfig(projectConfig);
  return (await Promise.all(includes.map(include => promisify(glob)(resolvePathRelativeToConfig(projectConfig, include), {
    ignore: excludes.map(exclude => resolvePathRelativeToConfig(projectConfig, exclude))
  })))).reduce((allFilePaths, filePaths) => allFilePaths.concat(filePaths), []);
}
function getGraphQLProjectForSchemaPath(config, schemaPath) {
  const project = getGraphQLProjects(config).filter(project => {
    return resolveSchemaPath(project, true) === schemaPath;
  }).shift() || config.projects[0];
  if (!project || !project.schema || resolveSchemaPath(project, true) !== schemaPath) {
    throw new Error(`No project defined in graphql config for schema '${schemaPath}'`);
  }
  return project;
}
function getIncludesExcludesFromConfig(projectConfig) {
  if (!projectConfig.include) {
    return [[], []];
  }
  const excludes = projectConfig.exclude || [];
  const includes = typeof projectConfig.include === 'string' ? [projectConfig.include] : projectConfig.include;
  const ignore = typeof excludes === 'string' ? [excludes] : excludes;
  return [includes, ignore];
}

export { defaultGraphQLProjectName, getGraphQLProjectForSchemaPath, getGraphQLProjectIncludedFilePaths, getGraphQLProjects, getGraphQLSchemaPaths, getIncludesExcludesFromConfig, resolvePathRelativeToConfig, resolveProjectName, resolveSchemaPath };
