import path from 'path';
import fs from 'fs';
import { AbortError } from '@shopify/cli-kit/node/error';
import chalk from 'chalk';
import { outputDebug } from '@shopify/cli-kit/node/output';
import { isStandaloneMini } from '../../../utils/standalone.js';
import { getPackageLatestVersion, hardResetDependencies, } from '../../../utils/package-manager.js';
import { wrapWithLoadingIndicator } from '../../../utils/wrap-with-loading-indicator.js';
import { COMMON_PACKAGE_DEPENDENCY_VERSIONS } from '../../../constants/templates.js';
const LEGACY_PLATFORM_DEPENDENCIES = [
    '@shopify/shop-minis-runtime',
    '@shopify/shop-minis-platform-sdk',
    '@shopify/shop-minis-ui-extensions',
];
const STANDALONE_PLATFORM_DEPENDENCIES = ['@shopify/shop-minis-sdk'];
const PLATFORM_DEV_DEPENDENCIES = [
    '@shopify/shop-minis-cli',
    '@types/jest',
    'babel-jest',
    'eslint',
    'jest',
    'prettier',
];
const DEPENDENCY_VERSIONS = {
    '@shopify/shop-minis-sdk': 'latest',
    '@shopify/shop-minis-runtime': 'latest',
    '@shopify/shop-minis-platform-sdk': 'latest',
    '@shopify/shop-minis-ui-extensions': 'latest',
    '@shopify/shop-minis-cli': 'latest',
    '@types/jest': COMMON_PACKAGE_DEPENDENCY_VERSIONS.TYPES_JEST,
    'babel-jest': COMMON_PACKAGE_DEPENDENCY_VERSIONS.BABEL_JEST,
    eslint: COMMON_PACKAGE_DEPENDENCY_VERSIONS.ESLINT,
    jest: COMMON_PACKAGE_DEPENDENCY_VERSIONS.JEST,
    prettier: COMMON_PACKAGE_DEPENDENCY_VERSIONS.PRETTIER,
};
const log = (message) => {
    if (process.env.VITEST)
        return;
    console.log(message);
};
export async function diagnoseDependencies(autoFix) {
    const { areDependenciesValid, dependenciesToAdd, dependenciesToRemove, devDependenciesToAdd, devDependenciesToRemove, } = getInvalidDependencies();
    if (!areDependenciesValid) {
        log(chalk.red(`\n❌ Found some issues with the dependencies of your mini. Read more about supported dependencies in ${chalk.bold('https://shop.app/minis/docs/build-a-shop-mini/dependencies/')}`));
        logDependenciesToRemove([...dependenciesToRemove]);
        logDependenciesToRemove([...devDependenciesToRemove], true);
        logDependenciesToAdd([...dependenciesToAdd]);
        logDependenciesToAdd([...devDependenciesToAdd], true);
    }
    if (autoFix) {
        await autoFixDependencies({
            packageJsonPath: path.join(process.cwd(), 'package.json'),
            dependenciesToAdd,
            devDependenciesToAdd,
            dependenciesToRemove,
            devDependenciesToRemove,
        });
    }
    else if (!areDependenciesValid) {
        logTroubleshootInstructions();
    }
    return areDependenciesValid;
}
function getDependencies(packageJsonPath) {
    return getPackageJsonByPath(packageJsonPath).dependencies;
}
function getDevDependencies(packageJsonPath) {
    return getPackageJsonByPath(packageJsonPath).devDependencies;
}
function getMiniDependencies() {
    const miniPackageJsonPath = path.join(process.cwd(), 'package.json');
    const miniDependencies = getDependencies(miniPackageJsonPath);
    const miniDevDependencies = getDevDependencies(miniPackageJsonPath);
    return {
        dependencies: miniDependencies,
        devDependencies: miniDevDependencies,
    };
}
export function getInvalidDependencies() {
    const isStandalone = isStandaloneMini();
    const { dependencies, devDependencies } = getMiniDependencies();
    const miniDependencies = Object.keys(dependencies);
    const miniDevDependencies = Object.keys(devDependencies);
    let dependenciesToAdd = [];
    let devDependenciesToAdd = [];
    let dependenciesToRemove = [];
    let devDependenciesToRemove = [];
    if (isStandalone) {
        dependenciesToAdd = STANDALONE_PLATFORM_DEPENDENCIES.filter(dependency => !miniDependencies.includes(dependency));
        dependenciesToRemove = miniDependencies.filter(dependency => !STANDALONE_PLATFORM_DEPENDENCIES.includes(dependency));
    }
    else {
        dependenciesToAdd = LEGACY_PLATFORM_DEPENDENCIES.filter(dependency => !miniDependencies.includes(dependency));
        dependenciesToRemove = miniDependencies.filter(dependency => !LEGACY_PLATFORM_DEPENDENCIES.includes(dependency));
    }
    devDependenciesToAdd = PLATFORM_DEV_DEPENDENCIES.filter(dependency => !miniDevDependencies.includes(dependency));
    devDependenciesToRemove = miniDevDependencies.filter(dependency => !PLATFORM_DEV_DEPENDENCIES.includes(dependency));
    const areDependenciesValid = dependenciesToAdd.length +
        dependenciesToRemove.length +
        devDependenciesToAdd.length +
        devDependenciesToRemove.length ===
        0;
    return {
        dependenciesToAdd,
        dependenciesToRemove,
        devDependenciesToAdd,
        devDependenciesToRemove,
        areDependenciesValid,
    };
}
function logDependenciesToRemove(dependencies, isDev = false) {
    if (dependencies.length === 0) {
        return;
    }
    log(chalk.red(`\n❌ The following ${isDev ? 'devDependencies' : 'dependencies'} should be removed:`));
    dependencies.forEach(dependency => log(`- ${dependency}`));
    log(''); // Newline after the dependencies
}
function logDependenciesToAdd(dependencies, isDev = false) {
    if (dependencies.length === 0) {
        return;
    }
    log(chalk.red(`\n❌ The following ${isDev ? 'devDependencies' : 'dependencies'} should be added:`));
    dependencies.forEach(dependency => log(`- ${dependency}`));
    log(''); // Newline after the dependencies
}
function getPackageJsonByPath(packageJsonPath) {
    let packageJson = {};
    try {
        const packageJsonString = fs.readFileSync(packageJsonPath).toString('utf-8');
        packageJson = JSON.parse(packageJsonString);
    }
    catch {
        throw new AbortError(`Failed to read from file on path ${packageJsonPath}`);
    }
    return packageJson;
}
function logTroubleshootInstructions() {
    log(chalk.cyan(`\nℹ️  This error is potentially fixable with the ${chalk.bold('--fix')} option.`));
    log(chalk.cyan('\nℹ️  If you want to fix this error manually, try:'));
    log('1. Remove the invalid dependencies and/or devDependencies from your package.json');
    log('2. Add the missing dependencies and/or devDependencies to your package.json');
    log('3. Remove the node_modules folder and the dependencies lockfile (package-lock.json or yarn.lock)');
    log('4. Reinstall dependencies');
    log('5. Commit the changes to the package.json and lockfile');
}
const getDependencyVersion = async (dependency) => {
    let version = DEPENDENCY_VERSIONS[dependency];
    if (!version || version === 'latest') {
        version = await getPackageLatestVersion(dependency);
    }
    return version;
};
async function autoFixDependencies({ packageJsonPath, dependenciesToRemove = [], devDependenciesToRemove = [], dependenciesToAdd = [], devDependenciesToAdd = [], }) {
    outputDebug('Auto fixing dependencies');
    if (!dependenciesToRemove.length &&
        !devDependenciesToRemove.length &&
        !dependenciesToAdd.length &&
        !devDependenciesToAdd.length) {
        return;
    }
    const packageJson = getPackageJsonByPath(packageJsonPath);
    for (const dependency of dependenciesToRemove) {
        outputDebug(`Removing dependency ${dependency}`);
        delete packageJson.dependencies[dependency];
    }
    for (const devDependency of devDependenciesToRemove) {
        outputDebug(`Removing devDependency ${devDependency}`);
        delete packageJson.devDependencies[devDependency];
    }
    await Promise.all(dependenciesToAdd.map(async (dependency) => {
        const version = await getDependencyVersion(dependency);
        outputDebug(`Adding dependency ${dependency} version ${version}`);
        packageJson.dependencies[dependency] = version;
    }));
    await Promise.all(devDependenciesToAdd.map(async (devDependency) => {
        const version = await getDependencyVersion(devDependency);
        outputDebug(`Adding devDependency ${devDependency} version ${version}`);
        packageJson.devDependencies[devDependency] = version;
    }));
    fs.writeFileSync(packageJsonPath, `${JSON.stringify(packageJson, null, 2)}\n`, // keep the new line at the end of the file
    {
        encoding: 'utf-8',
    });
    await wrapWithLoadingIndicator(hardResetDependencies(), {
        loadingMessage: 'Fixing dependencies and recreating lockfiles...',
        successMessage: 'Dependencies fixed',
    });
}
//# sourceMappingURL=diagnose-dependencies.js.map