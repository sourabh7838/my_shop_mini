import url from 'node:url';
import { rm } from 'node:fs/promises';
import path from 'path';
import { copy, move } from 'fs-extra';
import glob from 'glob';
import { outputDebug } from '@shopify/cli-kit/node/output';
import { replaceStringsInTemplate } from '../../../../utils/replace-strings-in-template.js';
import { CLI_VERSION } from '../../../config.js';
import { getFileChecksum } from '../../../../utils/file.js';
const __dirname = url.fileURLToPath(new URL('.', import.meta.url));
// Items we expect to find in the mini's root dir that we do not care about
// for the purposes for upgrading the mini
const IGNORED_FILES = [
    '.git/**/*',
    '.minis-cache/**/*',
    'node_modules/**/*',
    'src/**/*',
    'yarn.lock',
    'package-lock.json',
];
function getFiles(dir, ignore = []) {
    return glob('**', {
        ignore,
        cwd: dir,
        nodir: true,
        dot: true,
    });
}
async function isDifferent(file1, file2) {
    const file1Checksum = await getFileChecksum(file1);
    const file2Checksum = await getFileChecksum(file2);
    return file1Checksum !== file2Checksum;
}
export async function prepareResetFiles(miniHandle, tmpDir) {
    const miniDestinationDir = path.resolve(process.cwd());
    const stringsToReplace = {
        __SHOP_MINIS_CLI_VERSION__: CLI_VERSION,
        __MINI_APP_HANDLE_KEBAB_CASE__: miniHandle,
    };
    // __dirname refers to the linked directory when using `yarn link` so
    // testing this in dev mode is not 100% accurate
    const commonTemplateFilesDir = path.join(__dirname, '../../../../../templates', '__template_common');
    outputDebug(`Copying from ${commonTemplateFilesDir} to ${tmpDir}`);
    await copy(commonTemplateFilesDir, tmpDir);
    await move(path.join(tmpDir, 'gitignore'), path.join(tmpDir, '.gitignore'));
    await rm(path.join(tmpDir, 'src'), { recursive: true });
    await replaceStringsInTemplate(tmpDir, stringsToReplace);
    // We find all files from the the common template
    const tmpDirFiles = await getFiles(tmpDir);
    // We use an ignore list for files in the mini root dir that we expect to exist but we know we don't need to manage
    const miniDestinationDirFiles = await getFiles(miniDestinationDir, IGNORED_FILES);
    const fileSet = new Set([...tmpDirFiles, ...miniDestinationDirFiles]);
    const diff = {
        added: [],
        removed: [],
        changed: [],
        unchanged: [],
    };
    for (const file of fileSet) {
        const tmpDirFileFullPath = path.join(tmpDir, file);
        const miniDestinationDirFileFullPath = path.join(miniDestinationDir, file);
        if (!tmpDirFiles.includes(file)) {
            diff.added.push(file);
        }
        else if (!miniDestinationDirFiles.includes(file)) {
            diff.removed.push(file);
        }
        else if (await isDifferent(tmpDirFileFullPath, miniDestinationDirFileFullPath)) {
            diff.changed.push(file);
        }
        else {
            diff.unchanged.push(file);
        }
    }
    outputDebug(`Copy diff: ${JSON.stringify(diff, null, 2)}`);
    return diff;
}
export async function resetFiles(tmpDir) {
    const miniDestinationDir = path.resolve(process.cwd());
    outputDebug(`Copying from ${tmpDir} to ${miniDestinationDir}`);
    await copy(tmpDir, miniDestinationDir);
}
//# sourceMappingURL=reset-files.js.map