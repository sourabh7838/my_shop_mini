import { Command } from 'commander';
import { renderConfirmationPrompt, renderSuccess } from '@shopify/cli-kit/node/ui';
import { AbortError, handler as handleError } from '@shopify/cli-kit/node/error';
import { DEFAULT_MANIFEST_PATH, getMiniManifest, validateManifest, } from '../../utils/minis-manifest.js';
import { assertNetworkAndAuth } from '../../utils/common-tasks.js';
import { getUserMetafiledDefinitions } from '../../data/user-metafield-definitions/get-user-metafield-definitions.js';
import { deleteUserMetafiledDefinition } from '../../data/user-metafield-definitions/delete-user-metafield-definition.js';
import { createUserMetafiledDefinition } from '../../data/user-metafield-definitions/create-user-metafield-definition.js';
import { getRunBinCommand } from '../../utils/package-manager.js';
export const command = new Command()
    .name('sync-user-metafield-definitions')
    .description('Synchronize user metafield definitions.')
    .option('--path <path>', 'The path to your manifest file.', DEFAULT_MANIFEST_PATH)
    .option('--verbose', 'Print debugging messages.')
    .option('-y, --yes', 'Automatically answer prompts with default options.')
    .action(async (options) => {
    try {
        const localDefinitions = getMiniManifest(options.path).user_metafield_definitions ?? [];
        const { errors: validateErrors } = validateManifest(options.path);
        if (validateErrors.length) {
            const validateManifestCmd = await getRunBinCommand('shop-minis validate-manifest');
            throw new AbortError('Invalid manifest file.', `Run "${validateManifestCmd}" for more details.`);
        }
        await assertNetworkAndAuth();
        const remoteDefinitions = await getUserMetafiledDefinitions();
        const remoteDefinitionsToUpdate = remoteDefinitions.filter(remoteDefinition => {
            const matchedLocalDefinition = localDefinitions.find((localDefinition) => localDefinition.key === remoteDefinition.key);
            return (matchedLocalDefinition &&
                (remoteDefinition.name !== matchedLocalDefinition.name ||
                    remoteDefinition.description !==
                        matchedLocalDefinition.description ||
                    remoteDefinition.type !== matchedLocalDefinition.type));
        });
        const definitionKeysToDelete = remoteDefinitions
            .filter(remoteDefinition => {
            return !localDefinitions.some((localDefinition) => localDefinition.key === remoteDefinition.key);
        })
            .map(definition => definition.key)
            .concat(remoteDefinitionsToUpdate.map(definition => definition.key));
        const definitionsToCreate = localDefinitions
            .filter((localDefinition) => {
            return !remoteDefinitions.some(remoteDefinition => remoteDefinition.key === localDefinition.key);
        })
            .concat(remoteDefinitionsToUpdate.map(({ key }) => localDefinitions.find((localDefinition) => localDefinition.key === key)));
        if (!definitionKeysToDelete.length && !definitionsToCreate.length) {
            renderSuccess({
                headline: 'No changes to apply',
                body: ['All user metafield definitions are already in sync.'],
            });
            return;
        }
        if (!options.yes) {
            const shouldContinue = await renderConfirmationPrompt({
                message: [
                    'Are you sure you want to apply these user metafield definition changes?',
                    {
                        warn: 'Deleting a definition will also delete all associated metafield values.',
                    },
                ],
                infoTable: [
                    ...(definitionKeysToDelete.length > 0
                        ? [
                            {
                                header: 'Definitions to delete',
                                items: definitionKeysToDelete,
                            },
                        ]
                        : []),
                    ...(definitionsToCreate.length > 0
                        ? [
                            {
                                header: 'Definitions to create',
                                items: definitionsToCreate.map((definition) => JSON.stringify(definition, null, 2)),
                            },
                        ]
                        : []),
                ],
            });
            if (!shouldContinue)
                return;
        }
        definitionKeysToDelete.forEach(async (key) => {
            await deleteUserMetafiledDefinition(key);
        });
        definitionsToCreate.forEach(async (definition) => {
            await createUserMetafiledDefinition(definition);
        });
    }
    catch (error) {
        delete error.stack;
        // Always output the error first
        handleError(error);
    }
});
export function loadCommand(parentProgram) {
    parentProgram.addCommand(command);
}
//# sourceMappingURL=index.js.map