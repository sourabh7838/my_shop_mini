import { AbortError } from '@shopify/cli-kit/node/error';
import { outputDebug } from '@shopify/cli-kit/node/output';
import { getRunBinCommand } from '../../utils/package-manager.js';
import { getPendingSubmission } from '../../data/get-submissions.js';
const wrapErrorDefaultOptions = {
    separator: ': ',
};
// Prefix an error with a nice message without loosing the stack
export const wrapError = (error, message, userOptions = {}) => {
    const options = {
        ...wrapErrorDefaultOptions,
        ...userOptions,
    };
    const err = new Error(`${message}${options.separator}${error?.message ?? 'Unknown error'}`);
    if (error && error?.stack) {
        err.stack = error?.stack;
    }
    return err;
};
export const userErrorToErrorMessage = ({ code, message, field, }) => {
    if (!field || field.length === 0)
        return `${message}. (${code})`;
    return `${message}. (${code} for fields ${field.join(', ')})`;
};
export const handleCreateUploadErrors = (params, userErrors) => {
    if (!userErrors || userErrors.length === 0)
        return;
    const errorMessages = userErrors.map(userError => {
        switch (userError.code) {
            case 'INVALID_CHECKSUM':
                return `Invalid checksum for uploaded archive: ${params.checksum}`;
            case 'INVALID_FILE_SIZE':
                return `Invalid file size for uploaded archive: ${params.fileSize}`;
            case 'INVALID_MIME_TYPE':
                return `Invalid mime type for uploaded archive: ${params.mimeType}`;
            default:
                return userErrorToErrorMessage(userError);
        }
    });
    throw new AbortError('There was a problem creating your upload', errorMessages);
};
export const generateExistingPendingSubmissionError = async (pendingSubmission) => {
    outputDebug(`Existing pending submission found ${pendingSubmission ? JSON.stringify(pendingSubmission) : ''}`);
    const errorMessage = pendingSubmission
        ? `The previous submission (reference: ${pendingSubmission.reference}) was submitted at ${pendingSubmission.submittedAt}.\n\n` +
            `Status of ${pendingSubmission.reference}: ${pendingSubmission.status}`
        : undefined;
    return new AbortError('Already a submission under review', errorMessage, [
        [
            'Cancel previous submission. Run',
            {
                command: await getRunBinCommand('shop-minis cancel-submission'),
            },
            'to cancel',
        ],
        [
            'Cancel this submission. Do nothing else and wait for previous submission to be reviewed.',
        ],
    ]);
};
export const handleCreateSubmissionErrors = async (userErrors) => {
    if (!userErrors || userErrors.length === 0)
        return;
    for (const userError of userErrors) {
        if (userError.code === 'ALREADY_PENDING_SUBMISSION') {
            const pendingSubmission = await getPendingSubmission();
            throw await generateExistingPendingSubmissionError(pendingSubmission);
        }
    }
    const errorMessages = userErrors.map(userError => {
        switch (userError.code) {
            case 'FILE_NOT_FOUND':
                return `Your uploaded package could not be found`;
            case 'UPLOAD_NOT_FOUND':
                return `Your upload could not be found`;
            default:
                return userErrorToErrorMessage(userError);
        }
    });
    throw new AbortError('There was a problem creating your submission', errorMessages);
};
export const handleUploadFileErrors = (error) => {
    throw wrapError(error, 'There was a problem with your upload\n\n', {
        separator: '',
    });
};
//# sourceMappingURL=errors.js.map