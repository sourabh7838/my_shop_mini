import { existsSync, mkdirSync } from 'node:fs';
import path from 'node:path';
import { AbortError } from '@shopify/cli-kit/node/error';
import { fileSize } from '@shopify/cli-kit/node/fs';
import { outputContent, outputDebug, outputToken, } from '@shopify/cli-kit/node/output';
import { imageSizeFromFile } from 'image-size/fromFile';
import { zip } from '../../utils/archive.js';
import { getFileChecksum } from '../../utils/file.js';
import { validateManifest } from '../../utils/minis-manifest.js';
import { createUpload as graphqlCreateUpload, } from '../../data/create-upload.js';
import { getPendingSubmission as graphqlGetPendingSubmission } from '../../data/get-submissions.js';
import { createSubmission as graphqlCreateSubmission } from '../../data/create-submission.js';
import { uploadFile } from './gcs.js';
import { wrapError, handleCreateUploadErrors, handleUploadFileErrors, handleCreateSubmissionErrors, generateExistingPendingSubmissionError, } from './errors.js';
import { SUBMISSION_PATHS, SUBMISSION_VALIDATION } from './config.js';
export async function assertNoPendingSubmissions() {
    const pendingSubmission = await graphqlGetPendingSubmission();
    if (pendingSubmission) {
        throw await generateExistingPendingSubmissionError(pendingSubmission);
    }
}
export function assertManifestValid() {
    const { valid, errors } = validateManifest();
    if (!valid) {
        throw new AbortError('Manifest invalid. Errors:', errors.map(error => `  â€¢ ${error}`).join('\n'), [
            ['Fix the above issues in your', { bold: 'manifest.json' }],
            'Try again and if the issue continues, contact us.',
        ]);
    }
}
export async function assertRequiredAssets() {
    const iconPath = path.join(process.cwd(), 'src', 'icon.png');
    if (!existsSync(iconPath)) {
        throw new AbortError('Icon file does not exist', null, [
            [
                'Ensure there is an',
                { bold: 'icon.png' },
                'file in the',
                { bold: 'src' },
                'directory.',
            ],
            'It must be a 1024x1024px PNG file less than 500kb.',
        ]);
    }
    const iconSize = await fileSize(iconPath);
    const dimensions = await imageSizeFromFile(iconPath);
    if (!dimensions) {
        throw new AbortError('Unable to read icon.png dimensions');
    }
    if (iconSize > 500 * 1024) {
        throw new AbortError('icon.png size must be less than 500kb');
    }
    if (dimensions.width !== 1024 || dimensions.height !== 1024) {
        throw new AbortError('icon.png dimensions must be 1024x1024');
    }
    if (dimensions.type !== 'png') {
        throw new AbortError('icon.png must be a PNG file');
    }
}
export const packageShopMini = async ({ inputDirectory, outputArchivePath, matchFilePattern, ignore, }) => {
    try {
        // Ensure the submissions cache dir exists
        try {
            mkdirSync(SUBMISSION_PATHS.SUBMISSION_CACHE_DIR);
        }
        catch {
            // directory already exists. do nothing
        }
        await zip({
            inputDirectory,
            outputArchivePath,
            matchFilePattern,
            ignore,
        });
    }
    catch (error) {
        throw wrapError(error, 'Unable to package Shop Mini');
    }
    const packageSizeBytes = await fileSize(outputArchivePath);
    if (packageSizeBytes > SUBMISSION_VALIDATION.SUBMISSION_FILE_SIZE_MAX_BYTES) {
        outputDebug(outputContent `Filesize of ${outputToken.path(outputArchivePath)} is ${String(packageSizeBytes)} bytes`);
        throw new AbortError('File size too large', `Your Shop Mini is ${(packageSizeBytes / 1000 / 1000).toFixed(2)}mb, which exceeds the maximum size of ${Math.round(SUBMISSION_VALIDATION.SUBMISSION_FILE_SIZE_MAX_BYTES / 1000 / 1000)}mb.`, [
            'Reduce file size of assets and files',
            "Contact us if you're having issues reducing file size",
        ]);
    }
};
export const createStagedUpload = async ({ outputArchiveFilename, outputArchivePath, }) => {
    const packageSizeBytes = await fileSize(outputArchivePath);
    const packageChecksum = getFileChecksum(outputArchivePath);
    const params = {
        filename: outputArchiveFilename,
        checksum: packageChecksum,
        fileSize: packageSizeBytes,
        mimeType: 'application/gzip',
    };
    const { upload, userErrors } = await graphqlCreateUpload(params);
    handleCreateUploadErrors(params, userErrors);
    return upload;
};
export const uploadSubmission = async ({ url, headers, outputArchivePath, }) => {
    const params = {
        filepath: outputArchivePath,
        headers,
        url,
    };
    try {
        await uploadFile(params);
    }
    catch (error) {
        handleUploadFileErrors(error);
    }
};
export const createSubmission = async ({ description, stagedUploadId, }) => {
    const { submission, userErrors } = await graphqlCreateSubmission({
        description,
        uploadId: stagedUploadId,
    });
    await handleCreateSubmissionErrors(userErrors);
    return submission;
};
//# sourceMappingURL=tasks.js.map