import { promisify } from 'util';
import { execFile } from 'child_process';
import ngrok from '@ngrok/ngrok';
import { Command, Option } from 'commander';
import chalk from 'chalk';
import internalIp from 'internal-ip';
import { outputDebug } from '@shopify/cli-kit/node/output';
import { handler as handleError } from '@shopify/cli-kit/node/error';
import _ from 'lodash';
import { getMiniManifest, manifestExists } from '../../utils/minis-manifest.js';
import { maybeApplyPatches } from '../../utils/patch-package.js';
import { getInvalidDependencies } from '../doctor/utils/diagnose-dependencies.js';
import { getRunBinCommand } from '../../utils/package-manager.js';
import { getMiniExtensions } from '../../utils/extensions.js';
import { generateGraphQLTypes } from '../generate-graphql-types/utils/generate-graphql-types.js';
import { isStandaloneMini } from '../../utils/standalone.js';
import { InteractiveTerminal } from './utils/interactive-terminal.js';
import { runMetro } from './utils/metro/metro-server.js';
import { BuildType } from './utils/types.js';
export async function loadCommand(parentProgram) {
    const ip = await internalIp.v4();
    const command = new Command()
        .name('dev')
        .description('Start a local development server.')
        .option('--reset-cache', 'Reset the development server cache.')
        .option('--host <host>', 'The host address for the packager.', ip)
        .option('--verbose', 'Print debugging messages.') // compatible with cli-kit
        .addOption(new Option('--extension-targets <extensionTargets...>', 'Specify the extension targets to run.').hideHelp(!manifestExists() || isStandaloneMini()))
        .addOption(new Option('--build-type <buildType>', 'The type of build to perform.')
        .choices(Object.values(BuildType))
        .default(BuildType.Release))
        .addOption(new Option('--snapshot-version <version>', 'Specify the snapshot version to use (example: 2.100.0+544).').implies({ buildType: 'snapshot' }))
        .option('--tunnel', 'Use ngrok to create a tunnel to the local server.')
        .action(async (initialOptions) => {
        try {
            outputDebug(`Dev command args ${JSON.stringify(initialOptions)}`);
            const execFileAsync = promisify(execFile);
            try {
                await execFileAsync('watchman');
            }
            catch (err) {
                throw new Error('Watchman is required to develop Shop Minis. Install it using `brew install watchman` or visit https://facebook.github.io/watchman/ to learn more.');
            }
            const options = await initialiseOptions(initialOptions);
            if (options.tunnel && !process.env.NGROK_AUTHTOKEN) {
                throw new Error('To use the --tunnel flag, you must have an ngrok authtoken set in the NGROK_AUTHTOKEN environment variable. Get your authtoken at https://dashboard.ngrok.com/get-started/setup');
            }
            const { handle: miniHandle, name: miniName } = getMiniManifest();
            outputDebug(`Running mini "${miniName}"`);
            await validateDependencies();
            maybeApplyPatches(); // we need to patch react-native pressability system to avoid duplicated react tags
            await runMetro(options);
            const tunnelListener = options.tunnel
                ? await ngrok.forward({
                    addr: 8082,
                    authtoken_from_env: true,
                })
                : undefined;
            console.log('Local development environment for', chalk.green(miniName), 'is running...');
            const interactiveTerminal = new InteractiveTerminal({
                isWeb: false,
                options,
                miniHandle: miniHandle ?? _.kebabCase(miniName),
                tunnelListener,
            });
            interactiveTerminal.start();
            generateGraphQLTypes({ verbose: options.verbose, watch: true });
        }
        catch (err) {
            delete err.stack; // delete the stack to avoid a verbose error in case the manifest file does not exist
            await handleError(err);
        }
    });
    parentProgram.addCommand(command);
}
async function initialiseOptions(options) {
    if (options.snapshotVersion && options.buildType !== 'snapshot') {
        console.log(chalk.bold.yellow('\n⚠️  --snapshot-version was specified but --build-type is not `snapshot`. --snapshot-version will be ignored.\n'));
    }
    else if (options.buildType === 'snapshot' && !options.snapshotVersion) {
        console.log(chalk.bold.yellow('\n⚠️  --build-type was set to `snapshot` but --snapshot-version was not specified. Fetching the latest available snapshot\n'));
    }
    let extensionTargets = options.extensionTargets;
    if (!options.extensionTargets && options.extensionTarget) {
        console.log(chalk.bold.yellow(`\n⚠️  --extension-target is deprecated, used --extension-targets instead\n`));
        extensionTargets = [options.extensionTarget];
    }
    const extensionsToStart = await getMiniExtensions(extensionTargets);
    outputDebug(`Running extensions ${JSON.stringify(extensionsToStart)}`);
    return { ...options, extensionTargets: extensionsToStart };
}
async function validateDependencies() {
    const { areDependenciesValid } = getInvalidDependencies();
    if (!areDependenciesValid) {
        console.warn(chalk.yellow(`\n⚠️  There are some issues with the dependencies of your mini. Run ${chalk.bold(await getRunBinCommand('shop-minis doctor'))} for more details and instructions on how to fix them.`));
        console.warn(chalk.yellow('⚠️  Problems with the dependencies of your mini could be a cause of rejection during the submission process\n'));
    }
}
//# sourceMappingURL=react-native.js.map