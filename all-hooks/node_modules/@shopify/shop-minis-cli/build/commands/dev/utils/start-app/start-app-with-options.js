import { outputDebug } from '@shopify/cli-kit/node/output';
import { downloadBinary, getLatestRemoteVersion } from '../network.js';
import { metadataToBinaryFileName } from '../version.js';
import { promptBinaryUpgrade } from '../prompt-binary-upgrade.js';
import { getPlatformConfig } from '../platform.js';
import { BuildType } from '../types.js';
import { isVersionAvailableLocally } from '../binaries.js';
export const startAppWithOptions = async ({ deviceId, platform, deeplink, buildType, snapshotVersion, }, { getInstalledShopVersion, installShop, openDeeplink }, loadingHandlers) => {
    outputDebug(`Starting app with options ${JSON.stringify({
        deviceId,
        platform,
        deeplink,
        buildType,
        snapshotVersion,
    })}`);
    const { loadingEnd, loadingStart, loadingUpdate } = loadingHandlers ?? {};
    const installedShopVersion = await getInstalledShopVersion(deviceId);
    const hasShopAppInstalled = installedShopVersion !== null;
    const versionToUse = await getAppVersionToUse(platform, buildType, snapshotVersion);
    outputDebug(`Currently installed Shop version ${JSON.stringify(installedShopVersion)}`);
    outputDebug(`Target Shop version to use ${JSON.stringify(versionToUse)}`);
    const platformConfig = getPlatformConfig(platform);
    if (versionToUse == null) {
        loadingEnd?.('fail', `No binaries for ${platformConfig.name} can be found on the server!`);
        return;
    }
    else {
        loadingEnd?.();
    }
    // If the user specified a nightly or snapshot build
    const userOverriddenVersion = versionToUse.type !== BuildType.Release;
    // The installed version does not tell us which build type it is, but we can fairly
    // safely assume that version + build number is unique across all build types, so we
    // we will just compare the version + build number
    const isTargetVersionInstalled = hasShopAppInstalled
        ? installedShopVersion.version === versionToUse.version &&
            installedShopVersion.build === versionToUse.build
        : false;
    const needsUpdate = installedShopVersion == null;
    let wantsUpdate = false;
    if (!isTargetVersionInstalled) {
        if (userOverriddenVersion) {
            // The user specified a version and it's not installed so do that without asking
            wantsUpdate = true;
        }
        else if (hasShopAppInstalled) {
            // The user wants a release build and we know the latest is not installed, so prompt to update
            wantsUpdate = await promptBinaryUpgrade();
        }
    }
    outputDebug(`User needs a download/install? ${needsUpdate}`);
    outputDebug(`User wants a download/install? ${wantsUpdate}`);
    if (needsUpdate || wantsUpdate) {
        const binaryAlreadyDownloaded = await isVersionAvailableLocally(versionToUse);
        if (!binaryAlreadyDownloaded) {
            loadingStart?.('Downloading Shop (0%)');
            await downloadBinary(versionToUse, {
                onProgress: progress => {
                    loadingUpdate?.(`Downloading Shop (${progress}%)`);
                },
            });
        }
        loadingStart?.('Installing Shop');
        await installShop(deviceId, metadataToBinaryFileName(versionToUse));
    }
    loadingStart?.('Opening Shop');
    await openDeeplink(deviceId, deeplink);
    loadingEnd?.();
};
/**
 * If buildType is set to snapshot and snapshotVersion is specified, that version is returned.
 * Otherwise, returns the latest available version for the given platform and build type.
 */
async function getAppVersionToUse(platform, buildType, 
/**
 * version formatted as version+build
 * @example 2.5.8+5667
 * @example 0.8.0+2
 */
snapshotVersion) {
    if (snapshotVersion && buildType === BuildType.Snapshot) {
        return {
            build: snapshotVersion.split('+')[1],
            platform,
            type: BuildType.Snapshot,
            version: snapshotVersion.split('+')[0],
        };
    }
    return getLatestRemoteVersion(platform, buildType);
}
//# sourceMappingURL=start-app-with-options.js.map