import { promises as fs } from 'fs';
import path from 'path';
import { execSync } from 'child_process';
export async function cleanupMinisCache() {
    const minisCachePath = path.join(process.cwd(), '.minis-cache');
    try {
        try {
            await fs.access(minisCachePath);
            const cacheFiles = await fs.readdir(minisCachePath);
            let hasCorruptedFiles = false;
            for (const file of cacheFiles) {
                const filePath = path.join(minisCachePath, file);
                if (file.endsWith('.zip')) {
                    try {
                        // Test ZIP file integrity
                        execSync(`unzip -t "${filePath}"`, { stdio: 'pipe' });
                    }
                    catch (error) {
                        console.log(`Found corrupted ZIP file: ${file}`);
                        hasCorruptedFiles = true;
                    }
                }
            }
            if (hasCorruptedFiles) {
                console.log('Cleaning up corrupted minis cache for new download...');
                await fs.rm(minisCachePath, { recursive: true, force: true });
                await fs.mkdir(minisCachePath);
            }
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                await fs.mkdir(minisCachePath);
            }
            else {
                throw error;
            }
        }
        return true;
    }
    catch (error) {
        console.log('Error during cleanup:', error);
        return false;
    }
}
//# sourceMappingURL=cache-cleanup.js.map