import { createRequire } from 'node:module';
import chalk from 'chalk';
import { GraphQLConfig } from 'graphql-config';
import { getGraphqlConfig } from './get-graphql-config.js';
const { Builder, ExportFormat } = createRequire(import.meta.url)('graphql-typescript-definitions');
export function generateGraphQLTypes(options) {
    const miniDir = process.cwd();
    const config = new GraphQLConfig({
        config: getGraphqlConfig(),
        filepath: '',
    }, []);
    const builderOptions = {
        cwd: miniDir,
        addTypename: true,
        exportFormat: ExportFormat.DocumentWithTypedDocumentNode,
        // @ts-expect-error this happens because typescript is loading the same definition of GraphQLConfig from different places
        config,
    };
    const builder = new Builder(builderOptions);
    const schemas = [];
    const docs = [];
    const builtColor = chalk.inverse.bold.green(' BUILT ');
    const errorColor = chalk.inverse.bold.red(' ERROR ');
    builder.on('start:docs', () => {
        docs.length = 0;
    });
    builder.on('start:schema', () => {
        schemas.length = 0;
    });
    builder.on('build:docs', (doc) => {
        docs.push(doc);
    });
    builder.on('build:schema', (schema) => {
        schemas.push(schema);
    });
    builder.on('end:docs', () => {
        docs
            .sort(({ documentPath: documentPathA }, { documentPath: documentPathB }) => documentPathA.localeCompare(documentPathB))
            .forEach(({ documentPath, definitionPath }) => {
            // Make the paths a bit nicer to look at by removing all the path up to the mini's dir
            const trimmedDocumentPath = documentPath.replace(miniDir, '');
            const trimmedDefinitionPath = definitionPath.replace(miniDir, '');
            console.log(`${builtColor} ${chalk.dim(trimmedDocumentPath)} â†’ ${trimmedDefinitionPath}`);
        });
    });
    builder.on('end:schema', () => {
        // It would be good if there was a way to get `graphql-typescript-definitions` to not build the schema types
        // but instead we will just ignore it and not tell the user what happened
    });
    builder.on('error', (error) => {
        console.log(`${errorColor} ${error.message}`);
        if (error.stack) {
            console.log(chalk.dim(error.stack));
        }
        console.log();
        if (!options.watch) {
            process.exit(1);
        }
    });
    process.on('unhandledRejection', () => {
        // In watch mode you cannot catch more than one error `graphql-typescript-definitions` will
        // cause an `unhandledRejection` error. We should just exit
        process.exit(1);
    });
    builder.run({ watch: Boolean(options.watch) });
}
//# sourceMappingURL=generate-graphql-types.js.map