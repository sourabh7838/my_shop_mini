import * as path from 'path';
import * as fs from 'fs';
import * as https from 'https';
import * as url from 'url';
import { handler as handleError } from '@shopify/cli-kit/node/error';
import { outputInfo, outputSuccess } from '@shopify/cli-kit/node/output';
import { renderWarning, renderError } from '@shopify/cli-kit/node/ui';
import { Command } from 'commander';
import { assertNetworkAndAuth } from '../../utils/common-tasks.js';
import { getReportDownloadUrl } from '../../data/reports.js';
import { ReportTypeEnum } from '../../data/types/autogenerated/shop-minis-admin-api/graphql.js';
/**
 * Download a file from a URL to a local file
 * @param fileUrl The URL of the file to download
 * @param outputPath The local path to save the file to
 * @returns A promise that resolves when the download is complete
 */
function downloadFile(fileUrl, outputPath) {
    return new Promise((resolve, reject) => {
        const parsedUrl = new url.URL(fileUrl);
        const req = https.get(parsedUrl, res => {
            // Check if response is a redirect
            if (res.statusCode === 302 || res.statusCode === 301) {
                const redirectUrl = res.headers.location;
                if (!redirectUrl) {
                    reject(new Error('Redirect location header missing'));
                    return;
                }
                // Follow the redirect
                downloadFile(redirectUrl, outputPath).then(resolve).catch(reject);
                return;
            }
            // Check if the request was successful
            if (res.statusCode !== 200) {
                reject(new Error(`Failed to download file: HTTP status code ${res.statusCode}`));
                return;
            }
            // Create output file stream
            const fileStream = fs.createWriteStream(outputPath);
            // Pipe the response to the file
            res.pipe(fileStream);
            // Handle errors
            fileStream.on('error', err => {
                fs.unlink(outputPath, () => { }); // Delete the file on error
                reject(err);
            });
            // Resolve the promise when the download is complete
            fileStream.on('finish', () => {
                fileStream.close();
                resolve();
            });
        });
        // Handle request errors
        req.on('error', err => {
            fs.unlink(outputPath, () => { }); // Delete the file on error
            reject(err);
        });
        // End the request
        req.end();
    });
}
export const command = new Command()
    .name('get')
    .description('Download a report for a specific date.')
    .argument('<report-type>', 'The report type (see `reports list`)')
    .argument('<date>', 'The date for the report in UTC (YYYY-MM-DD format)')
    .option('-o, --output <path>', 'Output file path (defaults to report_<type>_<date>.csv)')
    .action(async (reportType, date, options) => {
    try {
        await assertNetworkAndAuth();
        // Validate that report type is valid
        if (!Object.values(ReportTypeEnum).includes(reportType)) {
            renderWarning({
                headline: `Invalid report type: ${reportType}`,
                body: [
                    'Valid report types are:',
                    Object.values(ReportTypeEnum).join(', '),
                    '',
                    'To see all report types, run:',
                    { command: 'shop-minis reports list' },
                ],
            });
            return;
        }
        // Validate date format
        const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
        if (!dateRegex.test(date)) {
            renderWarning({
                headline: `Invalid date format: ${date}`,
                body: ['Date must be in the format YYYY-MM-DD'],
            });
            return;
        }
        try {
            // Get download URL for the report
            outputInfo('');
            outputInfo(`Fetching download URL for ${reportType} report on ${date}...`);
            const downloadUrl = await getReportDownloadUrl(reportType, date);
            // Determine output file path
            const outputPath = options.output ||
                path.resolve(process.cwd(), `report_${reportType.toLowerCase()}_${date}.csv`);
            outputInfo(`Downloading report to ${outputPath}...`);
            // Download the report
            await downloadFile(downloadUrl, outputPath);
            outputSuccess(`Report successfully downloaded to ${outputPath}`);
            outputInfo('');
        }
        catch (apiError) {
            // Format the error message appropriately
            const errorMessage = apiError instanceof Error ? apiError.message : String(apiError);
            renderError({
                headline: 'Failed to download report',
                body: [errorMessage],
            });
        }
    }
    catch (error) {
        handleError(error);
    }
});
//# sourceMappingURL=get.js.map