import jscodeshift from 'jscodeshift';
export const j = jscodeshift.withParser('tsx');
/**
 * Find the first import declaration of a module
 *
 * Returns an object containing:
 * - `importDeclaration`: This is the whole import node. This is null if no import is found
 * - `specifier`: This is the specific import specifier node that matches the name/alias. Also null if not found
 *
 * If `importedAsName` is not provided, it will look for an import like:
 * ```
 * import {importedName} from 'importPath'
 * ```
 *
 * If `importedAsName` is provided, it will look for an import like:
 * ```
 * import {importedName as importedAsName} from 'importPath'
 * ```
 */
export const findImportOf = (root, importPath, importedName, importedAsName) => {
    const matchedImportDeclaration = root
        .find(j.ImportDeclaration, {
        source: { value: importPath },
    })
        .nodes()[0] ?? null;
    const matchedSpecifier = matchedImportDeclaration?.specifiers?.filter(specifier => {
        if (specifier.type !== 'ImportSpecifier')
            return false;
        return importedAsName
            ? specifier.imported.name === importedName &&
                specifier?.local?.name === importedAsName
            : specifier.imported.name === importedName;
    })[0] ?? null;
    return {
        specifier: matchedSpecifier,
        importDeclaration: matchedImportDeclaration,
    };
};
/**
 * Ensure that an import of a module is present in the file
 *
 * If the import is not present, it will be added below other imports or
 * to the top of the file if no other imports are found
 *
 * Returns the specifier and import declaration nodes that were found, edited or created
 */
export const ensureImportOf = (root, importPath, importedName, importedAsName) => {
    let { importDeclaration, specifier } = findImportOf(root, importPath, importedName, importedAsName);
    if (!specifier) {
        specifier = importedAsName
            ? j.importSpecifier(j.identifier(importedName), j.identifier(importedAsName))
            : j.importSpecifier(j.identifier(importedName));
        if (!importDeclaration) {
            importDeclaration = j.importDeclaration([], j.literal(importPath));
            const existingImports = root.find(j.ImportDeclaration);
            // Put it after the existing imports if possible
            if (existingImports.length > 0) {
                existingImports
                    .at(existingImports.length - 1)
                    .insertAfter(importDeclaration);
            }
            else {
                root.get().node.program.body.unshift(importDeclaration);
            }
        }
        importDeclaration?.specifiers?.push(specifier);
    }
    return { specifier, importDeclaration };
};
/**
 * Find an object expression by its name like
 *
 * ```
 * const objName = {
 *   key: 'value',
 * }
 * ```
 *
 * Returns the object expression node if found, otherwise null
 *
 * If multiple are found, the first one is returned
 */
export const findObjectExpression = (root, objName) => {
    const result = root
        .find(j.VariableDeclarator, {
        id: { type: 'Identifier', name: objName },
        init: { type: 'ObjectExpression' },
    })
        .nodes()[0];
    return result && result?.init?.type === 'ObjectExpression'
        ? result.init
        : null;
};
/**
 * Find an object's property by it's key
 *
 * Returns the property node that was found or null
 */
export const findObjectProperty = ({ obj, key, }) => {
    const properties = obj.properties;
    return (properties.find(prop => {
        if (prop.type !== 'ObjectProperty')
            return false;
        if (prop.key.type === 'Identifier' && prop.key.name === key)
            return true;
        if (prop.key.type === 'StringLiteral' && prop.key.value === key)
            return true;
        return false;
    }) ?? null);
};
/**
 * Return all the objects keys
 *
 * Only returns keys of types Identifier and StringLiteral eg
 *
 * const foo = { 'cool-key': 'value', otherKey: 'ok' }
 */
export const objectKeys = ({ obj, }) => {
    const properties = obj.properties;
    return properties
        .map(prop => {
        if (prop.type !== 'ObjectProperty')
            return null;
        if (prop.key.type === 'Identifier')
            return prop.key.name;
        if (prop.key.type === 'StringLiteral')
            return prop.key.value;
        return null;
    })
        .filter(value => typeof value === 'string');
};
/**
 * Ensure that an object has a property with a specific key
 *
 * If the property is not present, it will be added to the object
 *
 * If `defaultValue` is provided, the property will be set to that value if it does not exist
 *
 * If `overwrite` is also true, the property will be replaced with the `defaultValue`
 *
 * Returns the property node that was found or created
 */
export const ensureObjectProperty = ({ obj, key, defaultValue, overwrite = false, }) => {
    const properties = obj.properties;
    let targetProperty = findObjectProperty({ obj, key });
    if (targetProperty) {
        if (overwrite) {
            targetProperty.value = defaultValue;
        }
    }
    else {
        const safeKeyName = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
        const identifier = safeKeyName.test(key)
            ? j.identifier(key)
            : j.stringLiteral(key);
        targetProperty = j.property('init', identifier, defaultValue);
        properties.push(targetProperty);
    }
    return targetProperty;
};
//# sourceMappingURL=codemod.js.map