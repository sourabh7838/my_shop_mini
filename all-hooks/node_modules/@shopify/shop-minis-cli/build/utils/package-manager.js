import path from 'path';
import fs from 'fs';
import os from 'os';
import { mkdtemp } from 'node:fs/promises';
import _ from 'lodash';
import { getPackageManager as _getPackageManager } from '@shopify/cli-kit/node/node-package-manager';
import { formatPackageManagerCommand, outputDebug, } from '@shopify/cli-kit/node/output';
import { execAsync } from './exec-async-child-process.js';
export const getPackageManager = _.memoize(async () => {
    const packageManager = await _getPackageManager(process.cwd());
    outputDebug(`Preferred package manager has been detected as: ${packageManager}`);
    return packageManager;
});
/**
 * Install a package + update package.json and locks
 */
export const getUpgradePackageCommand = async (packageName, { version = 'latest', exact } = {}) => {
    const packageManager = await getPackageManager();
    return packageManager === 'yarn'
        ? `yarn add ${packageName}@${version} ${exact ? '--exact' : ''}`.trim()
        : // `--save` will save to the existing section of package.json
            // `--legacy-peer-deps` gets us around react 16/17/18 peer dep conflicts that do not matter
            `npm install ${packageName}@${version} --legacy-peer-deps ${exact ? '--save-exact' : '--save'}`;
};
export const addOverride = async (packageName, version) => {
    const packageJsonPath = path.join(process.cwd(), 'package.json');
    let packageJson = {};
    try {
        const packageJsonString = fs.readFileSync(packageJsonPath).toString('utf-8');
        packageJson = JSON.parse(packageJsonString);
        packageJson.overrides = packageJson.overrides || {};
        packageJson.overrides[packageName] = version;
        fs.writeFileSync(packageJsonPath, `${JSON.stringify(packageJson, null, 2)}\n`);
    }
    catch {
        // do nothing if we fail to read the package.json
    }
};
export const execUpgradePackageCommand = async (packageName, { version = 'latest', exact } = {}) => {
    const upgradeCommand = await getUpgradePackageCommand(packageName, {
        version,
        exact,
    });
    await execAsync({
        cmd: upgradeCommand,
        loadingMessage: `Upgrading ${packageName}...`,
        successMessage: `${packageName} upgraded`,
    });
};
/**
 * Install the latest versions that are compatible with the range in package.json
 * Yarn will upgrade in this range if it can and npm will stick with an existing compatible version
 */
export const getInstallCommand = async () => {
    const packageManager = await getPackageManager();
    return packageManager === 'yarn'
        ? `yarn install`
        : // `--legacy-peer-deps` gets us around react 16/17/18 peer dep conflicts that do not matter
            `npm install --legacy-peer-deps`;
};
export const execInstallCommand = async () => {
    const installCommand = await getInstallCommand();
    await execAsync({
        cmd: installCommand,
        loadingMessage: 'Installing dependencies...',
        successMessage: 'Dependencies installed',
    });
};
/**
 * Get a package.json script command formatted according to the detected package manager
 */
export const getRunScriptCommand = async (scriptName, scriptArgs = []) => {
    return formatPackageManagerCommand(await getPackageManager(), scriptName, ...scriptArgs);
};
/**
 * Get the correct command to start a mini in dev mode.
 *
 * For some reason `formatPackageManagerCommand` messes this up for `npx shop-minis dev`
 */
export const getRunDevModeCommand = async () => {
    const packageManager = await getPackageManager();
    return `${packageManager === 'yarn' ? 'yarn' : 'npx'} shop-minis dev`;
};
/**
 * Get a dependency bin command formatted according to the detected package manager
 */
export const getRunBinCommand = async (scriptName, scriptArgs = []) => {
    const packageManager = await getPackageManager();
    return `${packageManager === 'yarn' ? 'yarn' : 'npx'} ${scriptName} ${scriptArgs.join(' ')}`.trimEnd();
};
/**
 * Gets the latest version of a package available in the public npm registry
 */
export const getPackageLatestVersionCommand = (packageName) => {
    return `npm show ${packageName} version`;
};
/**
 * Gets the latest alpha version of a package available in the public npm registry
 */
export const getPackageAlphaVersionCommand = (packageName) => {
    return `npm show ${packageName} dist-tags.alpha`;
};
export const getPackageLatestVersion = async (packageName) => {
    try {
        const getLatestVersionCommand = await getPackageLatestVersionCommand(packageName);
        const { stdout } = await execAsync({
            cmd: getLatestVersionCommand,
        });
        if (!stdout[0] || !stdout[0].trim()) {
            throw new Error(`Version for ${packageName} not recognized`);
        }
        return stdout[0].trim();
    }
    catch {
        throw new Error(`Failed to fetch latest version for ${packageName}`);
    }
};
/**
 * Gets the dependency version of a package available in the public npm registry
 */
export const getPackageDependencyVersionCommand = (packageName, dependencyName) => {
    return `npm show ${packageName} dependencies.${dependencyName}`;
};
export const hardResetDependencies = async () => {
    const installCommand = await getInstallCommand(); // get install command before deleting lockfiles, since lockfiles are used to detect package manager
    await execAsync('rm -rf yarn.lock package-lock.json');
    // doing `rm -rf node_modules proved to be very slow
    // we move it to a tmp folder instead, so that we can reinstall dependencies while we delete the directory in parallel
    const tmpDir = await mkdtemp(path.join(os.tmpdir(), 'minis_dependencies'));
    await execAsync(`mv node_modules ${tmpDir}`);
    return Promise.all([execAsync(`rm -rf ${tmpDir}`), execAsync(installCommand)]);
};
export const getPackageVersion = async (packageName) => {
    const packageJsonPath = path.join(process.cwd(), 'node_modules', ...packageName.split('/'), 'package.json');
    let packageJson = {};
    try {
        const packageJsonString = fs.readFileSync(packageJsonPath).toString('utf-8');
        packageJson = JSON.parse(packageJsonString);
    }
    catch {
        // do nothing. we will return 'not found' instead of crashing
    }
    return packageJson.version || 'not found';
};
export const getPackageDependencyVersion = async (packageName, dependencyName) => {
    const packageJsonPath = path.join(process.cwd(), 'node_modules', ...packageName.split('/'), 'package.json');
    let packageJson = {};
    try {
        const packageJsonString = fs.readFileSync(packageJsonPath).toString('utf-8');
        packageJson = JSON.parse(packageJsonString);
        return packageJson.dependencies[dependencyName];
    }
    catch {
        // do nothing if we fail to read the package.json
    }
};
export const overridePackageDependencies = (directoryPath, versions) => {
    const packageJsonPath = path.join(directoryPath, 'package.json');
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath).toString('utf-8'));
    packageJson.dependencies = {
        ...packageJson.dependencies,
        ...versions.dependencies,
    };
    packageJson.devDependencies = {
        ...packageJson.devDependencies,
        ...versions.devDependencies,
    };
    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
};
export const overridePackageName = (directoryPath, name) => {
    const packageJsonPath = path.join(directoryPath, 'package.json');
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath).toString('utf-8'));
    packageJson.name = name;
    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
};
//# sourceMappingURL=package-manager.js.map