import { createRequire } from 'node:module';
import path from 'node:path';
import { existsSync, writeFileSync } from 'node:fs';
import { AbortError } from '@shopify/cli-kit/node/error';
import { Validator } from 'jsonschema';
import { getMiniBasePath } from './path.js';
const require = createRequire(import.meta.url);
const manifestSchema = require('../schemas/manifest.schema.json');
export const DEFAULT_MANIFEST_PATH = path.join('src', 'manifest.json');
export function manifestExists() {
    const fullManifestPath = path.join(getMiniBasePath(), DEFAULT_MANIFEST_PATH);
    return existsSync(fullManifestPath);
}
export function getMiniManifest(manifestPath = DEFAULT_MANIFEST_PATH) {
    const fullManifestPath = path.join(getMiniBasePath(), manifestPath);
    let manifest;
    try {
        manifest = require(fullManifestPath);
    }
    catch (err) {
        const mockManifest = process.env.MOCK_MANIFEST;
        if (mockManifest) {
            try {
                manifest = JSON.parse(mockManifest);
                manifest = typeof manifest === 'object' ? manifest : null;
            }
            catch {
                manifest = null;
            }
            if (manifest === null) {
                throw new Error(`Failed to load mock manifest value: ${mockManifest}`);
            }
        }
        else {
            let errorMessage = `Could not load manifest file from ${manifestPath}`;
            if (err?.name === 'SyntaxError') {
                errorMessage = `There are syntax errors in your manifest file (path: ${manifestPath}).`;
            }
            else if (err?.code === 'MODULE_NOT_FOUND') {
                errorMessage = `The manifest file of your mini does not exist. Create it in the path "${manifestPath}".`;
            }
            errorMessage +=
                '\nRead more about the manifest schema here: https://shop.app/minis/docs/reference/manifest/';
            throw new AbortError('Failed to read the manifest file.', errorMessage);
        }
    }
    return manifest;
}
export const getMiniManifestFeatures = (manifestPath = DEFAULT_MANIFEST_PATH) => {
    return getMiniManifest(manifestPath)?.features ?? [];
};
export const setMiniManifestFeatures = (features, manifestPath = DEFAULT_MANIFEST_PATH) => {
    const fullManifestPath = path.join(getMiniBasePath(), manifestPath);
    const manifestJson = getMiniManifest(manifestPath);
    manifestJson.features = features;
    writeFileSync(fullManifestPath, `${JSON.stringify(manifestJson, null, 2)}\n`, {
        encoding: 'utf-8',
    });
};
export const setMiniManifestProxies = (proxies, manifestPath = DEFAULT_MANIFEST_PATH) => {
    const fullManifestPath = path.join(getMiniBasePath(), manifestPath);
    const manifestJson = getMiniManifest(manifestPath);
    manifestJson.proxies = proxies;
    writeFileSync(fullManifestPath, `${JSON.stringify(manifestJson, null, 2)}\n`, {
        encoding: 'utf-8',
    });
};
const V1_ENTRYPOINTS = ['CONTENT_CARD', 'ACTION_BUTTON', 'EVENT_CARD'];
function isValidHostname(hostname) {
    // Hostname regex: allows letters, numbers, dots, and hyphens
    // Does not allow protocols or paths
    const hostnameRegex = /^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?)*$/;
    return hostnameRegex.test(hostname);
}
export function validateManifest(manifestPath) {
    const manifest = getMiniManifest(manifestPath);
    const validator = new Validator();
    const result = validator.validate(manifest, manifestSchema);
    const validationErrors = [
        ...result.errors.map(validationError => validationError.stack),
    ];
    // Check for V1 entry points
    if (manifest.entry_points?.some((entry_point) => entry_point.type && V1_ENTRYPOINTS.includes(entry_point.type))) {
        throw new AbortError(`${V1_ENTRYPOINTS} entry points are no longer supported and must be removed from the manifest.`);
    }
    // Validate trusted_domains
    if (manifest.trusted_domains) {
        if (Array.isArray(manifest.trusted_domains)) {
            manifest.trusted_domains.forEach((domain) => {
                if (!isValidHostname(domain)) {
                    validationErrors.push(`Invalid hostname format in trusted_domains: "${domain}". Domain should not include protocol or path`);
                }
            });
        }
        else {
            validationErrors.push('trusted_domains must be an array');
        }
    }
    return {
        valid: result.valid && validationErrors.length === 0,
        errors: validationErrors,
    };
}
//# sourceMappingURL=minis-manifest.js.map