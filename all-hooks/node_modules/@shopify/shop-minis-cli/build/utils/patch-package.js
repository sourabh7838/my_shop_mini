import { createRequire } from 'node:module';
import path from 'node:path';
import { outputDebug } from '@shopify/cli-kit/node/output';
import fs from 'fs-extra';
const { applyPatch: patchPackageApplyPatch } = createRequire(import.meta.url)('patch-package/dist/applyPatches');
const { getPackageDetailsFromPatchFilename } = createRequire(import.meta.url)('patch-package/dist/PackageDetails');
// We use an empty file to know if a patch was already applied or not. i.e.
// if node_modules/react-native/.patched-by-minis-cli exists, we assume that a patch was already applied
// if node_modules/react-native/.patched-by-minis-cli does not exist, we assume that a patch is not applied yet
const PATCHED_MARK_FILE = '.patched-by-minis-cli';
const nodeModulesPath = path.join(process.cwd(), 'node_modules');
const minisSdkPatchesDirectoryPath = path.join(nodeModulesPath, '@shopify', 'shop-minis-sdk', 'patches');
const patchesDirectoryPath = fs.existsSync(minisSdkPatchesDirectoryPath)
    ? minisSdkPatchesDirectoryPath
    : path.join(nodeModulesPath, '@shopify', 'shop-minis-runtime', 'patches');
function getPatchFiles() {
    try {
        return fs.readdirSync(patchesDirectoryPath);
    }
    catch (err) {
        // older versions of shop-minis-runtime (< 0.0.5) do not have the patches folder.
        outputDebug('Patches folder does not exist. Please update @shopify/shop-minis-runtime to ^0.0.5');
        return [];
    }
}
/**
 * Applies patches to Minis dependencies (only if they have not been applied yet)
 * @returns a list with the names of the patches that were applied
 */
export function maybeApplyPatches() {
    const appliedPatches = [];
    outputDebug('Applying dependency patches...');
    const patches = getPatchFiles();
    for (const patch of patches) {
        if (isPatchApplied(patch)) {
            outputDebug(`${patch} is already applied`);
            continue;
        }
        outputDebug(`Applying patch ${patch}`);
        const applied = applyPatch(patch);
        if (applied) {
            markPatchAsApplied(patch);
            outputDebug(`Patch ${patch} applied`);
            appliedPatches.push(patch);
        }
        else {
            outputDebug(`Failed to apply patch ${patch}`);
        }
    }
    return appliedPatches;
}
function isPatchApplied(patch) {
    const dependencyName = getDependencyNameForPatch(patch);
    return fs.existsSync(path.join(nodeModulesPath, dependencyName, PATCHED_MARK_FILE));
}
function applyPatch(patch) {
    const patchFilePath = path.join(patchesDirectoryPath, patch);
    return patchPackageApplyPatch({
        patchFilePath,
        reverse: false,
        patchDir: patchesDirectoryPath,
        packageDetails: getPackageDetailsFromPatchFilename(patch),
    });
}
function markPatchAsApplied(patch) {
    const dependencyName = getDependencyNameForPatch(patch);
    fs.createFileSync(path.join(nodeModulesPath, dependencyName, PATCHED_MARK_FILE));
}
/**
 * Given a patch file name, returns the name of the actual dependency that's being patched.
 *
 * @example
 * getDependencyNameForPatch('react-native+0.68.5.patch')
 * // returns 'react-native'
 */
function getDependencyNameForPatch(patch) {
    return patch.split('+')[0];
}
//# sourceMappingURL=patch-package.js.map