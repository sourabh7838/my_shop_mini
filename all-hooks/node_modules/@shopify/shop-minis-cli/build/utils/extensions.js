import path from 'node:path';
import { readFile } from 'node:fs/promises';
import { outputDebug } from '@shopify/cli-kit/node/output';
import { ExtensionTarget } from '../constants/extensions.js';
import { findObjectExpression, findObjectProperty, j, objectKeys, } from './codemod.js';
import { getMiniBasePath } from './path.js';
export const CONFIG_PATH = path.join('src', 'index.tsx');
const readConfigFile = () => readFile(path.join(getMiniBasePath(), CONFIG_PATH), 'utf8');
/**
 * Find a list of extensions used by this mini
 *
 * We read this from the minis src/index.tsx config.Targets object
 */
export async function getMiniExtensions(specifiedExtensionTargets) {
    let configFile;
    let root;
    try {
        configFile = await readConfigFile();
    }
    catch (error) {
        outputDebug(`getMiniExtensions couldn't read config at ${CONFIG_PATH}`);
        return [];
    }
    if (!configFile || !configFile.includes('MiniAppConfig')) {
        outputDebug(`getMiniExtensions couldn't find \`MiniAppConfig\` in ${CONFIG_PATH}`);
        return [];
    }
    try {
        root = j(configFile);
    }
    catch (error) {
        outputDebug(`getMiniExtensions couldn't parse config at ${CONFIG_PATH}`);
        return [];
    }
    // It would be better if we could find this by type `MiniAppConfig`
    // Or find it by tracing back the default export of the config file
    const configObject = findObjectExpression(root, 'config');
    if (!configObject) {
        outputDebug(`getMiniExtensions couldn't find a \`config\` object in ${CONFIG_PATH}`);
        return [];
    }
    const targetsObject = findObjectProperty({
        obj: configObject,
        key: 'Targets',
    });
    if (!targetsObject) {
        outputDebug('getMiniExtensions no `Targets` found in config');
        return [];
    }
    const targetsValue = targetsObject.value;
    if (targetsValue.type !== 'ObjectExpression') {
        outputDebug(`getMiniExtensions unexpected type for Targets. Expected: ObjectExpression, Found: ${targetsValue.type}`);
        return [];
    }
    const definedExtensions = objectKeys({ obj: targetsValue });
    if (!definedExtensions) {
        outputDebug('getMiniExtensions no extensions found in `Targets`');
        return [];
    }
    const possibleExtensions = Object.values(ExtensionTarget);
    const validDefinedExtensions = possibleExtensions.filter(val => definedExtensions.includes(val));
    outputDebug(`getMiniExtensions extensions found in \`Targets\`: ${JSON.stringify(validDefinedExtensions)}`);
    const invalidDefinedExtensions = definedExtensions.filter(val => !possibleExtensions.includes(val));
    if (invalidDefinedExtensions.length > 0) {
        outputDebug(`getMiniExtensions invalid extensions found in \`Targets\`: ${JSON.stringify(invalidDefinedExtensions)}`);
    }
    let extensionsToStart = validDefinedExtensions;
    // Find the valid extensions this mini has, filter to cli-args if supplied
    // We could (should?) error out if we don't find what the user wanted
    if (Array.isArray(specifiedExtensionTargets) &&
        specifiedExtensionTargets.length > 0) {
        outputDebug(`Extensions from cli args ${JSON.stringify(specifiedExtensionTargets)}`);
        extensionsToStart = validDefinedExtensions.filter(ext => specifiedExtensionTargets?.includes(ext));
    }
    else {
        outputDebug(`No extensions from cli args`);
    }
    return extensionsToStart;
}
/**
 * Given a extension target name, returns the path to the folder in the mini codebase that contains
 * input queries
 */
export function getExtensionInputQueriesFolderPath(target) {
    return path.join(getMiniBasePath(), 'src', 'targets', target);
}
//# sourceMappingURL=extensions.js.map