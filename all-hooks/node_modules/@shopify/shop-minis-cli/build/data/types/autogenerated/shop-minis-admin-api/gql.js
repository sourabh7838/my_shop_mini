/* eslint-disable */
import * as types from './graphql.js';
/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 */
const documents = {
    '\n  mutation CancelSubmission($reference: String!) {\n    submissionCancel(reference: $reference) {\n      submission {\n        reference\n        description\n        status\n        submittedAt\n      }\n      userErrors {\n        code\n        message\n        field\n      }\n    }\n  }\n': types.CancelSubmissionDocument,
    '\n  mutation CreateSubmission($description: String!, $uploadId: ID!) {\n    submissionCreate(description: $description, uploadId: $uploadId) {\n      submission {\n        reference\n        description\n        status\n        submittedAt\n      }\n      userErrors {\n        code\n        message\n        field\n      }\n    }\n  }\n': types.CreateSubmissionDocument,
    '\n  mutation CreateUpload(\n    $filename: String!\n    $fileSize: Int!\n    $checksum: String!\n    $mimeType: String!\n  ) {\n    submissionUploadCreate(\n      input: {\n        filename: $filename\n        fileSize: $fileSize\n        checksum: $checksum\n        mimeType: $mimeType\n      }\n    ) {\n      upload {\n        url\n        headers\n        id\n      }\n      userErrors {\n        code\n        message\n        field\n      }\n    }\n  }\n': types.CreateUploadDocument,
    '\n  query LinkedApps {\n    mini {\n      productionShopifyApp {\n        id\n        title\n      }\n      developmentShopifyApps {\n        id\n        title\n      }\n    }\n  }\n': types.LinkedAppsDocument,
    '\n  query Submissions($first: Int) {\n    submissions(first: $first) {\n      nodes {\n        reference\n        description\n        status\n        submittedAt\n      }\n      pageInfo {\n        hasNextPage\n        hasPreviousPage\n        startCursor\n        endCursor\n      }\n    }\n  }\n': types.SubmissionsDocument,
    '\n  mutation MiniCreate(\n    $name: String!\n    $organizationId: ID!\n    $partnersAccessToken: String!\n  ) {\n    miniCreate(\n      name: $name\n      organizationId: $organizationId\n      partnersAccessToken: $partnersAccessToken\n    ) {\n      mini {\n        handle\n      }\n      token\n      userErrors {\n        code\n        message\n        field\n      }\n    }\n  }\n': types.MiniCreateDocument,
    '\n  mutation MiniLinkApp(\n    $appApiKey: String!\n    $partnersAccessToken: String!\n    $primary: Boolean\n  ) {\n    miniLinkApp(\n      appApiKey: $appApiKey\n      partnersAccessToken: $partnersAccessToken\n      primary: $primary\n    ) {\n      mini {\n        handle\n        productionShopifyAppId\n        developmentShopifyAppIds\n      }\n      userErrors {\n        code\n        message\n        field\n      }\n    }\n  }\n': types.MiniLinkAppDocument,
    '\n  mutation MiniUnlinkApp($appId: ID!) {\n    miniUnlinkApp(appId: $appId) {\n      mini {\n        handle\n        productionShopifyAppId\n        developmentShopifyAppIds\n      }\n      userErrors {\n        code\n        message\n        field\n      }\n    }\n  }\n': types.MiniUnlinkAppDocument,
    '\n  query Mini {\n    mini {\n      handle\n      productionShopifyAppId\n      developmentShopifyAppIds\n    }\n  }\n': types.MiniDocument,
    '\n  query Proxies {\n    proxies {\n      allowedMethods\n      appendedHeaders\n      bodyJsonSchema\n      targetUrlPattern\n      userRateLimitInterval\n      userRateLimitRequests\n    }\n  }\n': types.ProxiesDocument,
    '\n  mutation ProxiesSet($proxies: [ProxyInput!]!) {\n    proxiesSet(proxies: $proxies) {\n      proxies {\n        targetUrlPattern\n      }\n      userErrors {\n        code\n        message\n      }\n    }\n  }\n': types.ProxiesSetDocument,
    '\n  mutation SecretDelete($key: String!) {\n    secretDelete(key: $key) {\n      userErrors {\n        code\n        field\n        message\n      }\n    }\n  }\n': types.SecretDeleteDocument,
    '\n  mutation SecretSet($key: String!, $secretValue: String!) {\n    secretSet(key: $key, value: $secretValue) {\n      secret {\n        key\n      }\n    }\n  }\n': types.SecretSetDocument,
    '\n  query Secrets {\n    secrets {\n      key\n    }\n  }\n': types.SecretsDocument,
    '\n  mutation UserMetafieldDefinitionCreate(\n    $definition: UserMetafieldDefinitionCreateInput!\n  ) {\n    userMetafieldDefinitionCreate(definition: $definition) {\n      createdDefinition {\n        description\n        name\n        key\n      }\n      userErrors {\n        code\n        message\n        field\n      }\n    }\n  }\n': types.UserMetafieldDefinitionCreateDocument,
    '\n  mutation UserMetafieldDefinitionDelete($key: String!) {\n    userMetafieldDefinitionDelete(identifier: {key: $key}) {\n      deletedDefinition {\n        key\n      }\n      userErrors {\n        code\n        message\n        field\n      }\n    }\n  }\n': types.UserMetafieldDefinitionDeleteDocument,
    '\n  query UserMetafieldDefinitions {\n    userMetafieldDefinitions {\n      nodes {\n        description\n        name\n        key\n        type\n      }\n    }\n  }\n': types.UserMetafieldDefinitionsDocument,
};
export function graphql(source) {
    return documents[source] ?? {};
}
//# sourceMappingURL=gql.js.map