import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    /** A signed decimal number serialized as a string. Example value: `"29.99"`. */
    Decimal: any;
    /** An ISO 8601-encoded date */
    ISO8601Date: any;
    /** An ISO 8601-encoded datetime */
    ISO8601DateTime: any;
    /** Represents untyped JSON */
    JSON: any;
    /**
     * Represents an [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986) and [RFC 3987](https://datatracker.ietf.org/doc/html/rfc3987)-compliant URI string.
     *
     * For example, `"https://johns-apparel.myshopify.com"` is a valid URL. It includes a scheme (`https`) and a host (`johns-apparel.myshopify.com`).
     *
     */
    URL: any;
};
/** Represents attribution details for a line item in an order. */
export type Attribution = {
    __typename?: 'Attribution';
    /** The fields associated with this attribution. */
    fields: Array<AttributionField>;
    /** The LineItem ID associated with this attribution. */
    lineItemId: Scalars['ID'];
    /** The Order ID associated with this attribution. */
    orderId: Scalars['ID'];
    /** The Shop domain ({store_name}.myshopify.com) associated with this attribution. */
    shopDomain: Scalars['String'];
    /**
     * The Shop ID associated with this attribution.
     * @deprecated DEPRECATED - Please use shopDomain instead.
     */
    shopId: Scalars['ID'];
};
/** The connection type for Attribution. */
export type AttributionConnection = {
    __typename?: 'AttributionConnection';
    /** A list of edges. */
    edges: Array<AttributionEdge>;
    /** A list of nodes. */
    nodes: Array<Attribution>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
};
/** An edge in a connection. */
export type AttributionEdge = {
    __typename?: 'AttributionEdge';
    /** A cursor for use in pagination. */
    cursor: Scalars['String'];
    /** The item at the end of the edge. */
    node?: Maybe<Attribution>;
};
/** Represents a single attribution detail. */
export type AttributionField = {
    __typename?: 'AttributionField';
    /** The key of the field. */
    key: Scalars['String'];
    /** The value of the field. */
    value: Scalars['String'];
};
/** Represents content in a Mini. */
export type Content = {
    __typename?: 'Content';
    /** Description of the content. */
    description?: Maybe<Scalars['String']>;
    /** External identifier for the content. */
    externalId?: Maybe<Scalars['ID']>;
    /** Image associated with the content. */
    image: Image;
    /** Products associated with the content. */
    productIds: Array<Scalars['ID']>;
    /** Public identifier for the content. */
    publicId: Scalars['ID'];
    /** Shareable URL for the content. */
    shareableUrl: Scalars['URL'];
    /** Title of the content. */
    title: Scalars['String'];
};
/** Return type for the `contentCreate` mutation. */
export type ContentCreatePayload = {
    __typename?: 'ContentCreatePayload';
    /** The created content. */
    content?: Maybe<Content>;
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<ContentCreateUserError>;
};
/** A user or client error that could occur during the execution of the `contentCreate` mutation. */
export type ContentCreateUserError = {
    __typename?: 'ContentCreateUserError';
    /** Error code associated with the error. */
    code: ContentCreateUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by ContentCreateUserError. */
export declare enum ContentCreateUserErrorCode {
    /** Content with this external ID already exists. */
    DuplicateExternalId = "DUPLICATE_EXTERNAL_ID",
    /** Some products are not eligible for Shop. */
    IneligibleProducts = "INELIGIBLE_PRODUCTS"
}
/** This is a content creator that may appear next to a Mini entry point. */
export type ContentCreator = {
    __typename?: 'ContentCreator';
    /** The avatar of the content creator. */
    avatar?: Maybe<Image>;
    /** The name of the content creator. */
    name: Scalars['String'];
};
/** Content creator that may appear next to a Mini entry point. */
export type ContentCreatorInput = {
    /** The avatar of the content creator. */
    avatar?: InputMaybe<ImageInput>;
    /** The name of the content creator. */
    name: Scalars['String'];
};
/** ISO currency code. */
export declare enum CurrencyCode {
    /** United Arab Emirates Dirham. */
    Aed = "AED",
    /** Afghan Afghani. */
    Afn = "AFN",
    /** Albanian Lek. */
    All = "ALL",
    /** Armenian Dram. */
    Amd = "AMD",
    /** Netherlands Antillean Gulden. */
    Ang = "ANG",
    /** Angolan Kwanza. */
    Aoa = "AOA",
    /** Argentine Peso. */
    Ars = "ARS",
    /** Australian Dollar. */
    Aud = "AUD",
    /** Aruban Florin. */
    Awg = "AWG",
    /** Azerbaijani Manat. */
    Azn = "AZN",
    /** Bosnia and Herzegovina Convertible Mark. */
    Bam = "BAM",
    /** Barbadian Dollar. */
    Bbd = "BBD",
    /** Bangladeshi Taka. */
    Bdt = "BDT",
    /** Bulgarian Lev. */
    Bgn = "BGN",
    /** Bahraini Dinar. */
    Bhd = "BHD",
    /** Burundian Franc. */
    Bif = "BIF",
    /** Bermudian Dollar. */
    Bmd = "BMD",
    /** Brunei Dollar. */
    Bnd = "BND",
    /** Bolivian Boliviano. */
    Bob = "BOB",
    /** Brazilian Real. */
    Brl = "BRL",
    /** Bahamian Dollar. */
    Bsd = "BSD",
    /** Bhutanese Ngultrum. */
    Btn = "BTN",
    /** Botswana Pula. */
    Bwp = "BWP",
    /** Belarusian Ruble. */
    Byn = "BYN",
    /** Belarusian Ruble. */
    Byr = "BYR",
    /** Belize Dollar. */
    Bzd = "BZD",
    /** Canadian Dollar. */
    Cad = "CAD",
    /** Congolese Franc. */
    Cdf = "CDF",
    /** Swiss Franc. */
    Chf = "CHF",
    /** Unidad de Fomento. */
    Clf = "CLF",
    /** Chilean Peso. */
    Clp = "CLP",
    /** Chinese Renminbi Yuan. */
    Cny = "CNY",
    /** Colombian Peso. */
    Cop = "COP",
    /** Costa Rican Colón. */
    Crc = "CRC",
    /** Cuban Convertible Peso. */
    Cuc = "CUC",
    /** Cuban Peso. */
    Cup = "CUP",
    /** Cape Verdean Escudo. */
    Cve = "CVE",
    /** Cypriot pound. */
    Cyp = "CYP",
    /** Czech Koruna. */
    Czk = "CZK",
    /** Djiboutian Franc. */
    Djf = "DJF",
    /** Danish Krone. */
    Dkk = "DKK",
    /** Dominican Peso. */
    Dop = "DOP",
    /** Algerian Dinar. */
    Dzd = "DZD",
    /** Estonian Kroon. */
    Eek = "EEK",
    /** Egyptian Pound. */
    Egp = "EGP",
    /** Eritrean Nakfa. */
    Ern = "ERN",
    /** Ethiopian Birr. */
    Etb = "ETB",
    /** Euro. */
    Eur = "EUR",
    /** Fijian Dollar. */
    Fjd = "FJD",
    /** Falkland Pound. */
    Fkp = "FKP",
    /** British Pound. */
    Gbp = "GBP",
    /** British Penny. */
    Gbx = "GBX",
    /** Georgian Lari. */
    Gel = "GEL",
    /** Guernsey Pound. */
    Ggp = "GGP",
    /** Ghanaian Cedi. */
    Ghc = "GHC",
    /** Ghanaian Cedi. */
    Ghs = "GHS",
    /** Gibraltar Pound. */
    Gip = "GIP",
    /** Gambian Dalasi. */
    Gmd = "GMD",
    /** Guinean Franc. */
    Gnf = "GNF",
    /** Guatemalan Quetzal. */
    Gtq = "GTQ",
    /** Guyanese Dollar. */
    Gyd = "GYD",
    /** Hong Kong Dollar. */
    Hkd = "HKD",
    /** Honduran Lempira. */
    Hnl = "HNL",
    /** Croatian Kuna. */
    Hrk = "HRK",
    /** Haitian Gourde. */
    Htg = "HTG",
    /** Hungarian Forint. */
    Huf = "HUF",
    /** Indonesian Rupiah. */
    Idr = "IDR",
    /** Israeli New Sheqel. */
    Ils = "ILS",
    /** Isle of Man Pound. */
    Imp = "IMP",
    /** Indian Rupee. */
    Inr = "INR",
    /** Iraqi Dinar. */
    Iqd = "IQD",
    /** Iranian Rial. */
    Irr = "IRR",
    /** Icelandic Króna. */
    Isk = "ISK",
    /** Jersey Pound. */
    Jep = "JEP",
    /** Jamaican Dollar. */
    Jmd = "JMD",
    /** Jordanian Dinar. */
    Jod = "JOD",
    /** Japanese Yen. */
    Jpy = "JPY",
    /** Kenyan Shilling. */
    Kes = "KES",
    /** Kyrgyzstani Som. */
    Kgs = "KGS",
    /** Cambodian Riel. */
    Khr = "KHR",
    /** Kiribati Dollar. */
    Kid = "KID",
    /** Comorian Franc. */
    Kmf = "KMF",
    /** North Korean Won. */
    Kpw = "KPW",
    /** South Korean Won. */
    Krw = "KRW",
    /** Kuwaiti Dinar. */
    Kwd = "KWD",
    /** Cayman Islands Dollar. */
    Kyd = "KYD",
    /** Kazakhstani Tenge. */
    Kzt = "KZT",
    /** Lao Kip. */
    Lak = "LAK",
    /** Lebanese Pound. */
    Lbp = "LBP",
    /** Sri Lankan Rupee. */
    Lkr = "LKR",
    /** Liberian Dollar. */
    Lrd = "LRD",
    /** Lesotho Loti. */
    Lsl = "LSL",
    /** Lithuanian Litas. */
    Ltl = "LTL",
    /** Latvian Lats. */
    Lvl = "LVL",
    /** Libyan Dinar. */
    Lyd = "LYD",
    /** Moroccan Dirham. */
    Mad = "MAD",
    /** Moldovan Leu. */
    Mdl = "MDL",
    /** Malagasy Ariary. */
    Mga = "MGA",
    /** Macedonian Denar. */
    Mkd = "MKD",
    /** Myanmar Kyat. */
    Mmk = "MMK",
    /** Mongolian Tögrög. */
    Mnt = "MNT",
    /** Macanese Pataca. */
    Mop = "MOP",
    /** Mauritanian Ouguiya. */
    Mro = "MRO",
    /** Mauritanian New Ouguiya. */
    Mru = "MRU",
    /** Maltese Lira. */
    Mtl = "MTL",
    /** Mauritian Rupee. */
    Mur = "MUR",
    /** Maldivian Rufiyaa. */
    Mvr = "MVR",
    /** Malawian Kwacha. */
    Mwk = "MWK",
    /** Mexican Peso. */
    Mxn = "MXN",
    /** Malaysian Ringgit. */
    Myr = "MYR",
    /** Mozambican Metical. */
    Mzn = "MZN",
    /** Namibian Dollar. */
    Nad = "NAD",
    /** Nigerian Naira. */
    Ngn = "NGN",
    /** Nicaraguan Córdoba. */
    Nio = "NIO",
    /** Norwegian Krone. */
    Nok = "NOK",
    /** Nepalese Rupee. */
    Npr = "NPR",
    /** New Zealand Dollar. */
    Nzd = "NZD",
    /** Omani Rial. */
    Omr = "OMR",
    /** Panamanian Balboa. */
    Pab = "PAB",
    /** Peruvian Sol. */
    Pen = "PEN",
    /** Papua New Guinean Kina. */
    Pgk = "PGK",
    /** Philippine Peso. */
    Php = "PHP",
    /** Pakistani Rupee. */
    Pkr = "PKR",
    /** Polish Złoty. */
    Pln = "PLN",
    /** Paraguayan Guaraní. */
    Pyg = "PYG",
    /** Qatari Riyal. */
    Qar = "QAR",
    /** Romanian Leu. */
    Ron = "RON",
    /** Serbian Dinar. */
    Rsd = "RSD",
    /** Russian Ruble. */
    Rub = "RUB",
    /** Rwandan Franc. */
    Rwf = "RWF",
    /** Saudi Riyal. */
    Sar = "SAR",
    /** Solomon Islands Dollar. */
    Sbd = "SBD",
    /** Seychellois Rupee. */
    Scr = "SCR",
    /** Sudanese Pound. */
    Sdg = "SDG",
    /** Swedish Krona. */
    Sek = "SEK",
    /** Singapore Dollar. */
    Sgd = "SGD",
    /** Saint Helenian Pound. */
    Shp = "SHP",
    /** Slovak Koruna. */
    Skk = "SKK",
    /** Sierra Leonean Leone. */
    Sll = "SLL",
    /** Somali Shilling. */
    Sos = "SOS",
    /** Surinamese Dollar. */
    Srd = "SRD",
    /** South Sudanese Pound. */
    Ssp = "SSP",
    /** São Tomé and Príncipe Dobra. */
    Std = "STD",
    /** São Tomé and Príncipe Dobra. */
    Stn = "STN",
    /** Salvadoran Colón. */
    Svc = "SVC",
    /** Syrian Pound. */
    Syp = "SYP",
    /** Swazi Lilangeni. */
    Szl = "SZL",
    /** Thai Baht. */
    Thb = "THB",
    /** Tajikistani Somoni. */
    Tjs = "TJS",
    /** Turkmenistani Manat. */
    Tmm = "TMM",
    /** Turkmenistani Manat. */
    Tmt = "TMT",
    /** Tunisian Dinar. */
    Tnd = "TND",
    /** Tongan Paʻanga. */
    Top = "TOP",
    /** Turkish Lira. */
    Try = "TRY",
    /** Trinidad and Tobago Dollar. */
    Ttd = "TTD",
    /** New Taiwan Dollar. */
    Twd = "TWD",
    /** Tanzanian Shilling. */
    Tzs = "TZS",
    /** Ukrainian Hryvnia. */
    Uah = "UAH",
    /** Ugandan Shilling. */
    Ugx = "UGX",
    /** United States Dollar. */
    Usd = "USD",
    /** Uruguayan Peso. */
    Uyu = "UYU",
    /** Uzbekistan Som. */
    Uzs = "UZS",
    /** Venezuelan Bolívar. */
    Veb = "VEB",
    /** Venezuelan Bolívar soberano. */
    Ved = "VED",
    /** Venezuelan Bolívar fuerte. */
    Vef = "VEF",
    /** Venezuelan Bolívar soberano. */
    Ves = "VES",
    /** Vietnamese Đồng. */
    Vnd = "VND",
    /** Vanuatu Vatu. */
    Vuv = "VUV",
    /** Samoan Tala. */
    Wst = "WST",
    /** Central African Cfa Franc. */
    Xaf = "XAF",
    /** Silver (Troy Ounce). */
    Xag = "XAG",
    /** Gold (Troy Ounce). */
    Xau = "XAU",
    /** European Composite Unit. */
    Xba = "XBA",
    /** European Monetary Unit. */
    Xbb = "XBB",
    /** European Unit of Account 9. */
    Xbc = "XBC",
    /** European Unit of Account 17. */
    Xbd = "XBD",
    /** East Caribbean Dollar. */
    Xcd = "XCD",
    /** Special Drawing Rights. */
    Xdr = "XDR",
    /** UIC Franc. */
    Xfu = "XFU",
    /** West African Cfa Franc. */
    Xof = "XOF",
    /** Palladium. */
    Xpd = "XPD",
    /** Cfp Franc. */
    Xpf = "XPF",
    /** Platinum. */
    Xpt = "XPT",
    /** Codes specifically reserved for testing purposes. */
    Xts = "XTS",
    /** Yemeni Rial. */
    Yer = "YER",
    /** South African Rand. */
    Zar = "ZAR",
    /** Zambian Kwacha. */
    Zmk = "ZMK",
    /** Zambian Kwacha. */
    Zmw = "ZMW",
    /** Zimbabwean Dollar. */
    Zwd = "ZWD",
    /** Zimbabwean Dollar. */
    Zwl = "ZWL",
    /** Zimbabwean Dollar. */
    Zwn = "ZWN",
    /** Zimbabwean Dollar. */
    Zwr = "ZWR"
}
/** This is a default card entry point for the Minis Admin API. */
export type DefaultCardEntryPoint = EntryPoint & {
    __typename?: 'DefaultCardEntryPoint';
    /** The action text of the entry point. */
    actionText?: Maybe<Scalars['String']>;
    /** The ID of the entry point. */
    id?: Maybe<Scalars['ID']>;
    /** The image for the entry point. */
    image?: Maybe<Image>;
    /** The location of the entry point. */
    location?: Maybe<EntryPointLocation>;
    /** The ID of the owner of the entry point.  Empty indicates the entry point has multiple owners set by the `visibilityRule` */
    ownerId?: Maybe<Scalars['ID']>;
    /** The text of the entry point. */
    text?: Maybe<Scalars['String']>;
    /** The title of the entry point. */
    title: Scalars['String'];
    /** The date and time when the entry point was updated. */
    updatedAt: Scalars['ISO8601DateTime'];
    /** The visibility rule of the entry point. Empty indicates the entry point has a single owner set by the `ownerId`. */
    visibilityRule?: Maybe<Scalars['String']>;
};
/** The information needed to create a new default card entry point. */
export type DefaultCardEntryPointSetInput = {
    /** The action text of the entry point. */
    actionText?: InputMaybe<Scalars['String']>;
    /** The image for the entry point. */
    image?: InputMaybe<ImageInput>;
    /** The text of the entry point. */
    text?: InputMaybe<Scalars['String']>;
    /** The title of the entry point. */
    title: Scalars['String'];
};
/** A development store for a Shop Mini. */
export type DevelopmentStore = {
    __typename?: 'DevelopmentStore';
    /** An user-attributed URL used for sharing the shop with others. */
    shareUrl?: Maybe<Scalars['String']>;
    /** The domain of the development store. */
    shopDomain: Scalars['String'];
    /** The shop ID of the development store. */
    shopId: Scalars['ID'];
};
/** The connection type for DevelopmentStore. */
export type DevelopmentStoreConnection = {
    __typename?: 'DevelopmentStoreConnection';
    /** A list of edges. */
    edges: Array<DevelopmentStoreEdge>;
    /** A list of nodes. */
    nodes: Array<DevelopmentStore>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
};
/** An edge in a connection. */
export type DevelopmentStoreEdge = {
    __typename?: 'DevelopmentStoreEdge';
    /** A cursor for use in pagination. */
    cursor: Scalars['String'];
    /** The item at the end of the edge. */
    node?: Maybe<DevelopmentStore>;
};
export type EntryPoint = {
    /** The ID of the entry point. */
    id?: Maybe<Scalars['ID']>;
    /** The location of the entry point. */
    location?: Maybe<EntryPointLocation>;
    /** The ID of the owner of the entry point.  Empty indicates the entry point has multiple owners set by the `visibilityRule` */
    ownerId?: Maybe<Scalars['ID']>;
    /** The date and time when the entry point was updated. */
    updatedAt: Scalars['ISO8601DateTime'];
    /** The visibility rule of the entry point. Empty indicates the entry point has a single owner set by the `ownerId`. */
    visibilityRule?: Maybe<Scalars['String']>;
};
/** The connection type for EntryPoint. */
export type EntryPointConnection = {
    __typename?: 'EntryPointConnection';
    /** A list of edges. */
    edges?: Maybe<Array<Maybe<EntryPointEdge>>>;
    /** A list of nodes. */
    nodes?: Maybe<Array<Maybe<EntryPoint>>>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
};
/** Return type for the `entryPointDeleteAll` mutation. */
export type EntryPointDeleteAllPayload = {
    __typename?: 'EntryPointDeleteAllPayload';
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<EntryPointDeleteAllUserError>;
};
/** A user or client error that could occur during the execution of the `entryPointDeleteAll` mutation. */
export type EntryPointDeleteAllUserError = {
    __typename?: 'EntryPointDeleteAllUserError';
    /** Error code associated with the error. */
    code: EntryPointDeleteAllUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by EntryPointDeleteAllUserError. */
export declare enum EntryPointDeleteAllUserErrorCode {
    /** Error code when the shop is not found. */
    ShopNotFound = "SHOP_NOT_FOUND"
}
/** Return type for the `entryPointDeleteByOwner` mutation. */
export type EntryPointDeleteByOwnerPayload = {
    __typename?: 'EntryPointDeleteByOwnerPayload';
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<EntryPointDeleteByOwnerUserError>;
};
/** A user or client error that could occur during the execution of the `entryPointDeleteByOwner` mutation. */
export type EntryPointDeleteByOwnerUserError = {
    __typename?: 'EntryPointDeleteByOwnerUserError';
    /** Error code associated with the error. */
    code: EntryPointDeleteByOwnerUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by EntryPointDeleteByOwnerUserError. */
export declare enum EntryPointDeleteByOwnerUserErrorCode {
    /** Error code when the entry point definition is not found from the manifest. */
    DefinitionNotFound = "DEFINITION_NOT_FOUND",
    /** Error code when the entry point to be deleted is not found. */
    EntryPointNotFound = "ENTRY_POINT_NOT_FOUND"
}
/** Return type for the `entryPointDeleteByRule` mutation. */
export type EntryPointDeleteByRulePayload = {
    __typename?: 'EntryPointDeleteByRulePayload';
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<EntryPointDeleteByRuleUserError>;
};
/** A user or client error that could occur during the execution of the `entryPointDeleteByRule` mutation. */
export type EntryPointDeleteByRuleUserError = {
    __typename?: 'EntryPointDeleteByRuleUserError';
    /** Error code associated with the error. */
    code: EntryPointDeleteByRuleUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by EntryPointDeleteByRuleUserError. */
export declare enum EntryPointDeleteByRuleUserErrorCode {
    /** Error code when the entry point definition is not found from the manifest. */
    DefinitionNotFound = "DEFINITION_NOT_FOUND",
    /** Error code when the entry point to be deleted is not found. */
    EntryPointNotFound = "ENTRY_POINT_NOT_FOUND",
    /** Error code when the shop is not found. */
    ShopNotFound = "SHOP_NOT_FOUND"
}
/** An edge in a connection. */
export type EntryPointEdge = {
    __typename?: 'EntryPointEdge';
    /** A cursor for use in pagination. */
    cursor: Scalars['String'];
    /** The item at the end of the edge. */
    node?: Maybe<EntryPoint>;
};
/** The event status enum for an entry point. */
export declare enum EntryPointEventStatus {
    /** The active status for Mini entry point event type. */
    Active = "ACTIVE",
    /** The post active status for Mini entry point event type. */
    PostActive = "POST_ACTIVE",
    /** The pre active status for Mini entry point event type. */
    PreActive = "PRE_ACTIVE"
}
/** Return type for the `entryPointEventStatusUpdate` mutation. */
export type EntryPointEventStatusUpdatePayload = {
    __typename?: 'EntryPointEventStatusUpdatePayload';
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<EntryPointEventStatusUpdateUserError>;
};
/** A user or client error that could occur during the execution of the `entryPointEventStatusUpdate` mutation. */
export type EntryPointEventStatusUpdateUserError = {
    __typename?: 'EntryPointEventStatusUpdateUserError';
    /** Error code associated with the error. */
    code: EntryPointEventStatusUpdateUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by EntryPointEventStatusUpdateUserError. */
export declare enum EntryPointEventStatusUpdateUserErrorCode {
    /** Error code when the product is not found. */
    ProductNotFound = "PRODUCT_NOT_FOUND",
    /** Error code when the shop is not found. */
    ShopNotFound = "SHOP_NOT_FOUND"
}
/** The entry point location of a Mini. */
export declare enum EntryPointLocation {
    /** The Mini should be displayed on the home feed. */
    HomeFeed = "HOME_FEED",
    /** The Mini should be displayed on the order confirmation page. */
    OrderConfirmationPage = "ORDER_CONFIRMATION_PAGE",
    /** The Mini should be displayed on the order management page. */
    OrderManagementPage = "ORDER_MANAGEMENT_PAGE",
    /** The Mini should be displayed on the product page. */
    ProductPage = "PRODUCT_PAGE",
    /** The Mini should be displayed on the product details page context menu. */
    ProductPageContextMenu = "PRODUCT_PAGE_CONTEXT_MENU",
    /** The Mini should be displayed on the store page. */
    StorePage = "STORE_PAGE",
    /** The Mini should be displayed on the store page context menu. */
    StorePageContextMenu = "STORE_PAGE_CONTEXT_MENU"
}
/** Return type for the `entryPointSetByOwner` mutation. */
export type EntryPointSetByOwnerPayload = {
    __typename?: 'EntryPointSetByOwnerPayload';
    /** The entry point that was created or updated. */
    entryPoint?: Maybe<EntryPoint>;
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<EntryPointSetByOwnerUserError>;
};
/** A user or client error that could occur during the execution of the `entryPointSetByOwner` mutation. */
export type EntryPointSetByOwnerUserError = {
    __typename?: 'EntryPointSetByOwnerUserError';
    /** Error code associated with the error. */
    code: EntryPointSetByOwnerUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by EntryPointSetByOwnerUserError. */
export declare enum EntryPointSetByOwnerUserErrorCode {
    /** Error code when the entry point definition is not found from the manifest. */
    DefinitionNotFound = "DEFINITION_NOT_FOUND",
    /** Error code when an item is invalid for the home feed. */
    InvalidHomeFeedItem = "INVALID_HOME_FEED_ITEM",
    /** Error code when the mini is not eligible for using entry points. */
    MiniNotEligible = "MINI_NOT_ELIGIBLE",
    /** Error code when all entry point items are invalid. */
    NoValidItems = "NO_VALID_ITEMS",
    /** Error code when the product is not eligible for Shop Minis. */
    ProductNotEligible = "PRODUCT_NOT_ELIGIBLE",
    /** Error code when the shop does not have any Shopify App installed for the associated Shop Mini. */
    ShopifyAppNotInstalled = "SHOPIFY_APP_NOT_INSTALLED",
    /** Error code when the shop domain argument is not provided. */
    ShopDomainNotProvided = "SHOP_DOMAIN_NOT_PROVIDED",
    /** Error code when the shop is not eligible for Shop Minis. */
    ShopNotEligible = "SHOP_NOT_ELIGIBLE",
    /** Error code when the shop is not found. */
    ShopNotFound = "SHOP_NOT_FOUND",
    /** Error code when the entry point owner is not the expected type for the given entry point location. */
    UnexpectedOwnerId = "UNEXPECTED_OWNER_ID"
}
/** Return type for the `entryPointSetByRule` mutation. */
export type EntryPointSetByRulePayload = {
    __typename?: 'EntryPointSetByRulePayload';
    /** The entry point that was created or updated. */
    entryPoint?: Maybe<EntryPoint>;
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<EntryPointSetByRuleUserError>;
};
/** A user or client error that could occur during the execution of the `entryPointSetByRule` mutation. */
export type EntryPointSetByRuleUserError = {
    __typename?: 'EntryPointSetByRuleUserError';
    /** Error code associated with the error. */
    code: EntryPointSetByRuleUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by EntryPointSetByRuleUserError. */
export declare enum EntryPointSetByRuleUserErrorCode {
    /** The entry point definition is not found from the manifest. */
    DefinitionNotFound = "DEFINITION_NOT_FOUND",
    /** The visibility rule is invalid. */
    InvalidVisibilityRule = "INVALID_VISIBILITY_RULE",
    /** The mini is not eligible for using entry points. */
    MiniNotEligible = "MINI_NOT_ELIGIBLE",
    /** Error code when the shop does not have any Shopify App installed for the associated Shop Mini. */
    ShopifyAppNotInstalled = "SHOPIFY_APP_NOT_INSTALLED",
    /** Error code when the shop domain argument is not provided. */
    ShopDomainNotProvided = "SHOP_DOMAIN_NOT_PROVIDED",
    /** The shop is not eligible for Shop Minis. */
    ShopNotEligible = "SHOP_NOT_ELIGIBLE",
    /** The shop is not found. */
    ShopNotFound = "SHOP_NOT_FOUND"
}
/** The information needed to create a new entry point. */
export type EntryPointSetInput = {
    /** The default card entry point set input. */
    defaultCard?: InputMaybe<DefaultCardEntryPointSetInput>;
    /** The event card entry point set input. */
    eventCardV2?: InputMaybe<EventCardV2EntryPointSetInput>;
    /** The image collection entry point set input. */
    imageCollection?: InputMaybe<ImageCollectionEntryPointSetInput>;
    /** The image collection v2 entry point set input. */
    imageCollectionV2?: InputMaybe<ImageCollectionV2EntryPointSetInput>;
    /** The link entry point set input. */
    link?: InputMaybe<LinkEntryPointSetInput>;
    /** The product offer card entry point set input. */
    productOfferCard?: InputMaybe<ProductOfferCardEntryPointSetInput>;
    /** The video collection entry point set input. */
    videoCollection?: InputMaybe<VideoCollectionEntryPointSetInput>;
    /** The video collection entry point V2 set input. */
    videoCollectionV2?: InputMaybe<VideoCollectionV2EntryPointSetInput>;
};
/** The entry point type of a Mini. */
export declare enum EntryPointType {
    /** The Mini should be displayed as an action button. */
    ActionButton = "ACTION_BUTTON",
    /** The Mini should be displayed as a card with content. */
    ContentCard = "CONTENT_CARD",
    /** The Mini should be displayed as a card with content. */
    DefaultCard = "DEFAULT_CARD",
    /** The Mini should be displayed as a card with a reminder button. */
    EventCard = "EVENT_CARD",
    /** The Mini should be displayed as a card with a reminder button. */
    EventCardV2 = "EVENT_CARD_V2",
    /** The Mini should be displayed as a collection of images. */
    ImageCollection = "IMAGE_COLLECTION",
    /** The Mini should be displayed as a collection of images with related products. */
    ImageCollectionV2 = "IMAGE_COLLECTION_V2",
    /** The Mini should be displayed as a link. */
    Link = "LINK",
    /** The Mini should be displayed as a product offer card. */
    ProductOfferCard = "PRODUCT_OFFER_CARD",
    /** The Mini should be displayed as a collection of videos. */
    VideoCollection = "VIDEO_COLLECTION",
    /** The Mini should be displayed as a collection of videos. */
    VideoCollectionV2 = "VIDEO_COLLECTION_V2"
}
/** Represents the validity of an entry point visibility rule. */
export type EntryPointVisibilityRuleValidity = {
    __typename?: 'EntryPointVisibilityRuleValidity';
    /** The validity status of the rule. */
    status: EntryPointVisibilityRuleValidityStatus;
    /** The errors that occurred when validating the rule. */
    userErrors: Array<EntryPointVisibilityRuleValidityUserError>;
};
/** The error code for an entry point visibility rule error. */
export declare enum EntryPointVisibilityRuleValidityErrorCode {
    /** Rules cannot be applied to all fields. Please specify the field name. */
    FieldsUnspecified = "FIELDS_UNSPECIFIED",
    /** Incompatible comparator found for the given fields. */
    IncompatibleComparators = "INCOMPATIBLE_COMPARATORS",
    /** Incompatible values given to the fields. Please refer to https://shopify.dev/api/usage/search-syntax for more information. */
    IncompatibleQueryTypes = "INCOMPATIBLE_QUERY_TYPES",
    /** Rule is not parseable. Please refer to https://shopify.dev/api/usage/search-syntax for more information. */
    IncorrectSyntax = "INCORRECT_SYNTAX",
    /** Rule is too long. Please refer to https://shopify.dev/api/usage/search-syntax for more information. */
    MaximumLengthExceeded = "MAXIMUM_LENGTH_EXCEEDED",
    /** Unsupported fields given. Please refer to https://github.com/Shopify/shop-minis/blob/main/docs/ENTRY_POINT_VISIBILITY_RULE_FOR_PRODUCT_DETAILS_PAGES.md for more information. */
    UnsupportedFields = "UNSUPPORTED_FIELDS"
}
/** The validity status of an entry point visibility rule. */
export declare enum EntryPointVisibilityRuleValidityStatus {
    /** The rule is not valid. */
    Invalid = "INVALID",
    /** The rule is valid. */
    Valid = "VALID"
}
/** An error that occurred when validating an entry point visibility rule. */
export type EntryPointVisibilityRuleValidityUserError = {
    __typename?: 'EntryPointVisibilityRuleValidityUserError';
    /** The code of the error that occurred. */
    code: EntryPointVisibilityRuleValidityErrorCode;
    /** The path to the field that the error occurred on. */
    field: Array<Scalars['String']>;
    /** The message describing the error. */
    message: Scalars['String'];
};
/** An Event Card entry point. */
export type EventCardV2EntryPoint = EntryPoint & {
    __typename?: 'EventCardV2EntryPoint';
    /** The start time of the event. */
    eventLiveAt?: Maybe<Scalars['ISO8601DateTime']>;
    /** The status of the event. */
    eventStatus: Scalars['String'];
    /** The ID of the entry point. */
    id?: Maybe<Scalars['ID']>;
    /** The image for the card when the event is active. */
    image: Image;
    /** The location of the entry point. */
    location?: Maybe<EntryPointLocation>;
    /** The topic to subscribe to for notifications. */
    notificationTopic: Scalars['String'];
    /** The ID of the owner of the entry point.  Empty indicates the entry point has multiple owners set by the `visibilityRule` */
    ownerId?: Maybe<Scalars['ID']>;
    /** The image for the card before the event is active. */
    preActiveImage: Image;
    /** The text of the card. */
    text?: Maybe<Scalars['String']>;
    /** The title of the card. */
    title: Scalars['String'];
    /** The date and time when the entry point was updated. */
    updatedAt: Scalars['ISO8601DateTime'];
    /** The visibility rule of the entry point. Empty indicates the entry point has a single owner set by the `ownerId`. */
    visibilityRule?: Maybe<Scalars['String']>;
};
/** The event status of the Mini event card entry point. */
export declare enum EventCardV2EntryPointEventStatus {
    /** The active status for Mini entry point event type. */
    Active = "ACTIVE",
    /** The post active status for Mini entry point event type. */
    PostActive = "POST_ACTIVE",
    /** The pre active status for Mini entry point event type. */
    PreActive = "PRE_ACTIVE"
}
/** The information needed to create a new event card entry point. */
export type EventCardV2EntryPointSetInput = {
    /** The event start time for the event card entry point. */
    eventLiveAt?: InputMaybe<Scalars['ISO8601DateTime']>;
    /** The event status for the event card entry point. */
    eventStatus: EventCardV2EntryPointEventStatus;
    /** The image for the event card entry point when the event is active. */
    image: ImageInput;
    /** The notification topic for the event card entry point. */
    notificationTopic: Scalars['String'];
    /** The image for the event card entry point before the event is active. */
    preActiveImage: ImageInput;
    /** The text for the event card entry point. */
    text?: InputMaybe<Scalars['String']>;
    /** The title for the event card entry point. */
    title: Scalars['String'];
};
/** Represents a video hosted outside of Shopify. */
export type ExternalVideo = {
    __typename?: 'ExternalVideo';
    /** The alt text for the media. */
    alt?: Maybe<Scalars['String']>;
    /** The embed URL of the video for the respective host. */
    embedUrl: Scalars['URL'];
    /** The preview image for the media. */
    previewImage?: Maybe<Image>;
};
/** Represents a video hosted outside of Shopify. */
export type ExternalVideoInput = {
    /** A word or phrase to share the nature or contents of a media. */
    alt?: InputMaybe<Scalars['String']>;
    /** The embed URL of the video for the respective host. */
    embedUrl: Scalars['URL'];
    /** The preview image for the media. */
    previewImage?: InputMaybe<ImageInput>;
};
/** An HTTP request method. */
export declare enum HttpRequestMethod {
    /** The DELETE method. */
    Delete = "DELETE",
    /** The GET method. */
    Get = "GET",
    /** The PATCH method. */
    Patch = "PATCH",
    /** The POST method. */
    Post = "POST",
    /** The PUT method. */
    Put = "PUT"
}
/** The image for the entry point. */
export type Image = {
    __typename?: 'Image';
    /** URL of the image. */
    url: Scalars['URL'];
};
/** This is a Mini Image Collection entry point. */
export type ImageCollectionEntryPoint = EntryPoint & {
    __typename?: 'ImageCollectionEntryPoint';
    /** The ID of the entry point. */
    id?: Maybe<Scalars['ID']>;
    /** The items for the entry point. */
    items: Array<ImageCollectionEntryPointItem>;
    /** The layout for the entry point. */
    layout: ImageCollectionEntryPointLayout;
    /** The location of the entry point. */
    location?: Maybe<EntryPointLocation>;
    /** The ID of the owner of the entry point.  Empty indicates the entry point has multiple owners set by the `visibilityRule` */
    ownerId?: Maybe<Scalars['ID']>;
    /** The date and time when the entry point was updated. */
    updatedAt: Scalars['ISO8601DateTime'];
    /** The visibility rule of the entry point. Empty indicates the entry point has a single owner set by the `ownerId`. */
    visibilityRule?: Maybe<Scalars['String']>;
};
/** This is a Mini image collection entry point item. */
export type ImageCollectionEntryPointItem = {
    __typename?: 'ImageCollectionEntryPointItem';
    /** The external ID for the item. Provided by the partner and opaque to the Shop app. */
    externalId?: Maybe<Scalars['ID']>;
    /** The image for the item. */
    image: Image;
};
/** This is a Mini Image Collection entry point item. */
export type ImageCollectionEntryPointItemInput = {
    /** The external ID for the item. Provided by the partner and opaque to the Shop app. */
    externalId?: InputMaybe<Scalars['String']>;
    /** The image for the item. */
    image: ImageInput;
};
/** The layout of the Mini Image Collection entry point. */
export declare enum ImageCollectionEntryPointLayout {
    /** The layout is a carousel. */
    Carousel = "CAROUSEL",
    /** The layout is a grid. */
    Grid = "GRID"
}
/** The information needed to create a new image collection entry point. */
export type ImageCollectionEntryPointSetInput = {
    /** The items for the entry point. It can't be empty. */
    items: Array<ImageCollectionEntryPointItemInput>;
};
/** This is a Mini Image Collection V2 entry point. */
export type ImageCollectionV2EntryPoint = EntryPoint & {
    __typename?: 'ImageCollectionV2EntryPoint';
    /** The ID of the entry point. */
    id?: Maybe<Scalars['ID']>;
    /** The items for the entry point. */
    items: Array<ImageCollectionV2EntryPointItem>;
    /** The layout for the entry point. */
    layout: ImageCollectionEntryPointLayout;
    /** The location of the entry point. */
    location?: Maybe<EntryPointLocation>;
    /** The ID of the owner of the entry point.  Empty indicates the entry point has multiple owners set by the `visibilityRule` */
    ownerId?: Maybe<Scalars['ID']>;
    /** The date and time when the entry point was updated. */
    updatedAt: Scalars['ISO8601DateTime'];
    /** The visibility rule of the entry point. Empty indicates the entry point has a single owner set by the `ownerId`. */
    visibilityRule?: Maybe<Scalars['String']>;
};
/** This is a Mini image collection entry point item. */
export type ImageCollectionV2EntryPointItem = {
    __typename?: 'ImageCollectionV2EntryPointItem';
    /** The description for ImageCollectionV2EntryPoint item. */
    description?: Maybe<Scalars['String']>;
    /** The date when the ImageCollectionV2EntryPoint item was created. */
    displayDate?: Maybe<Scalars['ISO8601DateTime']>;
    /** The external ID for the item. Provided by the partner and opaque to the Shop app. */
    externalId?: Maybe<Scalars['ID']>;
    /** The image for the item. */
    image: Image;
    /** The list of products associated with this image. */
    relatedProducts: Array<ImageCollectionV2EntryPointItemRelatedProduct>;
};
/** This is a Mini Image Collection entry point item. */
export type ImageCollectionV2EntryPointItemInput = {
    /** The description for the ImageCollectionV2EntryPoint item. */
    description?: InputMaybe<Scalars['String']>;
    /** The date when the ImageCollectionV2EntryPoint item will be displayed. */
    displayDate?: InputMaybe<Scalars['ISO8601DateTime']>;
    /** The external ID for the item. Provided by the partner and opaque to the Shop app. */
    externalId: Scalars['String'];
    /** The image for the item. */
    image: ImageInput;
    /** The list of products associated with this image. */
    relatedProducts: Array<ImageCollectionV2EntryPointItemRelatedProductInput>;
};
/** The related product item shown on the image. */
export type ImageCollectionV2EntryPointItemRelatedProduct = {
    __typename?: 'ImageCollectionV2EntryPointItemRelatedProduct';
    /** The product ID for the entry point. */
    productId: Scalars['ID'];
    /** The product variant ID for the entry point. */
    productVariantId?: Maybe<Scalars['ID']>;
};
/** This is a related product for the image. */
export type ImageCollectionV2EntryPointItemRelatedProductInput = {
    /** The product ID for the entry point. */
    productId: Scalars['String'];
    /** The product variant ID for the entry point. */
    productVariantId?: InputMaybe<Scalars['String']>;
};
/** The information needed to create a new image collection entry point. */
export type ImageCollectionV2EntryPointSetInput = {
    /** The items for the entry point. It can't be empty. */
    items: Array<ImageCollectionV2EntryPointItemInput>;
};
/** The information needed to create a new image. */
export type ImageInput = {
    /** The URL of the Shopify hosted image. */
    url: Scalars['URL'];
};
/** A Link entry point to a Shop Mini. */
export type LinkEntryPoint = EntryPoint & {
    __typename?: 'LinkEntryPoint';
    /** The call to action text of the link entry point. */
    actionText: Scalars['String'];
    /** The ID of the entry point. */
    id?: Maybe<Scalars['ID']>;
    /** The location of the entry point. */
    location?: Maybe<EntryPointLocation>;
    /** The ID of the owner of the entry point.  Empty indicates the entry point has multiple owners set by the `visibilityRule` */
    ownerId?: Maybe<Scalars['ID']>;
    /** The date and time when the entry point was updated. */
    updatedAt: Scalars['ISO8601DateTime'];
    /** The visibility rule of the entry point. Empty indicates the entry point has a single owner set by the `ownerId`. */
    visibilityRule?: Maybe<Scalars['String']>;
};
/** The information needed to create a new link entry point. */
export type LinkEntryPointSetInput = {
    /** The call to action text of the link entry point. */
    actionText: Scalars['String'];
};
/** Information about a Shop Mini. */
export type Mini = {
    __typename?: 'Mini';
    /** The development Shopify app IDs. */
    developmentShopifyAppIds: Array<Scalars['ID']>;
    /** The development Shopify apps linked to the Mini. */
    developmentShopifyApps: Array<ShopifyApp>;
    /** The mini handle. */
    handle: Scalars['ID'];
    /** The partner name. */
    partnerName: Scalars['String'];
    /** The production Shopify app linked to the Mini. */
    productionShopifyApp?: Maybe<ShopifyApp>;
    /** The production Shopify app ID. */
    productionShopifyAppId?: Maybe<Scalars['ID']>;
};
/** Return type for the `miniCreate` mutation. */
export type MiniCreatePayload = {
    __typename?: 'MiniCreatePayload';
    /** The created Mini. */
    mini?: Maybe<Mini>;
    /** The API key token that was created. */
    token?: Maybe<Scalars['String']>;
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<MiniCreateUserError>;
};
/** A user or client error that could occur during the execution of the `miniCreate` mutation. */
export type MiniCreateUserError = {
    __typename?: 'MiniCreateUserError';
    /** Error code associated with the error. */
    code: MiniCreateUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by MiniCreateUserError. */
export declare enum MiniCreateUserErrorCode {
    /** Error code when the handle is not unique. */
    HandleNotUnique = "HANDLE_NOT_UNIQUE",
    /** Error code when the organization has too many Minis. */
    TooManyMinis = "TOO_MANY_MINIS",
    /** Error code when verification failed. */
    VerificationFailed = "VERIFICATION_FAILED"
}
/** Return type for the `miniLinkApp` mutation. */
export type MiniLinkAppPayload = {
    __typename?: 'MiniLinkAppPayload';
    /** The Mini. */
    mini?: Maybe<Mini>;
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<MiniLinkAppUserError>;
};
/** A user or client error that could occur during the execution of the `miniLinkApp` mutation. */
export type MiniLinkAppUserError = {
    __typename?: 'MiniLinkAppUserError';
    /** Error code associated with the error. */
    code: MiniLinkAppUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by MiniLinkAppUserError. */
export declare enum MiniLinkAppUserErrorCode {
    /** Error code when the app is already linked to a Mini. */
    AppAlreadyLinked = "APP_ALREADY_LINKED",
    /** Error code when the primary app is already set. */
    PrimaryAppAlreadySet = "PRIMARY_APP_ALREADY_SET",
    /** Error code when verification failed. */
    VerificationFailed = "VERIFICATION_FAILED"
}
/** Return type for the `miniToggle` mutation. */
export type MiniTogglePayload = {
    __typename?: 'MiniTogglePayload';
    /** The flag whether the Mini is enabled or disabled. */
    enabled?: Maybe<Scalars['Boolean']>;
};
/** Return type for the `miniUnlinkApp` mutation. */
export type MiniUnlinkAppPayload = {
    __typename?: 'MiniUnlinkAppPayload';
    /** The Mini. */
    mini?: Maybe<Mini>;
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<MiniUnlinkAppUserError>;
};
/** A user or client error that could occur during the execution of the `miniUnlinkApp` mutation. */
export type MiniUnlinkAppUserError = {
    __typename?: 'MiniUnlinkAppUserError';
    /** Error code associated with the error. */
    code: MiniUnlinkAppUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by MiniUnlinkAppUserError. */
export declare enum MiniUnlinkAppUserErrorCode {
    /** Error code when the app is not linked to the Mini. */
    AppNotLinked = "APP_NOT_LINKED",
    /** Error code when the app is used as the production app. */
    CannotUnlinkProductionApp = "CANNOT_UNLINK_PRODUCTION_APP"
}
/** The information needed to create a new money. */
export type MoneyInput = {
    /** Decimal money amount. */
    amount: Scalars['Decimal'];
    /** Currency code of the money. */
    currencyCode: CurrencyCode;
};
/** A money object capturing an amount and its currency. */
export type MoneyV2 = {
    __typename?: 'MoneyV2';
    /** The decimal amount. */
    amount: Scalars['Decimal'];
    /**
     * Approximate conversion of price to currencyCodeConvertedTo.
     * @deprecated DEPRECATED - No longer implemented
     */
    approximateConvertedAmount?: Maybe<Scalars['Decimal']>;
    /** The currency code. */
    currencyCode: Scalars['String'];
    /**
     * Currency code that price was converted to.
     * @deprecated DEPRECATED - No longer implemented
     */
    currencyCodeConvertedTo?: Maybe<Scalars['String']>;
};
export type Mutation = {
    __typename?: 'Mutation';
    /** Creates a new content. */
    contentCreate: ContentCreatePayload;
    /** Asynchronously deletes all entry points for the given shopDomain. Entry points created or updated after performing the mutation will not be deleted. */
    entryPointDeleteAll: EntryPointDeleteAllPayload;
    /** Deletes an entry point by using its ownerId. */
    entryPointDeleteByOwner: EntryPointDeleteByOwnerPayload;
    /** Deletes an entry point with a visibility rule. */
    entryPointDeleteByRule: EntryPointDeleteByRulePayload;
    /** Updates the status of an event entry point. */
    entryPointEventStatusUpdate: EntryPointEventStatusUpdatePayload;
    /** Creates or updates an entry point. */
    entryPointSetByOwner: EntryPointSetByOwnerPayload;
    /** Creates or updates entry point by setting a visibility rule. */
    entryPointSetByRule: EntryPointSetByRulePayload;
    /** Creates a new Mini. */
    miniCreate: MiniCreatePayload;
    /** Links a Shopify app to a Mini. */
    miniLinkApp: MiniLinkAppPayload;
    /** Enables or disables the Mini by partner. */
    miniToggle: MiniTogglePayload;
    /** Unlinks a Shopify app from a Mini. */
    miniUnlinkApp: MiniUnlinkAppPayload;
    /** Triggers a notification. */
    notificationTrigger: NotificationTriggerPayload;
    /** Sets the proxies for the Mini. */
    proxiesSet: ProxiesSetPayload;
    /** Downloads a report. */
    reportDownload: ReportDownloadPayload;
    /** Deletes a secret. */
    secretDelete: SecretDeletePayload;
    /** Sets a secret. */
    secretSet: SecretSetPayload;
    /** Cancels a pending submission. */
    submissionCancel: SubmissionCancelPayload;
    /** Creates a new submission. */
    submissionCreate: SubmissionCreatePayload;
    /** Creates a new staged upload for a submission. */
    submissionUploadCreate: SubmissionUploadCreatePayload;
    /** Creates a new user metafield definition. */
    userMetafieldDefinitionCreate: UserMetafieldDefinitionCreatePayload;
    /** Deletes a user metafield definition. */
    userMetafieldDefinitionDelete: UserMetafieldDefinitionDeletePayload;
    /** Verifies a user token. */
    userTokenVerify: UserTokenVerifyPayload;
};
export type MutationContentCreateArgs = {
    description?: InputMaybe<Scalars['String']>;
    externalId?: InputMaybe<Scalars['ID']>;
    imageUrl: Scalars['URL'];
    productIds?: InputMaybe<Array<Scalars['ID']>>;
    title: Scalars['String'];
};
export type MutationEntryPointDeleteAllArgs = {
    shopDomain: Scalars['String'];
};
export type MutationEntryPointDeleteByOwnerArgs = {
    location: EntryPointLocation;
    ownerId: Scalars['ID'];
    type: EntryPointType;
};
export type MutationEntryPointDeleteByRuleArgs = {
    location: EntryPointLocation;
    shopDomain: Scalars['String'];
    type: EntryPointType;
};
export type MutationEntryPointEventStatusUpdateArgs = {
    productId?: InputMaybe<Scalars['ID']>;
    shopDomain?: InputMaybe<Scalars['String']>;
    status: EntryPointEventStatus;
};
export type MutationEntryPointSetByOwnerArgs = {
    input: EntryPointSetInput;
    location: EntryPointLocation;
    ownerId: Scalars['ID'];
    shopDomain?: InputMaybe<Scalars['String']>;
};
export type MutationEntryPointSetByRuleArgs = {
    input: EntryPointSetInput;
    location: EntryPointLocation;
    shopDomain: Scalars['String'];
    visibilityRule: Scalars['String'];
};
export type MutationMiniCreateArgs = {
    name: Scalars['String'];
    organizationId: Scalars['ID'];
    partnersAccessToken: Scalars['String'];
    web?: InputMaybe<Scalars['Boolean']>;
};
export type MutationMiniLinkAppArgs = {
    appApiKey: Scalars['String'];
    partnersAccessToken: Scalars['String'];
    primary?: InputMaybe<Scalars['Boolean']>;
};
export type MutationMiniToggleArgs = {
    enable: Scalars['Boolean'];
};
export type MutationMiniUnlinkAppArgs = {
    appId: Scalars['ID'];
};
export type MutationNotificationTriggerArgs = {
    scopedEntityId: Scalars['ID'];
    shopDomain?: InputMaybe<Scalars['String']>;
    templateHandle: Scalars['String'];
};
export type MutationProxiesSetArgs = {
    proxies: Array<ProxyInput>;
};
export type MutationReportDownloadArgs = {
    date: Scalars['ISO8601Date'];
    name: ReportTypeEnum;
};
export type MutationSecretDeleteArgs = {
    key: Scalars['String'];
};
export type MutationSecretSetArgs = {
    key: Scalars['String'];
    value: Scalars['String'];
};
export type MutationSubmissionCancelArgs = {
    reference: Scalars['String'];
};
export type MutationSubmissionCreateArgs = {
    description: Scalars['String'];
    uploadId: Scalars['ID'];
};
export type MutationSubmissionUploadCreateArgs = {
    input: StagedUploadInput;
};
export type MutationUserMetafieldDefinitionCreateArgs = {
    definition: UserMetafieldDefinitionCreateInput;
};
export type MutationUserMetafieldDefinitionDeleteArgs = {
    identifier: UserMetafieldIdentifierInput;
};
export type MutationUserTokenVerifyArgs = {
    token: Scalars['String'];
};
/** Return type for the `notificationTrigger` mutation. */
export type NotificationTriggerPayload = {
    __typename?: 'NotificationTriggerPayload';
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<NotificationTriggerUserError>;
    /** The warnings related to the notification trigger. */
    warnings?: Maybe<Array<Warning>>;
};
/** A user or client error that could occur during the execution of the `notificationTrigger` mutation. */
export type NotificationTriggerUserError = {
    __typename?: 'NotificationTriggerUserError';
    /** Error code associated with the error. */
    code: NotificationTriggerUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by NotificationTriggerUserError. */
export declare enum NotificationTriggerUserErrorCode {
    /** Error code when the scoped entity is not found. */
    ScopedEntityNotFound = "SCOPED_ENTITY_NOT_FOUND",
    /** Error code when the shop is not found. */
    ShopNotFound = "SHOP_NOT_FOUND",
    /** Error code when the template handle is not found in the Mini's manifest. */
    TemplateNotFound = "TEMPLATE_NOT_FOUND",
    /** Error code when the template's topic_handle is invalid. */
    TopicNotFound = "TOPIC_NOT_FOUND",
    /** Error code when scopedEntityId object does not match topic scope. */
    TopicScopeNotMatchingEntity = "TOPIC_SCOPE_NOT_MATCHING_ENTITY"
}
/** Information about pagination in a connection. */
export type PageInfo = {
    __typename?: 'PageInfo';
    /** When paginating forwards, the cursor to continue. */
    endCursor?: Maybe<Scalars['String']>;
    /** When paginating forwards, are there more items? */
    hasNextPage: Scalars['Boolean'];
    /** When paginating backwards, are there more items? */
    hasPreviousPage: Scalars['Boolean'];
    /** When paginating backwards, the cursor to continue. */
    startCursor?: Maybe<Scalars['String']>;
};
/** Represents the eligibility of a product within Shop. */
export type ProductEligibility = {
    __typename?: 'ProductEligibility';
    /** The ID of the product. */
    productId: Scalars['ID'];
    /** The eligibility status of the product. */
    status: ProductEligibilityStatus;
};
/** The eligibility status of a product. */
export declare enum ProductEligibilityStatus {
    /** The product is eligible to appear in Shop. */
    Eligible = "ELIGIBLE",
    /** The product is ineligible to appear in Shop. */
    Ineligible = "INELIGIBLE"
}
/** An Product Offer Card entry point. */
export type ProductOfferCardEntryPoint = EntryPoint & {
    __typename?: 'ProductOfferCardEntryPoint';
    /** The discounted price of the offered product. */
    discountedPrice: MoneyV2;
    /** The product offer expiration time. */
    expiresAt?: Maybe<Scalars['ISO8601DateTime']>;
    /** The ID of the entry point. */
    id?: Maybe<Scalars['ID']>;
    /** The image for the offered product. */
    image?: Maybe<Image>;
    /** The location of the entry point. */
    location?: Maybe<EntryPointLocation>;
    /** The original price of the offered product. */
    originalPrice: MoneyV2;
    /** The ID of the owner of the entry point.  Empty indicates the entry point has multiple owners set by the `visibilityRule` */
    ownerId?: Maybe<Scalars['ID']>;
    /** The product ID of the offered product on the card. */
    productId: Scalars['ID'];
    /** The title of the offered product. */
    title?: Maybe<Scalars['String']>;
    /** The date and time when the entry point was updated. */
    updatedAt: Scalars['ISO8601DateTime'];
    /** The variant ID of the offered product's variant on the card. */
    variantId?: Maybe<Scalars['ID']>;
    /** The visibility rule of the entry point. Empty indicates the entry point has a single owner set by the `ownerId`. */
    visibilityRule?: Maybe<Scalars['String']>;
};
/** The information needed to create a new product offer card entry point. */
export type ProductOfferCardEntryPointSetInput = {
    /** The text for the product offer card entry point. */
    discountedPrice: MoneyInput;
    /** The event start time for the product offer card entry point. */
    expiresAt?: InputMaybe<Scalars['ISO8601DateTime']>;
    /** The image for the product offer card entry point. */
    image?: InputMaybe<ImageInput>;
    /** The text for the product offer card entry point. */
    originalPrice: MoneyInput;
    /** The product ID for the product offer card entry point. */
    productId: Scalars['ID'];
    /** The title for the product offer card entry point. */
    title?: InputMaybe<Scalars['String']>;
    /** The variant ID for the product offer card entry point. */
    variantId?: InputMaybe<Scalars['ID']>;
};
/** Return type for the `proxiesSet` mutation. */
export type ProxiesSetPayload = {
    __typename?: 'ProxiesSetPayload';
    /** The proxies that were created or updated. */
    proxies?: Maybe<Array<Proxy>>;
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<ProxiesSetUserError>;
};
/** A user or client error that could occur during the execution of the `proxiesSet` mutation. */
export type ProxiesSetUserError = {
    __typename?: 'ProxiesSetUserError';
    /** Error code associated with the error. */
    code: ProxiesSetUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by ProxiesSetUserError. */
export declare enum ProxiesSetUserErrorCode {
    /** Error code when the proxy configuration is invalid. */
    Invalid = "INVALID"
}
/** A proxy. */
export type Proxy = {
    __typename?: 'Proxy';
    /** The methods that are allowed to be proxied. */
    allowedMethods?: Maybe<Array<HttpRequestMethod>>;
    /** A list of headers that will be appended to the request. Formatted as `Some-Key: Some Value`. */
    appendedHeaders?: Maybe<Array<Scalars['String']>>;
    /** A JSON schema to match the request body against. */
    bodyJsonSchema?: Maybe<Scalars['JSON']>;
    /** A pattern for matching the target URL. */
    targetUrlPattern: Scalars['String'];
    /** The interval of the user rate limit in seconds. */
    userRateLimitInterval?: Maybe<Scalars['Int']>;
    /** The number of requests per user per interval. */
    userRateLimitRequests?: Maybe<Scalars['Int']>;
};
/** The information needed to create or update a proxy. */
export type ProxyInput = {
    /** The methods that are allowed to be proxied. */
    allowedMethods?: InputMaybe<Array<HttpRequestMethod>>;
    /** A list of headers that will be appended to the request. Formatted as `Some-Key: Some Value`. */
    appendedHeaders?: InputMaybe<Array<Scalars['String']>>;
    /** A JSON schema to match the request body against. */
    bodyJsonSchema?: InputMaybe<Scalars['JSON']>;
    /** A pattern for matching the target URL. */
    targetUrlPattern: Scalars['String'];
    /** The interval of the user rate limit in seconds. */
    userRateLimitInterval?: InputMaybe<Scalars['Int']>;
    /** The number of requests per user per interval. */
    userRateLimitRequests?: InputMaybe<Scalars['Int']>;
};
export type Query = {
    __typename?: 'Query';
    /** Returns attributions for orders made through a Mini within Shop. */
    attributions: AttributionConnection;
    /**
     * Returns development stores for the Shop Mini.
     * @deprecated No longer supported.
     */
    developmentStores: DevelopmentStoreConnection;
    /** Returns whether a given entry point visibility rule is valid. */
    entryPointVisibilityRuleValidity: EntryPointVisibilityRuleValidity;
    /** Returns a list of entry points given the filters. */
    entryPoints: EntryPointConnection;
    /** Returns information about a Mini based on the provided API key. */
    mini?: Maybe<Mini>;
    /** Returns eligibilities for products within Shop. */
    productEligibilities: Array<ProductEligibility>;
    /** Returns proxies for the Shop Mini. */
    proxies: Array<Proxy>;
    /** Lists all available reports and their dates. */
    reports: ReportConnection;
    /** Returns secrets for the Shop Mini. */
    secrets: Array<Secret>;
    /** Returns eligibilities for shops within Shop. */
    shopEligibilities: Array<ShopEligibility>;
    /** Returns submissions for the Shop Mini. */
    submissions: SubmissionConnection;
    /** Returns a list of user metafield definitions. */
    userMetafieldDefinitions: UserMetafieldDefinitionConnection;
};
export type QueryAttributionsArgs = {
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
    orderId?: InputMaybe<Scalars['ID']>;
    shopDomain?: InputMaybe<Scalars['String']>;
};
export type QueryDevelopmentStoresArgs = {
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
};
export type QueryEntryPointVisibilityRuleValidityArgs = {
    rule: Scalars['String'];
};
export type QueryEntryPointsArgs = {
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
    location?: InputMaybe<EntryPointLocation>;
    shopDomain: Scalars['String'];
    type?: InputMaybe<EntryPointType>;
    updatedAt?: InputMaybe<TimeRangeFilter>;
};
export type QueryProductEligibilitiesArgs = {
    productIds: Array<Scalars['ID']>;
};
export type QueryReportsArgs = {
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    date?: InputMaybe<Scalars['ISO8601Date']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
    name: ReportTypeEnum;
};
export type QueryShopEligibilitiesArgs = {
    shopDomains?: InputMaybe<Array<Scalars['String']>>;
};
export type QuerySubmissionsArgs = {
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
};
export type QueryUserMetafieldDefinitionsArgs = {
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
};
/** Represents a report available for a Mini. */
export type Report = {
    __typename?: 'Report';
    /** The date of the report in ISO 8601 format. */
    date: Scalars['ISO8601Date'];
    /** The name of the report. */
    name: ReportTypeEnum;
};
/** The connection type for Report. */
export type ReportConnection = {
    __typename?: 'ReportConnection';
    /** A list of edges. */
    edges: Array<ReportEdge>;
    /** A list of nodes. */
    nodes: Array<Report>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
};
/** Return type for the `reportDownload` mutation. */
export type ReportDownloadPayload = {
    __typename?: 'ReportDownloadPayload';
    /** The date and time when the URL expires. */
    expiresAt?: Maybe<Scalars['ISO8601DateTime']>;
    /** A URL that can be used to download the report. The URL is valid for 5 days. */
    url?: Maybe<Scalars['URL']>;
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<ReportDownloadUserError>;
};
/** A user or client error that could occur during the execution of the `reportDownload` mutation. */
export type ReportDownloadUserError = {
    __typename?: 'ReportDownloadUserError';
    /** Error code associated with the error. */
    code: ReportDownloadUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by ReportDownloadUserError. */
export declare enum ReportDownloadUserErrorCode {
    /** The requested report could not be found. */
    NotFound = "NOT_FOUND"
}
/** An edge in a connection. */
export type ReportEdge = {
    __typename?: 'ReportEdge';
    /** A cursor for use in pagination. */
    cursor: Scalars['String'];
    /** The item at the end of the edge. */
    node?: Maybe<Report>;
};
/** The type of report to retrieve. */
export declare enum ReportTypeEnum {
    /** Content impressions report. */
    ContentImpressions = "CONTENT_IMPRESSIONS",
    /** Product impressions report. */
    ProductImpressions = "PRODUCT_IMPRESSIONS",
    /** Sales report. */
    Sales = "SALES",
    /** Usage statistics report. */
    UsageStats = "USAGE_STATS"
}
/** A secret. */
export type Secret = {
    __typename?: 'Secret';
    /** The time the secret was created. */
    createdAt: Scalars['ISO8601DateTime'];
    /** The key of the secret. */
    key: Scalars['String'];
    /** The time the secret was updated. */
    updatedAt: Scalars['ISO8601DateTime'];
};
/** Return type for the `secretDelete` mutation. */
export type SecretDeletePayload = {
    __typename?: 'SecretDeletePayload';
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<SecretDeleteUserError>;
};
/** A user or client error that could occur during the execution of the `secretDelete` mutation. */
export type SecretDeleteUserError = {
    __typename?: 'SecretDeleteUserError';
    /** Error code associated with the error. */
    code: SecretDeleteUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by SecretDeleteUserError. */
export declare enum SecretDeleteUserErrorCode {
    /** Error code when the secret could not be found. */
    NotFound = "NOT_FOUND"
}
/** Return type for the `secretSet` mutation. */
export type SecretSetPayload = {
    __typename?: 'SecretSetPayload';
    /** The secret that was set. */
    secret?: Maybe<Secret>;
};
/** Represents the eligibility of a shop within Shop. */
export type ShopEligibility = {
    __typename?: 'ShopEligibility';
    /** The domain of the shop. */
    shopDomain?: Maybe<Scalars['String']>;
    /**
     * The ID of the shop.
     * @deprecated DEPRECATED - Please use shopDomain instead.
     */
    shopId?: Maybe<Scalars['ID']>;
    /** The eligibility status of the shop. */
    status: ShopEligibilityStatus;
};
/** The eligibility status of a shop. */
export declare enum ShopEligibilityStatus {
    /** The shop is eligible to appear in Shop. */
    Eligible = "ELIGIBLE",
    /** The shop is ineligible to appear in Shop. */
    Ineligible = "INELIGIBLE"
}
/** A Shopify app. */
export type ShopifyApp = {
    __typename?: 'ShopifyApp';
    /** The Shopify app ID. */
    id: Scalars['ID'];
    /** The Shopify app title. */
    title: Scalars['String'];
};
/** A staged upload where the file can be uploaded to and an id to identify it. */
export type StagedUpload = {
    __typename?: 'StagedUpload';
    /** The headers to send with the upload request. */
    headers: Scalars['String'];
    /** The ID of the staged upload. */
    id: Scalars['ID'];
    /** The URL to upload the file to. */
    url: Scalars['URL'];
};
/** The information needed to create a new staged upload. */
export type StagedUploadInput = {
    /** The base64-encoded md5 hash of the file contents. */
    checksum: Scalars['String'];
    /** The size of the file in bytes. */
    fileSize: Scalars['Int'];
    /** The name of the file. */
    filename: Scalars['String'];
    /** The MIME of the file. */
    mimeType: Scalars['String'];
};
/** A submission for a Shop Mini. */
export type Submission = {
    __typename?: 'Submission';
    /** A description of the Shop Mini and any changes since the last released version. */
    description: Scalars['String'];
    /** The unique reference for the submission. */
    reference: Scalars['String'];
    /** The status of the submission. */
    status: SubmissionStatus;
    /** The date and time the submission was submitted. */
    submittedAt: Scalars['ISO8601DateTime'];
};
/** Return type for the `submissionCancel` mutation. */
export type SubmissionCancelPayload = {
    __typename?: 'SubmissionCancelPayload';
    /** The cancelled submission. */
    submission?: Maybe<Submission>;
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<SubmissionCancelUserError>;
};
/** A user or client error that could occur during the execution of the `submissionCancel` mutation. */
export type SubmissionCancelUserError = {
    __typename?: 'SubmissionCancelUserError';
    /** Error code associated with the error. */
    code: SubmissionCancelUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by SubmissionCancelUserError. */
export declare enum SubmissionCancelUserErrorCode {
    /** Error code when the submission is not found. */
    NotFound = "NOT_FOUND",
    /** Error code when the submission does not have a pending status. */
    NotPending = "NOT_PENDING"
}
/** The connection type for Submission. */
export type SubmissionConnection = {
    __typename?: 'SubmissionConnection';
    /** A list of edges. */
    edges: Array<SubmissionEdge>;
    /** A list of nodes. */
    nodes: Array<Submission>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
};
/** Return type for the `submissionCreate` mutation. */
export type SubmissionCreatePayload = {
    __typename?: 'SubmissionCreatePayload';
    /** The submission that was created. */
    submission?: Maybe<Submission>;
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<SubmissionCreateUserError>;
};
/** A user or client error that could occur during the execution of the `submissionCreate` mutation. */
export type SubmissionCreateUserError = {
    __typename?: 'SubmissionCreateUserError';
    /** Error code associated with the error. */
    code: SubmissionCreateUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by SubmissionCreateUserError. */
export declare enum SubmissionCreateUserErrorCode {
    /** Error code when there is already a pending submission. */
    AlreadyPendingSubmission = "ALREADY_PENDING_SUBMISSION",
    /** Error code when the file does not exist in the storage service. */
    FileNotFound = "FILE_NOT_FOUND",
    /** Error code when the upload ID is not valid. Either it is does not point to a blob or is not signed correctly. */
    UploadNotFound = "UPLOAD_NOT_FOUND"
}
/** An edge in a connection. */
export type SubmissionEdge = {
    __typename?: 'SubmissionEdge';
    /** A cursor for use in pagination. */
    cursor: Scalars['String'];
    /** The item at the end of the edge. */
    node?: Maybe<Submission>;
};
/** The status of a submission. */
export declare enum SubmissionStatus {
    /** The submission has been approved. */
    Approved = "APPROVED",
    /** The submission has been cancelled. */
    Cancelled = "CANCELLED",
    /** The submission is pending review. */
    Pending = "PENDING",
    /** The submission has been rejected. */
    Rejected = "REJECTED"
}
/** Return type for the `submissionUploadCreate` mutation. */
export type SubmissionUploadCreatePayload = {
    __typename?: 'SubmissionUploadCreatePayload';
    /** The staged upload that was created. */
    upload?: Maybe<StagedUpload>;
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<SubmissionUploadCreateUserError>;
};
/** A user or client error that could occur during the execution of the `submissionUploadCreate` mutation. */
export type SubmissionUploadCreateUserError = {
    __typename?: 'SubmissionUploadCreateUserError';
    /** Error code associated with the error. */
    code: SubmissionUploadCreateUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by SubmissionUploadCreateUserError. */
export declare enum SubmissionUploadCreateUserErrorCode {
    /** Error code when an invalid checksum is provided. */
    InvalidChecksum = "INVALID_CHECKSUM",
    /** Error code when the file size is less than 0 or exceeds 5242880 bytes. */
    InvalidFileSize = "INVALID_FILE_SIZE",
    /** Error code when an invalid MIME type is provided. */
    InvalidMimeType = "INVALID_MIME_TYPE"
}
/** This filter selects objects that were updated within a specified time range. */
export type TimeRangeFilter = {
    /** The maximum updated at date and time in the range. */
    max?: InputMaybe<Scalars['ISO8601DateTime']>;
    /** The minimum updated at date and time in the range. */
    min?: InputMaybe<Scalars['ISO8601DateTime']>;
};
/** A metafield definition for a Mini. */
export type UserMetafieldDefinition = {
    __typename?: 'UserMetafieldDefinition';
    /** The description of the metafield definition. */
    description?: Maybe<Scalars['String']>;
    /** The key of the metafield definition. */
    key: Scalars['String'];
    /** The name of the metafield definition. */
    name: Scalars['String'];
    /** The type of the metafield definition. */
    type: Scalars['String'];
};
/** The connection type for UserMetafieldDefinition. */
export type UserMetafieldDefinitionConnection = {
    __typename?: 'UserMetafieldDefinitionConnection';
    /** A list of edges. */
    edges: Array<UserMetafieldDefinitionEdge>;
    /** A list of nodes. */
    nodes: Array<UserMetafieldDefinition>;
    /** Information to aid in pagination. */
    pageInfo: PageInfo;
};
/** Input fields for creating a metafield definition. */
export type UserMetafieldDefinitionCreateInput = {
    /** The description of the metafield definition. */
    description: Scalars['String'];
    /** The key of the metafield definition. */
    key: Scalars['String'];
    /** The name of the metafield definition. */
    name: Scalars['String'];
    /** The type of the metafield definition. */
    type: Scalars['String'];
};
/** Return type for the `userMetafieldDefinitionCreate` mutation. */
export type UserMetafieldDefinitionCreatePayload = {
    __typename?: 'UserMetafieldDefinitionCreatePayload';
    /** The created definition. */
    createdDefinition?: Maybe<UserMetafieldDefinition>;
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<UserMetafieldDefinitionCreateUserError>;
};
/** A user or client error that could occur during the execution of the `userMetafieldDefinitionCreate` mutation. */
export type UserMetafieldDefinitionCreateUserError = {
    __typename?: 'UserMetafieldDefinitionCreateUserError';
    /** Error code associated with the error. */
    code: UserMetafieldDefinitionCreateUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by UserMetafieldDefinitionCreateUserError. */
export declare enum UserMetafieldDefinitionCreateUserErrorCode {
    /** The definition already exists. */
    DefinitionAlreadyExists = "DEFINITION_ALREADY_EXISTS"
}
/** Return type for the `userMetafieldDefinitionDelete` mutation. */
export type UserMetafieldDefinitionDeletePayload = {
    __typename?: 'UserMetafieldDefinitionDeletePayload';
    /** The deleted definition. */
    deletedDefinition?: Maybe<UserMetafieldDefinition>;
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<UserMetafieldDefinitionDeleteUserError>;
};
/** A user or client error that could occur during the execution of the `userMetafieldDefinitionDelete` mutation. */
export type UserMetafieldDefinitionDeleteUserError = {
    __typename?: 'UserMetafieldDefinitionDeleteUserError';
    /** Error code associated with the error. */
    code: UserMetafieldDefinitionDeleteUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by UserMetafieldDefinitionDeleteUserError. */
export declare enum UserMetafieldDefinitionDeleteUserErrorCode {
    /** Returned when the definition was not found. */
    DefinitionNotFound = "DEFINITION_NOT_FOUND"
}
/** An edge in a connection. */
export type UserMetafieldDefinitionEdge = {
    __typename?: 'UserMetafieldDefinitionEdge';
    /** A cursor for use in pagination. */
    cursor: Scalars['String'];
    /** The item at the end of the edge. */
    node?: Maybe<UserMetafieldDefinition>;
};
/** Input fields for identifying a user metafield definition. */
export type UserMetafieldIdentifierInput = {
    /** The key of the metafield definition. */
    key: Scalars['String'];
};
/** The state of the user. */
export declare enum UserState {
    /** User has not verified by Shop. */
    Guest = "GUEST",
    /** User has been verified by Shop. */
    Verified = "VERIFIED"
}
/** Return type for the `userTokenVerify` mutation. */
export type UserTokenVerifyPayload = {
    __typename?: 'UserTokenVerifyPayload';
    /** The expiration date of the token. */
    tokenExpiresAt?: Maybe<Scalars['ISO8601DateTime']>;
    /** List of errors that occured while executing the mutation. */
    userErrors: Array<UserTokenVerifyUserError>;
    /** A permanent identifier for the user. */
    userIdentifier?: Maybe<Scalars['String']>;
    /** The state of the user. */
    userState?: Maybe<UserState>;
};
/** A user or client error that could occur during the execution of the `userTokenVerify` mutation. */
export type UserTokenVerifyUserError = {
    __typename?: 'UserTokenVerifyUserError';
    /** Error code associated with the error. */
    code: UserTokenVerifyUserErrorCode;
    /** Which input value this error came from. */
    field?: Maybe<Array<Scalars['String']>>;
    /** A description of the error. */
    message: Scalars['String'];
};
/** Possible error codes that can be returned by UserTokenVerifyUserError. */
export declare enum UserTokenVerifyUserErrorCode {
    /** The token is for a different mini. */
    InvalidMini = "INVALID_MINI",
    /** The token has expired. */
    TokenExpired = "TOKEN_EXPIRED",
    /** The token is invalid. */
    TokenInvalid = "TOKEN_INVALID",
    /** The user was not found. */
    UserNotFound = "USER_NOT_FOUND"
}
/** This is a Mini video collection entry point. */
export type VideoCollectionEntryPoint = EntryPoint & {
    __typename?: 'VideoCollectionEntryPoint';
    /** The ID of the entry point. */
    id?: Maybe<Scalars['ID']>;
    /** The items for the entry point. */
    items: Array<VideoCollectionEntryPointItem>;
    /** The location of the entry point. */
    location?: Maybe<EntryPointLocation>;
    /** The ID of the owner of the entry point.  Empty indicates the entry point has multiple owners set by the `visibilityRule` */
    ownerId?: Maybe<Scalars['ID']>;
    /** The date and time when the entry point was updated. */
    updatedAt: Scalars['ISO8601DateTime'];
    /** The visibility rule of the entry point. Empty indicates the entry point has a single owner set by the `ownerId`. */
    visibilityRule?: Maybe<Scalars['String']>;
};
/** This is a Mini video collection entry point item. */
export type VideoCollectionEntryPointItem = {
    __typename?: 'VideoCollectionEntryPointItem';
    /**
     * The content creator for the item.
     * @deprecated No longer used.
     */
    contentCreator?: Maybe<ContentCreator>;
    /** The external ID for the item. Provided by the partner and opaque to the Shop app. */
    externalId?: Maybe<Scalars['ID']>;
    /** The fallback image for the item. */
    fallbackImage: Image;
    /** The product ID for the item. */
    productId?: Maybe<Scalars['ID']>;
    /** The video for the item. */
    video?: Maybe<ExternalVideo>;
};
/** This is a Mini Video Collection entry point item. */
export type VideoCollectionEntryPointItemInput = {
    /** The external ID for the item. Provided by the partner and opaque to the Shop app. */
    externalId?: InputMaybe<Scalars['String']>;
    /** The fallback image for the entry point. */
    fallbackImage: ImageInput;
    /** The product ID for the entry point. */
    productId?: InputMaybe<Scalars['ID']>;
    /** The product variant ID for the entry point. */
    productVariantId?: InputMaybe<Scalars['ID']>;
    /** The video for the entry point. */
    video: ExternalVideoInput;
};
/** The information needed to create or update a video collection entry point. */
export type VideoCollectionEntryPointSetInput = {
    /** The items for the entry point. It can't be empty. */
    items: Array<VideoCollectionEntryPointItemInput>;
};
/** This is a Mini video collection V2 entry point. */
export type VideoCollectionV2EntryPoint = EntryPoint & {
    __typename?: 'VideoCollectionV2EntryPoint';
    /** The ID of the entry point. */
    id?: Maybe<Scalars['ID']>;
    /** The items for the entry point. */
    items: Array<VideoCollectionV2EntryPointItem>;
    /** The location of the entry point. */
    location?: Maybe<EntryPointLocation>;
    /** The ID of the owner of the entry point.  Empty indicates the entry point has multiple owners set by the `visibilityRule` */
    ownerId?: Maybe<Scalars['ID']>;
    /** The date and time when the entry point was updated. */
    updatedAt: Scalars['ISO8601DateTime'];
    /** The visibility rule of the entry point. Empty indicates the entry point has a single owner set by the `ownerId`. */
    visibilityRule?: Maybe<Scalars['String']>;
};
/** This is a content creator that may appear next to a Mini entry point. */
export type VideoCollectionV2EntryPointContentCreator = {
    __typename?: 'VideoCollectionV2EntryPointContentCreator';
    /** The avatar of the content creator. */
    avatar?: Maybe<Image>;
    /** The name of the content creator. */
    name: Scalars['String'];
};
/** This is a Mini video collection entry point item. */
export type VideoCollectionV2EntryPointItem = {
    __typename?: 'VideoCollectionV2EntryPointItem';
    /**
     * The content creator for the item.
     * @deprecated No longer used.
     */
    contentCreator?: Maybe<VideoCollectionV2EntryPointContentCreator>;
    /** The external ID for the item. Provided by the partner and opaque to the Shop app. */
    externalId: Scalars['ID'];
    /** The fallback image for the item. */
    fallbackImage: Image;
    /** The preview video to be used in the entry point. */
    previewVideo?: Maybe<ExternalVideo>;
    /** The list of products associated with this video. */
    relatedProducts: Array<VideoCollectionV2EntryPointRelatedProduct>;
    /** The video for the item. */
    video?: Maybe<ExternalVideo>;
};
/** This is a Mini Video Collection V2 entry point item. */
export type VideoCollectionV2EntryPointItemInput = {
    /** The external ID for the item. Provided by the partner and opaque to the Shop app. */
    externalId: Scalars['String'];
    /** The fallback image for the entry point. */
    fallbackImage: ImageInput;
    /** The video to be shown in the entry point. Should be shorter and limited to the most important part. */
    previewVideo?: InputMaybe<ExternalVideoInput>;
    /** The list of products associated with this video. */
    relatedProducts: Array<VideoCollectionV2EntryPointItemRelatedProductInput>;
    /** The video for the entry point. */
    video: ExternalVideoInput;
};
/** This is a related product for the video. */
export type VideoCollectionV2EntryPointItemRelatedProductInput = {
    /** The product ID for the entry point. */
    productId: Scalars['ID'];
    /** The product variant ID for the entry point. */
    productVariantId?: InputMaybe<Scalars['ID']>;
};
/** The related product item shown on the video. */
export type VideoCollectionV2EntryPointRelatedProduct = {
    __typename?: 'VideoCollectionV2EntryPointRelatedProduct';
    /** The product ID for the entry point. */
    productId: Scalars['ID'];
    /** The product variant ID for the entry point. */
    productVariantId?: Maybe<Scalars['ID']>;
};
/** The information needed to create or update a video collection V2 entry point. */
export type VideoCollectionV2EntryPointSetInput = {
    /** The items for the entry point. It can't be empty. */
    items: Array<VideoCollectionV2EntryPointItemInput>;
};
/** Informs API user about non critical casualties during the execution of a query or a mutation. */
export type Warning = {
    __typename?: 'Warning';
    /** Text identifier of the warning. */
    code: Scalars['String'];
    /** Description of the warning. */
    message: Scalars['String'];
};
export type CancelSubmissionMutationVariables = Exact<{
    reference: Scalars['String'];
}>;
export type CancelSubmissionMutation = {
    __typename?: 'Mutation';
    submissionCancel: {
        __typename?: 'SubmissionCancelPayload';
        submission?: {
            __typename?: 'Submission';
            reference: string;
            description: string;
            status: SubmissionStatus;
            submittedAt: any;
        } | null;
        userErrors: Array<{
            __typename?: 'SubmissionCancelUserError';
            code: SubmissionCancelUserErrorCode;
            message: string;
            field?: Array<string> | null;
        }>;
    };
};
export type CreateSubmissionMutationVariables = Exact<{
    description: Scalars['String'];
    uploadId: Scalars['ID'];
}>;
export type CreateSubmissionMutation = {
    __typename?: 'Mutation';
    submissionCreate: {
        __typename?: 'SubmissionCreatePayload';
        submission?: {
            __typename?: 'Submission';
            reference: string;
            description: string;
            status: SubmissionStatus;
            submittedAt: any;
        } | null;
        userErrors: Array<{
            __typename?: 'SubmissionCreateUserError';
            code: SubmissionCreateUserErrorCode;
            message: string;
            field?: Array<string> | null;
        }>;
    };
};
export type CreateUploadMutationVariables = Exact<{
    filename: Scalars['String'];
    fileSize: Scalars['Int'];
    checksum: Scalars['String'];
    mimeType: Scalars['String'];
}>;
export type CreateUploadMutation = {
    __typename?: 'Mutation';
    submissionUploadCreate: {
        __typename?: 'SubmissionUploadCreatePayload';
        upload?: {
            __typename?: 'StagedUpload';
            url: any;
            headers: string;
            id: string;
        } | null;
        userErrors: Array<{
            __typename?: 'SubmissionUploadCreateUserError';
            code: SubmissionUploadCreateUserErrorCode;
            message: string;
            field?: Array<string> | null;
        }>;
    };
};
export type LinkedAppsQueryVariables = Exact<{
    [key: string]: never;
}>;
export type LinkedAppsQuery = {
    __typename?: 'Query';
    mini?: {
        __typename?: 'Mini';
        productionShopifyApp?: {
            __typename?: 'ShopifyApp';
            id: string;
            title: string;
        } | null;
        developmentShopifyApps: Array<{
            __typename?: 'ShopifyApp';
            id: string;
            title: string;
        }>;
    } | null;
};
export type SubmissionsQueryVariables = Exact<{
    first?: InputMaybe<Scalars['Int']>;
}>;
export type SubmissionsQuery = {
    __typename?: 'Query';
    submissions: {
        __typename?: 'SubmissionConnection';
        nodes: Array<{
            __typename?: 'Submission';
            reference: string;
            description: string;
            status: SubmissionStatus;
            submittedAt: any;
        }>;
        pageInfo: {
            __typename?: 'PageInfo';
            hasNextPage: boolean;
            hasPreviousPage: boolean;
            startCursor?: string | null;
            endCursor?: string | null;
        };
    };
};
export type MiniCreateMutationVariables = Exact<{
    name: Scalars['String'];
    organizationId: Scalars['ID'];
    partnersAccessToken: Scalars['String'];
}>;
export type MiniCreateMutation = {
    __typename?: 'Mutation';
    miniCreate: {
        __typename?: 'MiniCreatePayload';
        token?: string | null;
        mini?: {
            __typename?: 'Mini';
            handle: string;
        } | null;
        userErrors: Array<{
            __typename?: 'MiniCreateUserError';
            code: MiniCreateUserErrorCode;
            message: string;
            field?: Array<string> | null;
        }>;
    };
};
export type MiniLinkAppMutationVariables = Exact<{
    appApiKey: Scalars['String'];
    partnersAccessToken: Scalars['String'];
    primary?: InputMaybe<Scalars['Boolean']>;
}>;
export type MiniLinkAppMutation = {
    __typename?: 'Mutation';
    miniLinkApp: {
        __typename?: 'MiniLinkAppPayload';
        mini?: {
            __typename?: 'Mini';
            handle: string;
            productionShopifyAppId?: string | null;
            developmentShopifyAppIds: Array<string>;
        } | null;
        userErrors: Array<{
            __typename?: 'MiniLinkAppUserError';
            code: MiniLinkAppUserErrorCode;
            message: string;
            field?: Array<string> | null;
        }>;
    };
};
export type MiniUnlinkAppMutationVariables = Exact<{
    appId: Scalars['ID'];
}>;
export type MiniUnlinkAppMutation = {
    __typename?: 'Mutation';
    miniUnlinkApp: {
        __typename?: 'MiniUnlinkAppPayload';
        mini?: {
            __typename?: 'Mini';
            handle: string;
            productionShopifyAppId?: string | null;
            developmentShopifyAppIds: Array<string>;
        } | null;
        userErrors: Array<{
            __typename?: 'MiniUnlinkAppUserError';
            code: MiniUnlinkAppUserErrorCode;
            message: string;
            field?: Array<string> | null;
        }>;
    };
};
export type MiniQueryVariables = Exact<{
    [key: string]: never;
}>;
export type MiniQuery = {
    __typename?: 'Query';
    mini?: {
        __typename?: 'Mini';
        handle: string;
        productionShopifyAppId?: string | null;
        developmentShopifyAppIds: Array<string>;
    } | null;
};
export type ProxiesQueryVariables = Exact<{
    [key: string]: never;
}>;
export type ProxiesQuery = {
    __typename?: 'Query';
    proxies: Array<{
        __typename?: 'Proxy';
        allowedMethods?: Array<HttpRequestMethod> | null;
        appendedHeaders?: Array<string> | null;
        bodyJsonSchema?: any | null;
        targetUrlPattern: string;
        userRateLimitInterval?: number | null;
        userRateLimitRequests?: number | null;
    }>;
};
export type ProxiesSetMutationVariables = Exact<{
    proxies: Array<ProxyInput> | ProxyInput;
}>;
export type ProxiesSetMutation = {
    __typename?: 'Mutation';
    proxiesSet: {
        __typename?: 'ProxiesSetPayload';
        proxies?: Array<{
            __typename?: 'Proxy';
            targetUrlPattern: string;
        }> | null;
        userErrors: Array<{
            __typename?: 'ProxiesSetUserError';
            code: ProxiesSetUserErrorCode;
            message: string;
        }>;
    };
};
export type SecretDeleteMutationVariables = Exact<{
    key: Scalars['String'];
}>;
export type SecretDeleteMutation = {
    __typename?: 'Mutation';
    secretDelete: {
        __typename?: 'SecretDeletePayload';
        userErrors: Array<{
            __typename?: 'SecretDeleteUserError';
            code: SecretDeleteUserErrorCode;
            field?: Array<string> | null;
            message: string;
        }>;
    };
};
export type SecretSetMutationVariables = Exact<{
    key: Scalars['String'];
    secretValue: Scalars['String'];
}>;
export type SecretSetMutation = {
    __typename?: 'Mutation';
    secretSet: {
        __typename?: 'SecretSetPayload';
        secret?: {
            __typename?: 'Secret';
            key: string;
        } | null;
    };
};
export type SecretsQueryVariables = Exact<{
    [key: string]: never;
}>;
export type SecretsQuery = {
    __typename?: 'Query';
    secrets: Array<{
        __typename?: 'Secret';
        key: string;
    }>;
};
export type UserMetafieldDefinitionCreateMutationVariables = Exact<{
    definition: UserMetafieldDefinitionCreateInput;
}>;
export type UserMetafieldDefinitionCreateMutation = {
    __typename?: 'Mutation';
    userMetafieldDefinitionCreate: {
        __typename?: 'UserMetafieldDefinitionCreatePayload';
        createdDefinition?: {
            __typename?: 'UserMetafieldDefinition';
            description?: string | null;
            name: string;
            key: string;
        } | null;
        userErrors: Array<{
            __typename?: 'UserMetafieldDefinitionCreateUserError';
            code: UserMetafieldDefinitionCreateUserErrorCode;
            message: string;
            field?: Array<string> | null;
        }>;
    };
};
export type UserMetafieldDefinitionDeleteMutationVariables = Exact<{
    key: Scalars['String'];
}>;
export type UserMetafieldDefinitionDeleteMutation = {
    __typename?: 'Mutation';
    userMetafieldDefinitionDelete: {
        __typename?: 'UserMetafieldDefinitionDeletePayload';
        deletedDefinition?: {
            __typename?: 'UserMetafieldDefinition';
            key: string;
        } | null;
        userErrors: Array<{
            __typename?: 'UserMetafieldDefinitionDeleteUserError';
            code: UserMetafieldDefinitionDeleteUserErrorCode;
            message: string;
            field?: Array<string> | null;
        }>;
    };
};
export type UserMetafieldDefinitionsQueryVariables = Exact<{
    [key: string]: never;
}>;
export type UserMetafieldDefinitionsQuery = {
    __typename?: 'Query';
    userMetafieldDefinitions: {
        __typename?: 'UserMetafieldDefinitionConnection';
        nodes: Array<{
            __typename?: 'UserMetafieldDefinition';
            description?: string | null;
            name: string;
            key: string;
            type: string;
        }>;
    };
};
export declare const CancelSubmissionDocument: DocumentNode<CancelSubmissionMutation, Exact<{
    reference: Scalars['String'];
}>>;
export declare const CreateSubmissionDocument: DocumentNode<CreateSubmissionMutation, Exact<{
    description: Scalars['String'];
    uploadId: Scalars['ID'];
}>>;
export declare const CreateUploadDocument: DocumentNode<CreateUploadMutation, Exact<{
    filename: Scalars['String'];
    fileSize: Scalars['Int'];
    checksum: Scalars['String'];
    mimeType: Scalars['String'];
}>>;
export declare const LinkedAppsDocument: DocumentNode<LinkedAppsQuery, Exact<{
    [key: string]: never;
}>>;
export declare const SubmissionsDocument: DocumentNode<SubmissionsQuery, Exact<{
    first?: InputMaybe<number> | undefined;
}>>;
export declare const MiniCreateDocument: DocumentNode<MiniCreateMutation, Exact<{
    name: Scalars['String'];
    organizationId: Scalars['ID'];
    partnersAccessToken: Scalars['String'];
}>>;
export declare const MiniLinkAppDocument: DocumentNode<MiniLinkAppMutation, Exact<{
    appApiKey: Scalars['String'];
    partnersAccessToken: Scalars['String'];
    primary?: InputMaybe<boolean> | undefined;
}>>;
export declare const MiniUnlinkAppDocument: DocumentNode<MiniUnlinkAppMutation, Exact<{
    appId: Scalars['ID'];
}>>;
export declare const MiniDocument: DocumentNode<MiniQuery, Exact<{
    [key: string]: never;
}>>;
export declare const ProxiesDocument: DocumentNode<ProxiesQuery, Exact<{
    [key: string]: never;
}>>;
export declare const ProxiesSetDocument: DocumentNode<ProxiesSetMutation, Exact<{
    proxies: Array<ProxyInput> | ProxyInput;
}>>;
export declare const SecretDeleteDocument: DocumentNode<SecretDeleteMutation, Exact<{
    key: Scalars['String'];
}>>;
export declare const SecretSetDocument: DocumentNode<SecretSetMutation, Exact<{
    key: Scalars['String'];
    secretValue: Scalars['String'];
}>>;
export declare const SecretsDocument: DocumentNode<SecretsQuery, Exact<{
    [key: string]: never;
}>>;
export declare const UserMetafieldDefinitionCreateDocument: DocumentNode<UserMetafieldDefinitionCreateMutation, Exact<{
    definition: UserMetafieldDefinitionCreateInput;
}>>;
export declare const UserMetafieldDefinitionDeleteDocument: DocumentNode<UserMetafieldDefinitionDeleteMutation, Exact<{
    key: Scalars['String'];
}>>;
export declare const UserMetafieldDefinitionsDocument: DocumentNode<UserMetafieldDefinitionsQuery, Exact<{
    [key: string]: never;
}>>;
