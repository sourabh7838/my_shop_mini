import { LocalStorage } from '../../public/node/local-storage.js';
interface CacheValue<T> {
    value: T;
    timestamp: number;
}
export type IntrospectionUrlKey = `identity-introspection-url-${string}`;
export type PackageVersionKey = `npm-package-${string}`;
export type NotificationsKey = `notifications-${string}`;
export type NotificationKey = `notification-${string}`;
type MostRecentOccurrenceKey = `most-recent-occurrence-${string}`;
type RateLimitKey = `rate-limited-occurrences-${string}`;
type ExportedKey = IntrospectionUrlKey | PackageVersionKey | NotificationsKey | NotificationKey;
interface Cache {
    [introspectionUrlKey: IntrospectionUrlKey]: CacheValue<string>;
    [packageVersionKey: PackageVersionKey]: CacheValue<string>;
    [notifications: NotificationsKey]: CacheValue<string>;
    [notification: NotificationKey]: CacheValue<string>;
    [MostRecentOccurrenceKey: MostRecentOccurrenceKey]: CacheValue<boolean>;
    [rateLimitKey: RateLimitKey]: CacheValue<number[]>;
}
export interface ConfSchema {
    sessionStore: string;
    cache?: Cache;
}
/**
 * Get session.
 *
 * @returns Session.
 */
export declare function getSession(config?: LocalStorage<ConfSchema>): string | undefined;
/**
 * Set session.
 *
 * @param session - Session.
 */
export declare function setSession(session: string, config?: LocalStorage<ConfSchema>): void;
/**
 * Remove session.
 */
export declare function removeSession(config?: LocalStorage<ConfSchema>): void;
type CacheValueForKey<TKey extends keyof Cache> = NonNullable<Cache[TKey]>['value'];
/**
 * Fetch from cache, or run the provided function to get the value, and cache it
 * before returning it.
 * @param key - The key to use for the cache.
 * @param fn - The function to run to get the value to cache, if a cache miss occurs.
 * @param timeout - The maximum valid age of a cached value, in milliseconds.
 * If the cached value is older than this, it will be refreshed.
 * @returns The value from the cache or the result of the function.
 */
export declare function cacheRetrieveOrRepopulate(key: ExportedKey, fn: () => Promise<CacheValueForKey<typeof key>>, timeout?: number, config?: LocalStorage<ConfSchema>): Promise<CacheValueForKey<typeof key>>;
export declare function cacheStore(key: ExportedKey, value: string, config?: LocalStorage<ConfSchema>): void;
/**
 * Fetch from cache if already populated, otherwise return undefined.
 * @param key - The key to use for the cache.
 * @returns The chache element.
 */
export declare function cacheRetrieve(key: ExportedKey, config?: LocalStorage<ConfSchema>): CacheValue<string> | undefined;
export declare function cacheClear(config?: LocalStorage<ConfSchema>): void;
interface TimeInterval {
    days?: number;
    hours?: number;
    minutes?: number;
    seconds?: number;
}
/**
 * Execute a task only if the most recent occurrence of the task is older than the specified timeout.
 * @param key - The key to use for the cache.
 * @param timeout - The maximum valid age of the most recent occurrence, expressed as an object with
 * days, hours, minutes, and seconds properties.
 * If the most recent occurrence is older than this, the task will be executed.
 * @param task - The task to run if the most recent occurrence is older than the timeout.
 * @returns true if the task was run, or false if the task was not run.
 */
export declare function runAtMinimumInterval(key: string, timeout: TimeInterval, task: () => Promise<void>, config?: LocalStorage<ConfSchema>): Promise<boolean>;
interface RunWithRateLimitOptions {
    /**
     * The key to use for the cache.
     */
    key: string;
    /**
     * The number of times the task can be run within the limit
     */
    limit: number;
    /**
     * The window of time after which the rate limit is refreshed,
     * expressed as an object with days, hours, minutes, and seconds properties.
     * If the most recent occurrence is older than this, the task will be executed.
     */
    timeout: TimeInterval;
    /**
     * The task to run if the most recent occurrence is older than the timeout.
     */
    task: () => Promise<void>;
}
/**
 * Execute a task with a time-based rate limit. The rate limit is enforced by
 * checking how many times that task has been executed in a window of time ending
 * at the current time. If the task has been executed more than the allowed number
 * of times in that window, the task will not be executed.
 *
 * Note that this function has side effects, as it will also remove events prior
 * to the window of time that is being checked.
 * @param options - The options for the rate limiting.
 * @returns true, or undefined if the task was not run.
 */
export declare function runWithRateLimit(options: RunWithRateLimitOptions, config?: LocalStorage<ConfSchema>): Promise<boolean>;
export declare function getConfigStoreForPartnerStatus(): LocalStorage<{
    [partnerToken: string]: {
        status: true;
        checkedAt: string;
    };
}>;
export declare function getCachedPartnerAccountStatus(partnersToken: string): true | null;
export declare function setCachedPartnerAccountStatus(partnersToken: string): void;
export {};
