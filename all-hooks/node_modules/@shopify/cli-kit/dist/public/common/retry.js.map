{"version":3,"file":"retry.js","sourceRoot":"","sources":["../../../src/public/common/retry.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;GAcG;AACH,MAAM,CAAC,KAAK,UAAU,mCAAmC,CACvD,aAA+B,EAC/B,iBAAyC,EACzC,OAAO,GAAG,CAAC;IAEX,IAAI,SAAwB,CAAA;IAC5B,IAAI;QACF,SAAS,GAAG,MAAM,aAAa,EAAE,CAAA;QACjC,OAAO,SAAS,CAAA;KACjB;IAAC,OAAO,GAAG,EAAE;QACZ,IAAI,OAAO,GAAG,CAAC,EAAE;YACf,6DAA6D;YAC7D,MAAM,iBAAiB,EAAE,CAAA;YACzB,OAAO,mCAAmC,CAAC,aAAa,EAAE,iBAAiB,EAAE,OAAO,GAAG,CAAC,CAAC,CAAA;SAC1F;QACD,MAAM,GAAG,CAAA;KACV;AACH,CAAC","sourcesContent":["/**\n * Perform an action optimistically. If it fails the first time, first initiate\n * a provided recovery procedure, then retry the action. If it fails again,\n * throw the error.\n *\n * This is useful for actions that may fail due to recoverable errors, such as\n * an expired token that can be refreshed. In this case, the recovery procedure\n * would refresh the token.\n *\n * @param performAction - The action to perform.\n * @param recoveryProcedure - The recovery procedure to perform if the action\n * fails the first time.\n * @param retries - The number of times to retry the action if an error happens.\n * @returns The result of the action.\n */\nexport async function performActionWithRetryAfterRecovery<T>(\n  performAction: () => Promise<T>,\n  recoveryProcedure: () => Promise<unknown>,\n  retries = 1,\n): Promise<T> {\n  let returnVal: T | undefined\n  try {\n    returnVal = await performAction()\n    return returnVal\n  } catch (err) {\n    if (retries > 0) {\n      // Run the provided recovery procedure, then retry the action\n      await recoveryProcedure()\n      return performActionWithRetryAfterRecovery(performAction, recoveryProcedure, retries - 1)\n    }\n    throw err\n  }\n}\n"]}