import { ZodObject, z } from 'zod';
export { z as zod } from 'zod';
/**
 * Type alias for a zod object schema that produces a given shape once parsed.
 */
export type ZodObjectOf<T> = ZodObject<any, any, any, T>;
/**
 * Returns a new schema that is the same as the input schema, but with all nested schemas set to strict.
 *
 * @param schema - The schema to make strict.
 * @returns The result strict schema.
 */
export declare function deepStrict<T>(schema: T): T;
/**
 * Returns a human-readable string of the list of zod errors.
 *
 * @param errors - The list of zod errors.
 * @returns The human-readable string.
 */
export declare function errorsToString(errors: z.ZodIssueBase[]): string;
/**
 * A neutral type for the result of a parsing/validation operation.
 *
 * As some validation can happen via JSON Schema, we prefer to use a type that isn't wholly dependent on Zod (or
 * JSON Schema).
 */
export type ParseConfigurationResult<TConfiguration> = {
    state: 'ok';
    data: TConfiguration;
    errors: undefined;
} | {
    state: 'error';
    data: undefined;
    errors: Pick<z.ZodIssueBase, 'path' | 'message'>[];
};
