{"version":3,"file":"json-schema.js","sourceRoot":"","sources":["../../../src/public/node/json-schema.ts"],"names":[],"mappings":"AAEA,OAAO,EAAC,YAAY,EAAC,MAAM,qBAAqB,CAAA;AAChD,OAAO,EAAC,UAAU,EAAC,MAAM,qBAAqB,CAAA;AAC9C,OAAO,EAAC,GAAG,EAA4B,MAAM,KAAK,CAAA;AAClD,OAAO,UAAU,MAAM,qCAAqC,CAAA;AAI5D;;;;;;;GAOG;AACH,MAAM,CAAC,KAAK,UAAU,mBAAmB,CAAC,MAAc;IACtD,0FAA0F;IAC1F,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA;IACvC,MAAM,UAAU,CAAC,WAAW,CAAC,YAAY,EAAE,EAAC,OAAO,EAAE,EAAC,QAAQ,EAAE,KAAK,EAAC,EAAC,CAAC,CAAA;IACxE,OAAO,YAAY,CAAA;AACrB,CAAC;AAED;;;;;;;;GAQG;AACH,MAAM,UAAU,kBAAkB,CAChC,OAAe,EACf,MAAoB;IAEpB,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,EAAC,eAAe,EAAE,IAAI,EAAC,CAAC,CAAA;IAC5C,MAAM,SAAS,GAAG,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,CAAA;IACrC,SAAS,CAAC,OAAO,CAAC,CAAA;IAElB,iGAAiG;IACjG,IAAI,gBAAgB,CAAA;IACpB,IAAI,SAAS,CAAC,MAAM,IAAI,SAAS,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;QACnD,gBAAgB,GAAG,uBAAuB,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,EAAE,MAAM,CAAC,CAAA;QAC7E,OAAO;YACL,KAAK,EAAE,OAAO;YACd,IAAI,EAAE,SAAS;YACf,MAAM,EAAE,gBAAgB;YACxB,SAAS,EAAE,SAAS,CAAC,MAAM;SAC5B,CAAA;KACF;IACD,OAAO;QACL,KAAK,EAAE,IAAI;QACX,IAAI,EAAE,OAAO;QACb,MAAM,EAAE,SAAS;QACjB,SAAS,EAAE,SAAS;KACrB,CAAA;AACH,CAAC;AAED;;;;;;;GAOG;AACH,SAAS,uBAAuB,CAAC,SAAqB,EAAE,OAAe,EAAE,MAAoB;IAC3F,oGAAoG;IACpG,MAAM,MAAM,GAAG,mBAAmB,CAAC,SAAS,EAAE,OAAO,EAAE,MAAM,CAAC,CAAA;IAE9D,8CAA8C;IAC9C,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;QAC1B,MAAM,IAAI,GAAa,KAAK,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;QAC7D,IAAI,KAAK,CAAC,MAAM,CAAC,eAAe,EAAE;YAChC,MAAM,eAAe,GAAG,KAAK,CAAC,MAAM,CAAC,eAAyB,CAAA;YAC9D,OAAO,EAAC,IAAI,EAAE,CAAC,GAAG,IAAI,EAAE,eAAe,CAAC,EAAE,OAAO,EAAE,UAAU,EAAC,CAAA;SAC/D;QAED,IAAI,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE;YACrB,MAAM,YAAY,GAAG,KAAK,CAAC,MAAM,CAAC,IAAc,CAAA;YAChD,MAAM,UAAU,GAAG,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAA;YACxD,OAAO,EAAC,IAAI,EAAE,OAAO,EAAE,YAAY,YAAY,cAAc,OAAO,UAAU,EAAE,EAAC,CAAA;SAClF;QAED,IAAI,KAAK,CAAC,OAAO,KAAK,OAAO,IAAI,KAAK,CAAC,OAAO,KAAK,OAAO,EAAE;YAC1D,OAAO,EAAC,IAAI,EAAE,OAAO,EAAE,eAAe,EAAC,CAAA;SACxC;QAED,IAAI,KAAK,CAAC,MAAM,CAAC,aAAa,EAAE;YAC9B,MAAM,aAAa,GAAG,KAAK,CAAC,MAAM,CAAC,aAAyB,CAAA;YAC5D,MAAM,WAAW,GAAG,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAA;YACzD,OAAO;gBACL,IAAI;gBACJ,OAAO,EAAE,gCAAgC,aAAa;qBACnD,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;qBACrC,IAAI,CAAC,KAAK,CAAC,cAAc,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,EAAE,CAAC,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC;aAC7E,CAAA;SACF;QAED,IAAI,KAAK,CAAC,MAAM,CAAC,UAAU,EAAE;YAC3B,MAAM,UAAU,GAAG,KAAK,CAAC,MAAM,CAAC,UAAoB,CAAA;YACpD,MAAM,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,KAAK,CAAA;YAChC,MAAM,WAAW,GAAG,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAA;YAEzD,IAAI,cAAc,GAAG,UAAU,CAAA;YAC/B,QAAQ,UAAU,EAAE;gBAClB,KAAK,IAAI;oBACP,cAAc,GAAG,uBAAuB,CAAA;oBACxC,MAAK;gBACP,KAAK,GAAG;oBACN,cAAc,GAAG,WAAW,CAAA;oBAC5B,MAAK;gBACP,KAAK,IAAI;oBACP,cAAc,GAAG,0BAA0B,CAAA;oBAC3C,MAAK;gBACP,KAAK,GAAG;oBACN,cAAc,GAAG,cAAc,CAAA;oBAC/B,MAAK;aACR;YAED,OAAO;gBACL,IAAI;gBACJ,OAAO,EAAE,UAAU,CAAC,GAAG,OAAO,WAAW,YAAY,cAAc,IAAI,KAAK,EAAE,CAAC;aAChF,CAAA;SACF;QAED,OAAO;YACL,IAAI;YACJ,OAAO,EAAE,KAAK,CAAC,OAAO;SACvB,CAAA;IACH,CAAC,CAAC,CAAA;AACJ,CAAC;AAED;;;;;;;;;;;;;;;;;;GAkBG;AACH,SAAS,mBAAmB,CAAC,SAAqB,EAAE,OAAe,EAAE,MAAoB;IACvF,MAAM,GAAG,GAAG,IAAI,GAAG,EAAE,CAAA;IACrB,IAAI,MAAM,GAAG,SAAS,CAAA;IAEtB,MAAM,mBAAmB,GAAG,IAAI,GAAG,EAAE,CAAA;IACrC,OAAO,IAAI,EAAE;QACX,MAAM,UAAU,GAAG,MAAM,CAAC,MAAM,CAC9B,CAAC,KAAK,EAAE,EAAE,CACR,CAAC,KAAK,CAAC,OAAO,KAAK,OAAO,IAAI,KAAK,CAAC,OAAO,KAAK,OAAO,CAAC,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,KAAK,CAAC,YAAY,CAAC,CAC3G,CAAC,CAAC,CAAC,CAAA;QACJ,IAAI,UAAU,KAAK,SAAS,EAAE;YAC5B,MAAK;SACN;QACD,iEAAiE;QACjE,MAAM,eAAe,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,YAAY,CAAC,UAAU,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAA;QAEzG,4GAA4G;QAC5G,IAAI,4BAA4B,GAAe,CAAC,UAAU,CAAC,CAAA;QAE3D,yDAAyD;QACzD,MAAM,gBAAgB,GAAG,UAAU,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAA;QACpF,MAAM,YAAY,GAAG,YAAY,CAAiB,MAAM,EAAE,gBAAgB,CAAC,CAAA;QAC3E,qDAAqD;QACrD,MAAM,YAAY,GAAG,YAAY,CAAC,OAAO,EAAE,UAAU,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAA;QAEjG,IAAI,YAAY,KAAK,SAAS,IAAI,YAAY,KAAK,SAAS,EAAE;YAC5D,6GAA6G;YAC7G,MAAM,sBAAsB,GAAG,YAAY;iBACxC,GAAG,CAAC,CAAC,wBAAsC,EAAE,EAAE;gBAC9C,MAAM,wBAAwB,GAAG,GAAG,CAAC,OAAO,CAAC,wBAAwB,CAAC,CAAA;gBACtE,wBAAwB,CAAC,YAAY,CAAC,CAAA;gBAEtC,IAAI,KAAK,GAAG,CAAC,CAAA;gBACb,IAAI,wBAAwB,CAAC,IAAI,KAAK,QAAQ,EAAE;oBAC9C,gFAAgF;oBAChF,MAAM,0BAA0B,GAAG,MAAM,CAAC,IAAI,CAAC,wBAAwB,CAAC,UAAU,CAAC,CAAA;oBACnF,KAAK,GAAG,0BAA0B,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,YAAY,EAAE,EAAE;wBAC9D,MAAM,SAAS,GAAG,wBAAwB,CAAC,UAAU,CAAC,YAAY,CAAiB,CAAA;wBACnF,MAAM,iBAAiB,GAAG,YAAY,CAAC,YAAY,EAAE,YAAY,CAAC,CAAA;wBAElE,MAAM,YAAY,GAAG,GAAG,CAAC,OAAO,CAAC,SAAS,CAAC,CAAA;wBAC3C,IAAI,YAAY,CAAC,iBAAiB,CAAC,EAAE;4BACnC,OAAO,GAAG,GAAG,CAAC,CAAA;yBACf;wBACD,OAAO,GAAG,CAAA;oBACZ,CAAC,EAAE,KAAK,CAAC,CAAA;iBACV;gBAED,OAAO,CAAC,KAAK,EAAE,wBAAwB,CAAC,MAAO,CAAU,CAAA;YAC3D,CAAC,CAAC;iBACD,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,MAAM,GAAG,MAAM,CAAC,CAAA;YAEhD,IAAI,sBAAsB,CAAC,MAAM,IAAI,CAAC,EAAE;gBACtC,MAAM,CAAC,SAAS,EAAE,UAAU,CAAC,GAAG,sBAAsB,CAAC,sBAAsB,CAAC,MAAM,GAAG,CAAC,CAAE,CAAA;gBAC1F,MAAM,CAAC,gBAAgB,CAAC,GAAG,sBAAsB,CAAC,sBAAsB,CAAC,MAAM,GAAG,CAAC,CAAE,CAAA;gBAErF,IAAI,SAAS,KAAK,gBAAgB,EAAE;oBAClC,4FAA4F;oBAC5F,+EAA+E;oBAC/E,4BAA4B,GAAG;wBAC7B,UAAU;wBACV,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;4BAChC,GAAG,SAAS;4BACZ,YAAY,EAAE,UAAU,CAAC,YAAY,GAAG,SAAS,CAAC,YAAY;yBAC/D,CAAC,CAAC;qBACJ,CAAA;iBACF;aACF;SACF;QACD,MAAM,GAAG,CAAC,GAAG,eAAe,EAAE,GAAG,4BAA4B,CAAC,CAAA;QAE9D,mBAAmB,CAAC,GAAG,CAAC,UAAU,CAAC,YAAY,CAAC,CAAA;KACjD;IACD,OAAO,MAAM,CAAA;AACf,CAAC","sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport {ParseConfigurationResult} from './schema.js'\nimport {getPathValue} from '../common/object.js'\nimport {capitalize} from '../common/string.js'\nimport {Ajv, ErrorObject, SchemaObject} from 'ajv'\nimport $RefParser from '@apidevtools/json-schema-ref-parser'\n\ntype AjvError = ErrorObject<string, {[key: string]: unknown}>\n\n/**\n * Normalises a JSON Schema by standardising it's internal implementation.\n *\n * We prefer to not use $ref elements in our schemas, so we inline them; it's easier then to process errors.\n *\n * @param schema - The JSON schema (as a string) to normalise.\n * @returns The normalised JSON schema.\n */\nexport async function normaliseJsonSchema(schema: string): Promise<SchemaObject> {\n  // we want to modify the schema, removing any $ref elements and inlining with their source\n  const parsedSchema = JSON.parse(schema)\n  await $RefParser.dereference(parsedSchema, {resolve: {external: false}})\n  return parsedSchema\n}\n\n/**\n * Given a subject object and a JSON schema contract, validate the subject against the contract.\n *\n * Errors are returned in a zod-like format, and processed to better handle unions.\n *\n * @param subject - The object to validate.\n * @param schema - The JSON schema to validate against.\n * @returns The result of the validation. If the state is 'error', the errors will be in a zod-like format.\n */\nexport function jsonSchemaValidate(\n  subject: object,\n  schema: SchemaObject,\n): ParseConfigurationResult<unknown> & {rawErrors?: AjvError[]} {\n  const ajv = new Ajv({allowUnionTypes: true})\n  const validator = ajv.compile(schema)\n  validator(subject)\n\n  // Errors from the contract are post-processed to be more zod-like and to deal with unions better\n  let jsonSchemaErrors\n  if (validator.errors && validator.errors.length > 0) {\n    jsonSchemaErrors = convertJsonSchemaErrors(validator.errors, subject, schema)\n    return {\n      state: 'error',\n      data: undefined,\n      errors: jsonSchemaErrors,\n      rawErrors: validator.errors,\n    }\n  }\n  return {\n    state: 'ok',\n    data: subject,\n    errors: undefined,\n    rawErrors: undefined,\n  }\n}\n\n/**\n * Converts errors from Ajv into a zod-like format.\n *\n * @param rawErrors - JSON Schema errors taken directly from Ajv.\n * @param subject - The object being validated.\n * @param schema - The JSON schema to validated against.\n * @returns The errors in a zod-like format.\n */\nfunction convertJsonSchemaErrors(rawErrors: AjvError[], subject: object, schema: SchemaObject) {\n  // This reduces the number of errors by simplifying errors coming from different branches of a union\n  const errors = simplifyUnionErrors(rawErrors, subject, schema)\n\n  // Now we can remap errors to be more zod-like\n  return errors.map((error) => {\n    const path: string[] = error.instancePath.split('/').slice(1)\n    if (error.params.missingProperty) {\n      const missingProperty = error.params.missingProperty as string\n      return {path: [...path, missingProperty], message: 'Required'}\n    }\n\n    if (error.params.type) {\n      const expectedType = error.params.type as string\n      const actualType = getPathValue(subject, path.join('.'))\n      return {path, message: `Expected ${expectedType}, received ${typeof actualType}`}\n    }\n\n    if (error.keyword === 'anyOf' || error.keyword === 'oneOf') {\n      return {path, message: 'Invalid input'}\n    }\n\n    if (error.params.allowedValues) {\n      const allowedValues = error.params.allowedValues as string[]\n      const actualValue = getPathValue(subject, path.join('.'))\n      return {\n        path,\n        message: `Invalid enum value. Expected ${allowedValues\n          .map((value) => JSON.stringify(value))\n          .join(' | ')}, received ${JSON.stringify(actualValue)}`.replace(/\"/g, \"'\"),\n      }\n    }\n\n    if (error.params.comparison) {\n      const comparison = error.params.comparison as string\n      const limit = error.params.limit\n      const actualValue = getPathValue(subject, path.join('.'))\n\n      let comparisonText = comparison\n      switch (comparison) {\n        case '<=':\n          comparisonText = 'less than or equal to'\n          break\n        case '<':\n          comparisonText = 'less than'\n          break\n        case '>=':\n          comparisonText = 'greater than or equal to'\n          break\n        case '>':\n          comparisonText = 'greater than'\n          break\n      }\n\n      return {\n        path,\n        message: capitalize(`${typeof actualValue} must be ${comparisonText} ${limit}`),\n      }\n    }\n\n    return {\n      path,\n      message: error.message,\n    }\n  })\n}\n\n/**\n * If a JSON schema specifies a union (anyOf, oneOf), and the subject doesn't meet any of the 'candidates' for the\n * union, then the error list received ends up being quite long: you get an error for the union property itself, and\n * then additional errors for each of the candidate branches.\n *\n * This function simplifies the error collection. By default it strips anything other than the union error itself.\n *\n * In some cases, it can be possible to identify what the intended branch of the union was -- for instance, maybe there\n * is a discriminating field like `type` that is unique between the branches. We inspect each candidate branch and if\n * one branch is less wrong than the others -- e.g. It had a valid `type`, but problems elsewhere -- then we keep the\n * errors for that branch.\n *\n * This is complex but in practise gives much more actionable errors.\n *\n * @param rawErrors - JSON Schema errors taken directly from Ajv.\n * @param subject - The object being validated.\n * @param schema - The JSON schema to validated against.\n * @returns A simplified list of errors.\n */\nfunction simplifyUnionErrors(rawErrors: AjvError[], subject: object, schema: SchemaObject): AjvError[] {\n  const ajv = new Ajv()\n  let errors = rawErrors\n\n  const resolvedUnionErrors = new Set()\n  while (true) {\n    const unionError = errors.filter(\n      (error) =>\n        (error.keyword === 'oneOf' || error.keyword === 'anyOf') && !resolvedUnionErrors.has(error.instancePath),\n    )[0]\n    if (unionError === undefined) {\n      break\n    }\n    // split errors into those sharing an instance path and those not\n    const unrelatedErrors = errors.filter((error) => !error.instancePath.startsWith(unionError.instancePath))\n\n    // we start by assuming only the union error itself is useful, and not the errors from the candidate schemas\n    let simplifiedUnionRelatedErrors: AjvError[] = [unionError]\n\n    // get the schema list from where the union issue occured\n    const dottedSchemaPath = unionError.schemaPath.replace('#/', '').replace(/\\//g, '.')\n    const unionSchemas = getPathValue<SchemaObject[]>(schema, dottedSchemaPath)\n    // and the slice of the subject that caused the issue\n    const subjectValue = getPathValue(subject, unionError.instancePath.split('/').slice(1).join('.'))\n\n    if (unionSchemas !== undefined && subjectValue !== undefined) {\n      // we know that none of the union schemas are correct, but for each of them we can measure how wrong they are\n      const correctValuesAndErrors = unionSchemas\n        .map((candidateSchemaFromUnion: SchemaObject) => {\n          const candidateSchemaValidator = ajv.compile(candidateSchemaFromUnion)\n          candidateSchemaValidator(subjectValue)\n\n          let score = 0\n          if (candidateSchemaFromUnion.type === 'object') {\n            // provided the schema is an object, we can measure how many properties are good\n            const candidatesObjectProperties = Object.keys(candidateSchemaFromUnion.properties)\n            score = candidatesObjectProperties.reduce((acc, propertyName) => {\n              const subSchema = candidateSchemaFromUnion.properties[propertyName] as SchemaObject\n              const subjectValueSlice = getPathValue(subjectValue, propertyName)\n\n              const subValidator = ajv.compile(subSchema)\n              if (subValidator(subjectValueSlice)) {\n                return acc + 1\n              }\n              return acc\n            }, score)\n          }\n\n          return [score, candidateSchemaValidator.errors!] as const\n        })\n        .sort(([scoreA], [scoreB]) => scoreA - scoreB)\n\n      if (correctValuesAndErrors.length >= 2) {\n        const [bestScore, bestErrors] = correctValuesAndErrors[correctValuesAndErrors.length - 1]!\n        const [penultimateScore] = correctValuesAndErrors[correctValuesAndErrors.length - 2]!\n\n        if (bestScore !== penultimateScore) {\n          // If there's a winner, show the errors for the best schema as they'll likely be actionable.\n          // We got these through a nested schema, so we need to adjust the instance path\n          simplifiedUnionRelatedErrors = [\n            unionError,\n            ...bestErrors.map((bestError) => ({\n              ...bestError,\n              instancePath: unionError.instancePath + bestError.instancePath,\n            })),\n          ]\n        }\n      }\n    }\n    errors = [...unrelatedErrors, ...simplifiedUnionRelatedErrors]\n\n    resolvedUnionErrors.add(unionError.instancePath)\n  }\n  return errors\n}\n"]}