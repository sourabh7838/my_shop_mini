import { useState as A, useCallback as l, useMemo as O, useEffect as D } from "react";
import { MiniError as M, formatError as b } from "../utils/errors.js";
const V = (g, c, h) => {
  const [r, f] = A({
    data: null,
    pageInfo: { hasNextPage: !1, endCursor: null },
    loading: !1,
    error: null
  }), p = h?.skip === !0, { validator: y, hook: t } = h, w = l(
    (d) => {
      try {
        return y?.(d), null;
      } catch (o) {
        return o instanceof Error ? o : new M({
          hook: t,
          message: "Validation failed"
        });
      }
    },
    [y, t]
  ), I = O(() => c, [JSON.stringify(c)]), e = l(
    async (d, {
      setLoading: o = !0,
      setError: N = !0,
      resetOnError: i = !0,
      throwOnError: k = !0,
      appendData: C = !1
    } = {}) => {
      let E = null, u = null;
      f((a) => ({
        ...a,
        loading: o ? !0 : a.loading
      }));
      try {
        const a = await g({ ...I, ...d });
        if (a.ok)
          u = w(a.data.data), f((s) => {
            let P = a.data.data;
            return C && s.data && Array.isArray(s.data) && Array.isArray(a.data.data) && (P = [...s.data, ...a.data.data]), {
              ...s,
              data: P,
              pageInfo: a.data.pageInfo,
              loading: !1,
              error: u ?? null
            };
          });
        else
          throw a.error;
      } catch (a) {
        console.log("caught 1", a), E = b({ hook: t }, a);
      }
      const n = u || E;
      if (n && (N || i) && f((a) => ({
        data: i ? null : a.data,
        pageInfo: i ? { hasNextPage: !1, endCursor: null } : a.pageInfo,
        loading: !1,
        error: n
      })), n && k)
        throw n;
    },
    [g, I, t, w]
  ), m = l(async () => {
    await e({ fetchPolicy: "network-only" }, {
      setLoading: !1,
      resetOnError: !1,
      throwOnError: !0
    });
  }, [e]), x = l(async () => {
    !r.pageInfo.hasNextPage || !r.pageInfo.endCursor || await e({ after: r.pageInfo.endCursor }, {
      setLoading: !1,
      setError: !1,
      resetOnError: !1,
      throwOnError: !0,
      appendData: !0
    });
  }, [r.pageInfo.hasNextPage, r.pageInfo.endCursor, e]);
  return D(() => {
    p || e(
      {},
      {
        throwOnError: !1
      }
    );
  }, [e, p]), {
    data: r.data,
    loading: r.loading,
    error: r.error,
    hasNextPage: r.pageInfo.hasNextPage,
    refetch: m,
    fetchMore: x
  };
};
export {
  V as useShopActionsPaginatedDataFetching
};
//# sourceMappingURL=useShopActionsPaginatedDataFetching.js.map
