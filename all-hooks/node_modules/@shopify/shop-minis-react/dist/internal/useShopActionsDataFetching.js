import { useState as b, useCallback as u, useMemo as v, useEffect as M } from "react";
import { MiniError as P, formatError as V } from "../utils/errors.js";
const A = (d, c, f) => {
  const [o, n] = b({
    data: null,
    loading: !0,
    error: null
  }), h = f?.skip === !0, { validator: g, hook: t } = f, w = u(
    (l) => {
      try {
        return g?.(l), null;
      } catch (s) {
        return s ?? new P({
          hook: t,
          message: "Validation failed"
        });
      }
    },
    [g, t]
  ), y = v(() => c, [JSON.stringify(c)]), a = u(
    async (l, {
      setLoading: s = !0,
      setError: p = !0,
      resetOnError: m = !0,
      throwOnError: O = !0
    } = {}) => {
      let E = null, i = null;
      n((r) => ({
        ...r,
        loading: s ? !0 : r.loading
      }));
      try {
        const r = await d({ ...y, ...l });
        if (r.ok)
          i = w(r.data.data), n((S) => ({
            ...S,
            data: r.data.data,
            loading: !1,
            error: i ?? null
          }));
        else
          throw r.error;
      } catch (r) {
        E = V({ hook: t }, r);
      }
      const e = i || E;
      if (e && (p || m) && n((r) => ({
        data: m ? null : r.data,
        loading: !1,
        error: e
      })), e && O)
        throw e;
    },
    [d, y, t, w]
  ), k = u(async () => {
    await a({ fetchPolicy: "network-only" }, {
      setLoading: !1,
      resetOnError: !1,
      throwOnError: !0
    });
  }, [a]);
  return M(() => {
    h || a(
      {},
      {
        throwOnError: !1
      }
    );
  }, [a, h]), {
    data: o.data,
    loading: o.loading,
    error: o.error,
    refetch: k
  };
};
export {
  A as useShopActionsDataFetching
};
//# sourceMappingURL=useShopActionsDataFetching.js.map
