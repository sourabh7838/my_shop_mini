import { time as p } from "../frameloop/sync-time.js";
import { JSAnimation as A } from "./JSAnimation.js";
import { getFinalKeyframe as y } from "./keyframes/get-final.js";
import { KeyframeResolver as R, flushKeyframeResolvers as g } from "./keyframes/KeyframesResolver.js";
import { NativeAnimationExtended as T } from "./NativeAnimationExtended.js";
import { canAnimate as _ } from "./utils/can-animate.js";
import { WithPromise as w } from "./utils/WithPromise.js";
import { supportsBrowserAnimation as K } from "./waapi/supports/waapi.js";
import { MotionGlobalConfig as E } from "../../../../motion-utils/dist/es/global-config.js";
import { noop as x } from "../../../../motion-utils/dist/es/noop.js";
const M = 40;
class C extends w {
  constructor({ autoplay: t = !0, delay: n = 0, type: i = "keyframes", repeat: m = 0, repeatDelay: h = 0, repeatType: l = "loop", keyframes: d, name: a, motionValue: r, element: s, ...f }) {
    super(), this.stop = () => {
      this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel();
    }, this.createdAt = p.now();
    const e = {
      autoplay: t,
      delay: n,
      type: i,
      repeat: m,
      repeatDelay: h,
      repeatType: l,
      name: a,
      motionValue: r,
      element: s,
      ...f
    }, o = s?.KeyframeResolver || R;
    this.keyframeResolver = new o(d, (c, u, v) => this.onKeyframesResolved(c, u, e, !v), a, r, s), this.keyframeResolver?.scheduleResolve();
  }
  onKeyframesResolved(t, n, i, m) {
    this.keyframeResolver = void 0;
    const { name: h, type: l, velocity: d, delay: a, isHandoff: r, onUpdate: s } = i;
    this.resolvedAt = p.now(), _(t, h, l, d) || ((E.instantAnimations || !a) && s?.(y(t, i, n)), t[0] = t[t.length - 1], i.duration = 0, i.repeat = 0);
    const e = {
      startTime: m ? this.resolvedAt ? this.resolvedAt - this.createdAt > M ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
      finalKeyframe: n,
      ...i,
      keyframes: t
    }, o = !r && K(e) ? new T({
      ...e,
      element: e.motionValue.owner.current
    }) : new A(e);
    o.finished.then(() => this.notifyFinished()).catch(x), this.pendingTimeline && (this.stopTimeline = o.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = o;
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(t, n) {
    return this.finished.finally(t).then(() => {
    });
  }
  get animation() {
    return this._animation || (this.keyframeResolver?.resume(), g()), this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get time() {
    return this.animation.time;
  }
  set time(t) {
    this.animation.time = t;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(t) {
    this.animation.speed = t;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(t) {
    return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    this._animation && this.animation.cancel(), this.keyframeResolver?.cancel();
  }
}
export {
  C as AsyncMotionValueAnimation
};
//# sourceMappingURL=AsyncMotionValueAnimation.js.map
