import { animateSingleValue as ot } from "../../animation/animate/single-value.js";
import { getOptimisedAppearId as at } from "../../animation/optimized-appear/get-appear-id.js";
import { FlatTree as rt } from "../../render/utils/flat-tree.js";
import { delay as nt } from "../../utils/delay.js";
import { resolveMotionValue as w } from "../../value/utils/resolve-motion-value.js";
import { mixValues as lt } from "../animation/mix-values.js";
import { copyBoxInto as m, copyAxisDeltaInto as M } from "../geometry/copy.js";
import { translateAxis as k, transformBox as L, applyBoxDelta as ht, applyTreeDeltas as ut } from "../geometry/delta-apply.js";
import { calcLength as B, calcRelativePosition as R, calcRelativeBox as ct, calcBoxDelta as V, isNear as dt } from "../geometry/delta-calc.js";
import { removeBoxTransforms as b } from "../geometry/delta-remove.js";
import { createBox as c, createDelta as j } from "../geometry/models.js";
import { boxEqualsRounded as _, isDeltaZero as tt, axisDeltaEquals as z, boxEquals as ft, aspectRatio as N } from "../geometry/utils.js";
import { NodeStack as mt } from "../shared/stack.js";
import { scaleCorrectors as W } from "../styles/scale-correction.js";
import { buildProjectionTransform as pt } from "../styles/transform.js";
import { eachAxis as H } from "../utils/each-axis.js";
import { hasTransform as S, hasScale as G, has2DTranslate as yt } from "../utils/has-transform.js";
import { globalProjectionState as C } from "./state.js";
import { SubscriptionManager as gt } from "../../../../../motion-utils/dist/es/subscription-manager.js";
import { isSVGElement as Tt } from "../../../../../motion-dom/dist/es/utils/is-svg-element.js";
import { isSVGSVGElement as vt } from "../../../../../motion-dom/dist/es/utils/is-svg-svg-element.js";
import { getValueTransition as xt } from "../../../../../motion-dom/dist/es/animation/utils/get-value-transition.js";
import { cancelFrame as q, frameData as p, frameSteps as O, frame as E } from "../../../../../motion-dom/dist/es/frameloop/frame.js";
import { time as Pt } from "../../../../../motion-dom/dist/es/frameloop/sync-time.js";
import { clamp as Dt } from "../../../../../motion-utils/dist/es/clamp.js";
import { microtask as St } from "../../../../../motion-dom/dist/es/frameloop/microtask.js";
import { motionValue as Bt } from "../../../../../motion-dom/dist/es/value/index.js";
import { mixNumber as U } from "../../../../../motion-dom/dist/es/utils/mix/number.js";
import { noop as jt } from "../../../../../motion-utils/dist/es/noop.js";
const F = ["", "X", "Y", "Z"], At = { visibility: "hidden" }, Rt = 1e3;
let Vt = 0;
function I(e, r, h, d) {
  const { latestValues: y } = r;
  y[e] && (h[e] = y[e], r.setStaticValue(e, 0), d && (d[e] = 0));
}
function et(e) {
  if (e.hasCheckedOptimisedAppear = !0, e.root === e)
    return;
  const { visualElement: r } = e.options;
  if (!r)
    return;
  const h = at(r);
  if (window.MotionHasOptimisedAnimation(h, "transform")) {
    const { layout: y, layoutId: x } = e.options;
    window.MotionCancelOptimisedAnimation(h, "transform", E, !(y || x));
  }
  const { parent: d } = e;
  d && !d.hasCheckedOptimisedAppear && et(d);
}
function Pe({ attachResizeListener: e, defaultParent: r, measureScroll: h, checkIsScrollRoot: d, resetTransform: y }) {
  return class {
    constructor(t = {}, i = r?.()) {
      this.id = Vt++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, this.nodes.forEach(Et), this.nodes.forEach(Ft), this.nodes.forEach(It), this.nodes.forEach(Ut);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = t, this.root = i ? i.root || i : this, this.path = i ? [...i.path, i] : [], this.parent = i, this.depth = i ? i.depth + 1 : 0;
      for (let s = 0; s < this.path.length; s++)
        this.path[s].shouldResetTransform = !0;
      this.root === this && (this.nodes = new rt());
    }
    addEventListener(t, i) {
      return this.eventHandlers.has(t) || this.eventHandlers.set(t, new gt()), this.eventHandlers.get(t).add(i);
    }
    notifyListeners(t, ...i) {
      const s = this.eventHandlers.get(t);
      s && s.notify(...i);
    }
    hasListeners(t) {
      return this.eventHandlers.has(t);
    }
    /**
     * Lifecycles
     */
    mount(t) {
      if (this.instance)
        return;
      this.isSVG = Tt(t) && !vt(t), this.instance = t;
      const { layoutId: i, layout: s, visualElement: a } = this.options;
      if (a && !a.current && a.mount(t), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (s || i) && (this.isLayoutDirty = !0), e) {
        let o;
        const n = () => this.root.updateBlockedByResize = !1;
        e(t, () => {
          this.root.updateBlockedByResize = !0, o && o(), o = nt(n, 250), C.hasAnimatedSinceResize && (C.hasAnimatedSinceResize = !1, this.nodes.forEach(Y));
        });
      }
      i && this.root.registerSharedNode(i, this), this.options.animate !== !1 && a && (i || s) && this.addEventListener("didUpdate", ({ delta: o, hasLayoutChanged: n, hasRelativeLayoutChanged: l, layout: u }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const g = this.options.transition || a.getDefaultTransition() || Wt, { onLayoutAnimationStart: T, onLayoutAnimationComplete: P } = a.getProps(), v = !this.targetLayout || !_(this.targetLayout, u), D = !n && l;
        if (this.options.layoutRoot || this.resumeFrom || D || n && (v || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);
          const f = {
            ...xt(g, "layout"),
            onPlay: T,
            onComplete: P
          };
          (a.shouldReduceMotion || this.options.layoutRoot) && (f.delay = 0, f.type = !1), this.startAnimation(f), this.setAnimationOrigin(o, D);
        } else
          n || Y(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = u;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const t = this.getStack();
      t && t.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), q(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(Mt), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: t } = this.options;
      return t && t.getProps().transformTemplate;
    }
    willUpdate(t = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && et(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let o = 0; o < this.path.length; o++) {
        const n = this.path[o];
        n.shouldResetTransform = !0, n.updateScroll("snapshot"), n.options.layoutRoot && n.willUpdate(!1);
      }
      const { layoutId: i, layout: s } = this.options;
      if (i === void 0 && !s)
        return;
      const a = this.getTransformTemplate();
      this.prevTransformTemplateValue = a ? a(this.latestValues, "") : void 0, this.updateSnapshot(), t && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(X);
        return;
      }
      this.isUpdating || this.nodes.forEach(Ct), this.isUpdating = !1, this.nodes.forEach(Ot), this.nodes.forEach(kt), this.nodes.forEach(Lt), this.clearAllSnapshots();
      const i = Pt.now();
      p.delta = Dt(0, 1e3 / 60, i - p.timestamp), p.timestamp = i, p.isProcessing = !0, O.update.process(p), O.preRender.process(p), O.render.process(p), p.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, St.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(wt), this.sharedNodes.forEach(bt);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, E.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      E.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !B(this.snapshot.measuredBox.x) && !B(this.snapshot.measuredBox.y) && (this.snapshot = void 0));
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let s = 0; s < this.path.length; s++)
          this.path[s].updateScroll();
      const t = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = c(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: i } = this.options;
      i && i.notify("LayoutMeasure", this.layout.layoutBox, t ? t.layoutBox : void 0);
    }
    updateScroll(t = "measure") {
      let i = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === t && (i = !1), i && this.instance) {
        const s = d(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: t,
          isRoot: s,
          offset: h(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : s
        };
      }
    }
    resetTransform() {
      if (!y)
        return;
      const t = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, i = this.projectionDelta && !tt(this.projectionDelta), s = this.getTransformTemplate(), a = s ? s(this.latestValues, "") : void 0, o = a !== this.prevTransformTemplateValue;
      t && this.instance && (i || S(this.latestValues) || o) && (y(this.instance, a), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(t = !0) {
      const i = this.measurePageBox();
      let s = this.removeElementScroll(i);
      return t && (s = this.removeTransform(s)), Ht(s), {
        animationId: this.root.animationId,
        measuredBox: i,
        layoutBox: s,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement: t } = this.options;
      if (!t)
        return c();
      const i = t.measureViewportBox();
      if (!(this.scroll?.wasRoot || this.path.some(Gt))) {
        const { scroll: a } = this.root;
        a && (k(i.x, a.offset.x), k(i.y, a.offset.y));
      }
      return i;
    }
    removeElementScroll(t) {
      const i = c();
      if (m(i, t), this.scroll?.wasRoot)
        return i;
      for (let s = 0; s < this.path.length; s++) {
        const a = this.path[s], { scroll: o, options: n } = a;
        a !== this.root && o && n.layoutScroll && (o.wasRoot && m(i, t), k(i.x, o.offset.x), k(i.y, o.offset.y));
      }
      return i;
    }
    applyTransform(t, i = !1) {
      const s = c();
      m(s, t);
      for (let a = 0; a < this.path.length; a++) {
        const o = this.path[a];
        !i && o.options.layoutScroll && o.scroll && o !== o.root && L(s, {
          x: -o.scroll.offset.x,
          y: -o.scroll.offset.y
        }), S(o.latestValues) && L(s, o.latestValues);
      }
      return S(this.latestValues) && L(s, this.latestValues), s;
    }
    removeTransform(t) {
      const i = c();
      m(i, t);
      for (let s = 0; s < this.path.length; s++) {
        const a = this.path[s];
        if (!a.instance || !S(a.latestValues))
          continue;
        G(a.latestValues) && a.updateSnapshot();
        const o = c(), n = a.measurePageBox();
        m(o, n), b(i, a.latestValues, a.snapshot ? a.snapshot.layoutBox : void 0, o);
      }
      return S(this.latestValues) && b(i, this.latestValues), i;
    }
    setTargetDelta(t) {
      this.targetDelta = t, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(t) {
      this.options = {
        ...this.options,
        ...t,
        crossfade: t.crossfade !== void 0 ? t.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== p.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(t = !1) {
      const i = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = i.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = i.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = i.isSharedProjectionDirty);
      const s = !!this.resumingFrom || this !== i;
      if (!(t || s && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: o, layoutId: n } = this.options;
      if (!(!this.layout || !(o || n))) {
        if (this.resolvedRelativeTargetAt = p.timestamp, !this.targetDelta && !this.relativeTarget) {
          const l = this.getClosestProjectingParent();
          l && l.layout && this.animationProgress !== 1 ? (this.relativeParent = l, this.forceRelativeParentToResolveTarget(), this.relativeTarget = c(), this.relativeTargetOrigin = c(), R(this.relativeTargetOrigin, this.layout.layoutBox, l.layout.layoutBox), m(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = c(), this.targetWithTransforms = c()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), ct(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : m(this.target, this.layout.layoutBox), ht(this.target, this.targetDelta)) : m(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) {
          this.attemptToResolveRelativeTarget = !1;
          const l = this.getClosestProjectingParent();
          l && !!l.resumingFrom == !!this.resumingFrom && !l.options.layoutScroll && l.target && this.animationProgress !== 1 ? (this.relativeParent = l, this.forceRelativeParentToResolveTarget(), this.relativeTarget = c(), this.relativeTargetOrigin = c(), R(this.relativeTargetOrigin, this.target, l.target), m(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || G(this.parent.latestValues) || yt(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      const t = this.getLead(), i = !!this.resumingFrom || this !== t;
      let s = !0;
      if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (s = !1), i && (this.isSharedProjectionDirty || this.isTransformDirty) && (s = !1), this.resolvedRelativeTargetAt === p.timestamp && (s = !1), s)
        return;
      const { layout: a, layoutId: o } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(a || o))
        return;
      m(this.layoutCorrected, this.layout.layoutBox);
      const n = this.treeScale.x, l = this.treeScale.y;
      ut(this.layoutCorrected, this.treeScale, this.path, i), t.layout && !t.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (t.target = t.layout.layoutBox, t.targetWithTransforms = c());
      const { target: u } = t;
      if (!u) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (M(this.prevProjectionDelta.x, this.projectionDelta.x), M(this.prevProjectionDelta.y, this.projectionDelta.y)), V(this.projectionDelta, this.layoutCorrected, u, this.latestValues), (this.treeScale.x !== n || this.treeScale.y !== l || !z(this.projectionDelta.x, this.prevProjectionDelta.x) || !z(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", u));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(t = !0) {
      if (this.options.visualElement?.scheduleRender(), t) {
        const i = this.getStack();
        i && i.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = j(), this.projectionDelta = j(), this.projectionDeltaWithTransform = j();
    }
    setAnimationOrigin(t, i = !1) {
      const s = this.snapshot, a = s ? s.latestValues : {}, o = { ...this.latestValues }, n = j();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !i;
      const l = c(), u = s ? s.source : void 0, g = this.layout ? this.layout.source : void 0, T = u !== g, P = this.getStack(), v = !P || P.members.length <= 1, D = !!(T && !v && this.options.crossfade === !0 && !this.path.some(Nt));
      this.animationProgress = 0;
      let f;
      this.mixTargetDelta = (st) => {
        const A = st / 1e3;
        $(n.x, t.x, A), $(n.y, t.y, A), this.setTargetDelta(n), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (R(l, this.layout.layoutBox, this.relativeParent.layout.layoutBox), zt(this.relativeTarget, this.relativeTargetOrigin, l, A), f && ft(this.relativeTarget, f) && (this.isProjectionDirty = !1), f || (f = c()), m(f, this.relativeTarget)), T && (this.animationValues = o, lt(o, a, this.latestValues, A, D, v)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = A;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(t) {
      this.notifyListeners("animationStart"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation && (q(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = E.update(() => {
        C.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = Bt(0)), this.currentAnimation = ot(this.motionValue, [0, 1e3], {
          ...t,
          velocity: 0,
          isSync: !0,
          onUpdate: (i) => {
            this.mixTargetDelta(i), t.onUpdate && t.onUpdate(i);
          },
          onStop: () => {
          },
          onComplete: () => {
            t.onComplete && t.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const t = this.getStack();
      t && t.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Rt), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const t = this.getLead();
      let { targetWithTransforms: i, target: s, layout: a, latestValues: o } = t;
      if (!(!i || !s || !a)) {
        if (this !== t && this.layout && a && it(this.options.animationType, this.layout.layoutBox, a.layoutBox)) {
          s = this.target || c();
          const n = B(this.layout.layoutBox.x);
          s.x.min = t.target.x.min, s.x.max = s.x.min + n;
          const l = B(this.layout.layoutBox.y);
          s.y.min = t.target.y.min, s.y.max = s.y.min + l;
        }
        m(i, s), L(i, o), V(this.projectionDeltaWithTransform, this.layoutCorrected, i, o);
      }
    }
    registerSharedNode(t, i) {
      this.sharedNodes.has(t) || this.sharedNodes.set(t, new mt()), this.sharedNodes.get(t).add(i);
      const a = i.options.initialPromotionConfig;
      i.promote({
        transition: a ? a.transition : void 0,
        preserveFollowOpacity: a && a.shouldPreserveFollowOpacity ? a.shouldPreserveFollowOpacity(i) : void 0
      });
    }
    isLead() {
      const t = this.getStack();
      return t ? t.lead === this : !0;
    }
    getLead() {
      const { layoutId: t } = this.options;
      return t ? this.getStack()?.lead || this : this;
    }
    getPrevLead() {
      const { layoutId: t } = this.options;
      return t ? this.getStack()?.prevLead : void 0;
    }
    getStack() {
      const { layoutId: t } = this.options;
      if (t)
        return this.root.sharedNodes.get(t);
    }
    promote({ needsReset: t, transition: i, preserveFollowOpacity: s } = {}) {
      const a = this.getStack();
      a && a.promote(this, s), t && (this.projectionDelta = void 0, this.needsReset = !0), i && this.setOptions({ transition: i });
    }
    relegate() {
      const t = this.getStack();
      return t ? t.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: t } = this.options;
      if (!t)
        return;
      let i = !1;
      const { latestValues: s } = t;
      if ((s.z || s.rotate || s.rotateX || s.rotateY || s.rotateZ || s.skewX || s.skewY) && (i = !0), !i)
        return;
      const a = {};
      s.z && I("z", t, a, this.animationValues);
      for (let o = 0; o < F.length; o++)
        I(`rotate${F[o]}`, t, a, this.animationValues), I(`skew${F[o]}`, t, a, this.animationValues);
      t.render();
      for (const o in a)
        t.setStaticValue(o, a[o]), this.animationValues && (this.animationValues[o] = a[o]);
      t.scheduleRender();
    }
    getProjectionStyles(t) {
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return At;
      const i = {
        visibility: ""
      }, s = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, i.opacity = "", i.pointerEvents = w(t?.pointerEvents) || "", i.transform = s ? s(this.latestValues, "") : "none", i;
      const a = this.getLead();
      if (!this.projectionDelta || !this.layout || !a.target) {
        const u = {};
        return this.options.layoutId && (u.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, u.pointerEvents = w(t?.pointerEvents) || ""), this.hasProjected && !S(this.latestValues) && (u.transform = s ? s({}, "") : "none", this.hasProjected = !1), u;
      }
      const o = a.animationValues || a.latestValues;
      this.applyTransformsToTarget(), i.transform = pt(this.projectionDeltaWithTransform, this.treeScale, o), s && (i.transform = s(o, i.transform));
      const { x: n, y: l } = this.projectionDelta;
      i.transformOrigin = `${n.origin * 100}% ${l.origin * 100}% 0`, a.animationValues ? i.opacity = a === this ? o.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : o.opacityExit : i.opacity = a === this ? o.opacity !== void 0 ? o.opacity : "" : o.opacityExit !== void 0 ? o.opacityExit : 0;
      for (const u in W) {
        if (o[u] === void 0)
          continue;
        const { correct: g, applyTo: T, isCSSVariable: P } = W[u], v = i.transform === "none" ? o[u] : g(o[u], a);
        if (T) {
          const D = T.length;
          for (let f = 0; f < D; f++)
            i[T[f]] = v;
        } else
          P ? this.options.visualElement.renderState.vars[u] = v : i[u] = v;
      }
      return this.options.layoutId && (i.pointerEvents = a === this ? w(t?.pointerEvents) || "" : "none"), i;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((t) => t.currentAnimation?.stop()), this.root.nodes.forEach(X), this.root.sharedNodes.clear();
    }
  };
}
function kt(e) {
  e.updateLayout();
}
function Lt(e) {
  const r = e.resumeFrom?.snapshot || e.snapshot;
  if (e.isLead() && e.layout && r && e.hasListeners("didUpdate")) {
    const { layoutBox: h, measuredBox: d } = e.layout, { animationType: y } = e.options, x = r.source !== e.layout.source;
    y === "size" ? H((o) => {
      const n = x ? r.measuredBox[o] : r.layoutBox[o], l = B(n);
      n.min = h[o].min, n.max = n.min + l;
    }) : it(y, r.layoutBox, h) && H((o) => {
      const n = x ? r.measuredBox[o] : r.layoutBox[o], l = B(h[o]);
      n.max = n.min + l, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[o].max = e.relativeTarget[o].min + l);
    });
    const t = j();
    V(t, h, r.layoutBox);
    const i = j();
    x ? V(i, e.applyTransform(d, !0), r.measuredBox) : V(i, h, r.layoutBox);
    const s = !tt(t);
    let a = !1;
    if (!e.resumeFrom) {
      const o = e.getClosestProjectingParent();
      if (o && !o.resumeFrom) {
        const { snapshot: n, layout: l } = o;
        if (n && l) {
          const u = c();
          R(u, r.layoutBox, n.layoutBox);
          const g = c();
          R(g, h, l.layoutBox), _(u, g) || (a = !0), o.options.layoutRoot && (e.relativeTarget = g, e.relativeTargetOrigin = u, e.relativeParent = o);
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: h,
      snapshot: r,
      delta: i,
      layoutDelta: t,
      hasLayoutChanged: s,
      hasRelativeLayoutChanged: a
    });
  } else if (e.isLead()) {
    const { onExitComplete: h } = e.options;
    h && h();
  }
  e.options.transition = void 0;
}
function Et(e) {
  e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
function Ut(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function wt(e) {
  e.clearSnapshot();
}
function X(e) {
  e.clearMeasurements();
}
function Ct(e) {
  e.isLayoutDirty = !1;
}
function Ot(e) {
  const { visualElement: r } = e.options;
  r && r.getProps().onBeforeLayoutMeasure && r.notify("BeforeLayoutMeasure"), e.resetTransform();
}
function Y(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0;
}
function Ft(e) {
  e.resolveTargetDelta();
}
function It(e) {
  e.calcProjection();
}
function Mt(e) {
  e.resetSkewAndRotation();
}
function bt(e) {
  e.removeLeadSnapshot();
}
function $(e, r, h) {
  e.translate = U(r.translate, 0, h), e.scale = U(r.scale, 1, h), e.origin = r.origin, e.originPoint = r.originPoint;
}
function Z(e, r, h, d) {
  e.min = U(r.min, h.min, d), e.max = U(r.max, h.max, d);
}
function zt(e, r, h, d) {
  Z(e.x, r.x, h.x, d), Z(e.y, r.y, h.y, d);
}
function Nt(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const Wt = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, J = (e) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), K = J("applewebkit/") && !J("chrome/") ? Math.round : jt;
function Q(e) {
  e.min = K(e.min), e.max = K(e.max);
}
function Ht(e) {
  Q(e.x), Q(e.y);
}
function it(e, r, h) {
  return e === "position" || e === "preserve-aspect" && !dt(N(r), N(h), 0.2);
}
function Gt(e) {
  return e !== e.root && e.scroll?.wasRoot;
}
export {
  Ut as cleanDirtyNodes,
  Pe as createProjectionNode,
  Z as mixAxis,
  $ as mixAxisDelta,
  zt as mixBox,
  Et as propagateDirtyNodes
};
//# sourceMappingURL=create-projection-node.js.map
