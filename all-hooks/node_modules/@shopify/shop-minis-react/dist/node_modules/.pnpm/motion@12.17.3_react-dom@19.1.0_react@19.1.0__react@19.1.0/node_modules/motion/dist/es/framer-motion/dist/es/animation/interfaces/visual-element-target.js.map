{"version":3,"file":"visual-element-target.js","sources":["../../../../../../../../../../../../../node_modules/.pnpm/motion@12.17.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/motion/dist/es/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs"],"sourcesContent":["import { setTarget } from '../../render/utils/setters.mjs';\nimport { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';\nimport { getOptimisedAppearId } from '../optimized-appear/get-appear-id.mjs';\nimport { animateMotionValue } from './motion-value.mjs';\nimport { getValueTransition } from '../../../../../motion-dom/dist/es/animation/utils/get-value-transition.mjs';\nimport { frame } from '../../../../../motion-dom/dist/es/frameloop/frame.mjs';\nimport { positionalKeys } from '../../../../../motion-dom/dist/es/render/utils/keys-position.mjs';\n\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\nfunction animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;\n    if (transitionOverride)\n        transition = transitionOverride;\n    const animations = [];\n    const animationTypeState = type &&\n        visualElement.animationState &&\n        visualElement.animationState.getState()[type];\n    for (const key in target) {\n        const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);\n        const valueTarget = target[key];\n        if (valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        const valueTransition = {\n            delay,\n            ...getValueTransition(transition || {}, key),\n        };\n        /**\n         * If the value is already at the defined target, skip the animation.\n         */\n        const currentValue = value.get();\n        if (currentValue !== undefined &&\n            !value.isAnimating &&\n            !Array.isArray(valueTarget) &&\n            valueTarget === currentValue &&\n            !valueTransition.velocity) {\n            continue;\n        }\n        /**\n         * If this is the first time a value is being animated, check\n         * to see if we're handling off from an existing animation.\n         */\n        let isHandoff = false;\n        if (window.MotionHandoffAnimation) {\n            const appearId = getOptimisedAppearId(visualElement);\n            if (appearId) {\n                const startTime = window.MotionHandoffAnimation(appearId, key, frame);\n                if (startTime !== null) {\n                    valueTransition.startTime = startTime;\n                    isHandoff = true;\n                }\n            }\n        }\n        addValueToWillChange(visualElement, key);\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key)\n            ? { type: false }\n            : valueTransition, visualElement, isHandoff));\n        const animation = value.animation;\n        if (animation) {\n            animations.push(animation);\n        }\n    }\n    if (transitionEnd) {\n        Promise.all(animations).then(() => {\n            frame.update(() => {\n                transitionEnd && setTarget(visualElement, transitionEnd);\n            });\n        });\n    }\n    return animations;\n}\n\nexport { animateTarget };\n"],"names":["shouldBlockAnimation","protectedKeys","needsAnimating","key","shouldBlock","animateTarget","visualElement","targetAndTransition","delay","transitionOverride","type","transition","transitionEnd","target","animations","animationTypeState","value","valueTarget","valueTransition","getValueTransition","currentValue","isHandoff","appearId","getOptimisedAppearId","startTime","frame","addValueToWillChange","animateMotionValue","positionalKeys","animation","setTarget"],"mappings":";;;;;;;AAcA,SAASA,EAAqB,EAAE,eAAAC,GAAe,gBAAAC,EAAc,GAAIC,GAAK;AAClE,QAAMC,IAAcH,EAAc,eAAeE,CAAG,KAAKD,EAAeC,CAAG,MAAM;AACjF,SAAAD,EAAeC,CAAG,IAAI,IACfC;AACX;AACA,SAASC,EAAcC,GAAeC,GAAqB,EAAE,OAAAC,IAAQ,GAAG,oBAAAC,GAAoB,MAAAC,EAAM,IAAG,IAAI;AACrG,MAAI,EAAE,YAAAC,IAAaL,EAAc,qBAAsB,GAAE,eAAAM,GAAe,GAAGC,EAAM,IAAKN;AACtF,EAAIE,MACAE,IAAaF;AACjB,QAAMK,IAAa,CAAE,GACfC,IAAqBL,KACvBJ,EAAc,kBACdA,EAAc,eAAe,SAAU,EAACI,CAAI;AAChD,aAAWP,KAAOU,GAAQ;AACtB,UAAMG,IAAQV,EAAc,SAASH,GAAKG,EAAc,aAAaH,CAAG,KAAK,IAAI,GAC3Ec,IAAcJ,EAAOV,CAAG;AAC9B,QAAIc,MAAgB,UACfF,KACGf,EAAqBe,GAAoBZ,CAAG;AAChD;AAEJ,UAAMe,IAAkB;AAAA,MACpB,OAAAV;AAAA,MACA,GAAGW,EAAmBR,KAAc,CAAE,GAAER,CAAG;AAAA,IAC9C,GAIKiB,IAAeJ,EAAM,IAAK;AAChC,QAAII,MAAiB,UACjB,CAACJ,EAAM,eACP,CAAC,MAAM,QAAQC,CAAW,KAC1BA,MAAgBG,KAChB,CAACF,EAAgB;AACjB;AAMJ,QAAIG,IAAY;AAChB,QAAI,OAAO,wBAAwB;AAC/B,YAAMC,IAAWC,EAAqBjB,CAAa;AACnD,UAAIgB,GAAU;AACV,cAAME,IAAY,OAAO,uBAAuBF,GAAUnB,GAAKsB,CAAK;AACpE,QAAID,MAAc,SACdN,EAAgB,YAAYM,GAC5BH,IAAY;AAAA,MAEhC;AAAA,IACA;AACQ,IAAAK,EAAqBpB,GAAeH,CAAG,GACvCa,EAAM,MAAMW,EAAmBxB,GAAKa,GAAOC,GAAaX,EAAc,sBAAsBsB,EAAe,IAAIzB,CAAG,IAC5G,EAAE,MAAM,GAAK,IACbe,GAAiBZ,GAAee,CAAS,CAAC;AAChD,UAAMQ,IAAYb,EAAM;AACxB,IAAIa,KACAf,EAAW,KAAKe,CAAS;AAAA,EAErC;AACI,SAAIjB,KACA,QAAQ,IAAIE,CAAU,EAAE,KAAK,MAAM;AAC/B,IAAAW,EAAM,OAAO,MAAM;AACf,MAAAb,KAAiBkB,EAAUxB,GAAeM,CAAa;AAAA,IACvE,CAAa;AAAA,EACb,CAAS,GAEEE;AACX;","x_google_ignoreList":[0]}