import { animateVisualElement as q } from "../../animation/interfaces/visual-element.js";
import { isAnimationControls as G } from "../../animation/utils/is-animation-controls.js";
import { isKeyframesTarget as D } from "../../animation/utils/is-keyframes-target.js";
import { shallowCompare as B } from "../../utils/shallow-compare.js";
import { getVariantContext as J } from "./get-variant-context.js";
import { isVariantLabel as N } from "./is-variant-label.js";
import { resolveVariant as L } from "./resolve-dynamic-variants.js";
import { variantPriorityOrder as F } from "./variant-props.js";
const Q = [...F].reverse(), U = F.length;
function W(e) {
  return (l) => Promise.all(l.map(({ animation: f, options: m }) => q(e, f, m)));
}
function ae(e) {
  let l = W(e), f = k(), m = !0;
  const H = (o) => (t, A) => {
    const s = L(e, A, o === "exit" ? e.presenceContext?.custom : void 0);
    if (s) {
      const { transition: d, transitionEnd: h, ...g } = s;
      t = { ...t, ...g, ...h };
    }
    return t;
  };
  function M(o) {
    l = o(e);
  }
  function T(o) {
    const { props: t } = e, A = J(e.parent) || {}, s = [], d = /* @__PURE__ */ new Set();
    let h = {}, g = 1 / 0;
    for (let c = 0; c < U; c++) {
      const n = Q[c], r = f[n], a = t[n] !== void 0 ? t[n] : A[n], V = N(a), w = n === o ? r.isActive : null;
      w === !1 && (g = c);
      let v = a === A[n] && a !== t[n] && V;
      if (v && m && e.manuallyAnimateOnMount && (v = !1), r.protectedKeys = { ...h }, // If it isn't active and hasn't *just* been set as inactive
      !r.isActive && w === null || // If we didn't and don't have any defined prop for this animation type
      !a && !r.prevProp || // Or if the prop doesn't define an animation
      G(a) || typeof a == "boolean")
        continue;
      const b = X(r.prevProp, a);
      let P = b || // If we're making this variant active, we want to always make it active
      n === o && r.isActive && !v && V || // If we removed a higher-priority variant (i is in reverse order)
      c > g && V, I = !1;
      const R = Array.isArray(a) ? a : [a];
      let y = R.reduce(H(n), {});
      w === !1 && (y = {});
      const { prevResolvedValues: x = {} } = r, j = {
        ...x,
        ...y
      }, O = (i) => {
        P = !0, d.has(i) && (I = !0, d.delete(i)), r.needsAnimating[i] = !0;
        const u = e.getValue(i);
        u && (u.liveStyle = !1);
      };
      for (const i in j) {
        const u = y[i], C = x[i];
        if (h.hasOwnProperty(i))
          continue;
        let S = !1;
        D(u) && D(C) ? S = !B(u, C) : S = u !== C, S ? u != null ? O(i) : d.add(i) : u !== void 0 && d.has(i) ? O(i) : r.protectedKeys[i] = !0;
      }
      r.prevProp = a, r.prevResolvedValues = y, r.isActive && (h = { ...h, ...y }), m && e.blockInitialAnimation && (P = !1), P && (!(v && b) || I) && s.push(...R.map((i) => ({
        animation: i,
        options: { type: n }
      })));
    }
    if (d.size) {
      const c = {};
      if (typeof t.initial != "boolean") {
        const n = L(e, Array.isArray(t.initial) ? t.initial[0] : t.initial);
        n && n.transition && (c.transition = n.transition);
      }
      d.forEach((n) => {
        const r = e.getBaseTarget(n), a = e.getValue(n);
        a && (a.liveStyle = !0), c[n] = r ?? null;
      }), s.push({ animation: c });
    }
    let K = !!s.length;
    return m && (t.initial === !1 || t.initial === t.animate) && !e.manuallyAnimateOnMount && (K = !1), m = !1, K ? l(s) : Promise.resolve();
  }
  function z(o, t) {
    if (f[o].isActive === t)
      return Promise.resolve();
    e.variantChildren?.forEach((s) => s.animationState?.setActive(o, t)), f[o].isActive = t;
    const A = T(o);
    for (const s in f)
      f[s].protectedKeys = {};
    return A;
  }
  return {
    animateChanges: T,
    setActive: z,
    setAnimateFunction: M,
    getState: () => f,
    reset: () => {
      f = k(), m = !0;
    }
  };
}
function X(e, l) {
  return typeof l == "string" ? l !== e : Array.isArray(l) ? !B(l, e) : !1;
}
function p(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function k() {
  return {
    animate: p(!0),
    whileInView: p(),
    whileHover: p(),
    whileTap: p(),
    whileDrag: p(),
    whileFocus: p(),
    exit: p()
  };
}
export {
  X as checkVariantsDidChange,
  ae as createAnimationState
};
//# sourceMappingURL=animation-state.js.map
