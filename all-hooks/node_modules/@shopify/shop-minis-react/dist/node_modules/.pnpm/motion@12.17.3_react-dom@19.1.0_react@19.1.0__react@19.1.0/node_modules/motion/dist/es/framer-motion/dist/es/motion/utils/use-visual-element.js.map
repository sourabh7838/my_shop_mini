{"version":3,"file":"use-visual-element.js","sources":["../../../../../../../../../../../../../node_modules/.pnpm/motion@12.17.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/motion/dist/es/framer-motion/dist/es/motion/utils/use-visual-element.mjs"],"sourcesContent":["import { useContext, useRef, useInsertionEffect, useEffect } from 'react';\nimport { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';\nimport { LazyContext } from '../../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../context/SwitchLayoutGroupContext.mjs';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { microtask } from '../../../../../motion-dom/dist/es/frameloop/microtask.mjs';\n\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {\n    const { visualElement: parent } = useContext(MotionContext);\n    const lazyContext = useContext(LazyContext);\n    const presenceContext = useContext(PresenceContext);\n    const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;\n    const visualElementRef = useRef(null);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    createVisualElement = createVisualElement || lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState,\n            parent,\n            props,\n            presenceContext,\n            blockInitialAnimation: presenceContext\n                ? presenceContext.initial === false\n                : false,\n            reducedMotionConfig,\n        });\n    }\n    const visualElement = visualElementRef.current;\n    /**\n     * Load Motion gesture and animation features. These are rendered as renderless\n     * components so each feature can optionally make use of React lifecycle methods.\n     */\n    const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\n    if (visualElement &&\n        !visualElement.projection &&\n        ProjectionNodeConstructor &&\n        (visualElement.type === \"html\" || visualElement.type === \"svg\")) {\n        createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\n    }\n    const isMounted = useRef(false);\n    useInsertionEffect(() => {\n        /**\n         * Check the component has already mounted before calling\n         * `update` unnecessarily. This ensures we skip the initial update.\n         */\n        if (visualElement && isMounted.current) {\n            visualElement.update(props, presenceContext);\n        }\n    });\n    /**\n     * Cache this value as we want to know whether HandoffAppearAnimations\n     * was present on initial render - it will be deleted after this.\n     */\n    const optimisedAppearId = props[optimizedAppearDataAttribute];\n    const wantsHandoff = useRef(Boolean(optimisedAppearId) &&\n        !window.MotionHandoffIsComplete?.(optimisedAppearId) &&\n        window.MotionHasOptimisedAnimation?.(optimisedAppearId));\n    useIsomorphicLayoutEffect(() => {\n        if (!visualElement)\n            return;\n        isMounted.current = true;\n        window.MotionIsMounted = true;\n        visualElement.updateFeatures();\n        microtask.render(visualElement.render);\n        /**\n         * Ideally this function would always run in a useEffect.\n         *\n         * However, if we have optimised appear animations to handoff from,\n         * it needs to happen synchronously to ensure there's no flash of\n         * incorrect styles in the event of a hydration error.\n         *\n         * So if we detect a situtation where optimised appear animations\n         * are running, we use useLayoutEffect to trigger animations.\n         */\n        if (wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n    });\n    useEffect(() => {\n        if (!visualElement)\n            return;\n        if (!wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n        if (wantsHandoff.current) {\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\n            queueMicrotask(() => {\n                window.MotionHandoffMarkAsComplete?.(optimisedAppearId);\n            });\n            wantsHandoff.current = false;\n        }\n    });\n    return visualElement;\n}\nfunction createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade, } = props;\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"]\n        ? undefined\n        : getClosestProjectingNode(visualElement.parent));\n    visualElement.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\n        visualElement,\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig,\n        crossfade: layoutCrossfade,\n        layoutScroll,\n        layoutRoot,\n    });\n}\nfunction getClosestProjectingNode(visualElement) {\n    if (!visualElement)\n        return undefined;\n    return visualElement.options.allowProjection !== false\n        ? visualElement.projection\n        : getClosestProjectingNode(visualElement.parent);\n}\n\nexport { useVisualElement };\n"],"names":["useVisualElement","Component","visualState","props","createVisualElement","ProjectionNodeConstructor","parent","useContext","MotionContext","lazyContext","LazyContext","presenceContext","PresenceContext","reducedMotionConfig","MotionConfigContext","visualElementRef","useRef","visualElement","initialLayoutGroupConfig","SwitchLayoutGroupContext","createProjectionNode","isMounted","useInsertionEffect","optimisedAppearId","optimizedAppearDataAttribute","wantsHandoff","useIsomorphicLayoutEffect","microtask","useEffect","initialPromotionConfig","layoutId","layout","drag","dragConstraints","layoutScroll","layoutRoot","layoutCrossfade","getClosestProjectingNode","isRefObject"],"mappings":";;;;;;;;;;AAWA,SAASA,EAAiBC,GAAWC,GAAaC,GAAOC,GAAqBC,GAA2B;AACrG,QAAM,EAAE,eAAeC,MAAWC,EAAWC,CAAa,GACpDC,IAAcF,EAAWG,CAAW,GACpCC,IAAkBJ,EAAWK,CAAe,GAC5CC,IAAsBN,EAAWO,CAAmB,EAAE,eACtDC,IAAmBC,EAAO,IAAI;AAIpC,EAAAZ,IAAsBA,KAAuBK,EAAY,UACrD,CAACM,EAAiB,WAAWX,MAC7BW,EAAiB,UAAUX,EAAoBH,GAAW;AAAA,IACtD,aAAAC;AAAA,IACA,QAAAI;AAAA,IACA,OAAAH;AAAA,IACA,iBAAAQ;AAAA,IACA,uBAAuBA,IACjBA,EAAgB,YAAY,KAC5B;AAAA,IACN,qBAAAE;AAAA,EACZ,CAAS;AAEL,QAAMI,IAAgBF,EAAiB,SAKjCG,IAA2BX,EAAWY,CAAwB;AACpE,EAAIF,KACA,CAACA,EAAc,cACfZ,MACCY,EAAc,SAAS,UAAUA,EAAc,SAAS,UACzDG,EAAqBL,EAAiB,SAASZ,GAAOE,GAA2Ba,CAAwB;AAE7G,QAAMG,IAAYL,EAAO,EAAK;AAC9B,EAAAM,EAAmB,MAAM;AAKrB,IAAIL,KAAiBI,EAAU,WAC3BJ,EAAc,OAAOd,GAAOQ,CAAe;AAAA,EAEvD,CAAK;AAKD,QAAMY,IAAoBpB,EAAMqB,CAA4B,GACtDC,IAAeT,EAAO,EAAQO,KAChC,CAAC,OAAO,0BAA0BA,CAAiB,KACnD,OAAO,8BAA8BA,CAAiB,CAAC;AAC3D,SAAAG,EAA0B,MAAM;AAC5B,IAAKT,MAELI,EAAU,UAAU,IACpB,OAAO,kBAAkB,IACzBJ,EAAc,eAAgB,GAC9BU,EAAU,OAAOV,EAAc,MAAM,GAWjCQ,EAAa,WAAWR,EAAc,kBACtCA,EAAc,eAAe,eAAgB;AAAA,EAEzD,CAAK,GACDW,EAAU,MAAM;AACZ,IAAKX,MAED,CAACQ,EAAa,WAAWR,EAAc,kBACvCA,EAAc,eAAe,eAAgB,GAE7CQ,EAAa,YAEb,eAAe,MAAM;AACjB,aAAO,8BAA8BF,CAAiB;AAAA,IACtE,CAAa,GACDE,EAAa,UAAU;AAAA,EAEnC,CAAK,GACMR;AACX;AACA,SAASG,EAAqBH,GAAed,GAAOE,GAA2BwB,GAAwB;AACnG,QAAM,EAAE,UAAAC,GAAU,QAAAC,GAAQ,MAAAC,GAAM,iBAAAC,GAAiB,cAAAC,GAAc,YAAAC,GAAY,iBAAAC,EAAe,IAAMjC;AAChG,EAAAc,EAAc,aAAa,IAAIZ,EAA0BY,EAAc,cAAcd,EAAM,uBAAuB,IAC5G,SACAkC,EAAyBpB,EAAc,MAAM,CAAC,GACpDA,EAAc,WAAW,WAAW;AAAA,IAChC,UAAAa;AAAA,IACA,QAAAC;AAAA,IACA,qBAAqB,EAAQC,KAAUC,KAAmBK,EAAYL,CAAe;AAAA,IACrF,eAAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,eAAe,OAAOc,KAAW,WAAWA,IAAS;AAAA,IACrD,wBAAAF;AAAA,IACA,WAAWO;AAAA,IACX,cAAAF;AAAA,IACA,YAAAC;AAAA,EACR,CAAK;AACL;AACA,SAASE,EAAyBpB,GAAe;AAC7C,MAAKA;AAEL,WAAOA,EAAc,QAAQ,oBAAoB,KAC3CA,EAAc,aACdoB,EAAyBpB,EAAc,MAAM;AACvD;","x_google_ignoreList":[0]}