import { setTarget as w } from "../../render/utils/setters.js";
import { addValueToWillChange as y } from "../../value/use-will-change/add-will-change.js";
import { getOptimisedAppearId as M } from "../optimized-appear/get-appear-id.js";
import { animateMotionValue as S } from "./motion-value.js";
import { getValueTransition as H } from "../../../../../motion-dom/dist/es/animation/utils/get-value-transition.js";
import { frame as V } from "../../../../../motion-dom/dist/es/frameloop/frame.js";
import { positionalKeys as B } from "../../../../../motion-dom/dist/es/render/utils/keys-position.js";
function I({ protectedKeys: t, needsAnimating: a }, n) {
  const r = t.hasOwnProperty(n) && a[n] !== !0;
  return a[n] = !1, r;
}
function R(t, a, { delay: n = 0, transitionOverride: r, type: c } = {}) {
  let { transition: u = t.getDefaultTransition(), transitionEnd: f, ...d } = a;
  r && (u = r);
  const s = [], p = c && t.animationState && t.animationState.getState()[c];
  for (const o in d) {
    const i = t.getValue(o, t.latestValues[o] ?? null), e = d[o];
    if (e === void 0 || p && I(p, o))
      continue;
    const m = {
      delay: n,
      ...H(u || {}, o)
    }, l = i.get();
    if (l !== void 0 && !i.isAnimating && !Array.isArray(e) && e === l && !m.velocity)
      continue;
    let g = !1;
    if (window.MotionHandoffAnimation) {
      const h = M(t);
      if (h) {
        const A = window.MotionHandoffAnimation(h, o, V);
        A !== null && (m.startTime = A, g = !0);
      }
    }
    y(t, o), i.start(S(o, i, e, t.shouldReduceMotion && B.has(o) ? { type: !1 } : m, t, g));
    const T = i.animation;
    T && s.push(T);
  }
  return f && Promise.all(s).then(() => {
    V.update(() => {
      f && w(t, f);
    });
  }), s;
}
export {
  R as animateTarget
};
//# sourceMappingURL=visual-element-target.js.map
