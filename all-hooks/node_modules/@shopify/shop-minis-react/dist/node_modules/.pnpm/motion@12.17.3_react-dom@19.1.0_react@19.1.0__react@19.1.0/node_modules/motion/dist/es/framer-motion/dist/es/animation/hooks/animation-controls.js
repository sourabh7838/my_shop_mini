import { setTarget as i } from "../../render/utils/setters.js";
import { animateVisualElement as u } from "../interfaces/visual-element.js";
import { invariant as c } from "../../../../../motion-utils/dist/es/errors.js";
function l(t) {
  t.values.forEach((r) => r.stop());
}
function a(t, r) {
  [...r].reverse().forEach((o) => {
    const e = t.getVariant(o);
    e && i(t, e), t.variantChildren && t.variantChildren.forEach((s) => {
      a(s, r);
    });
  });
}
function h(t, r) {
  if (Array.isArray(r))
    return a(t, r);
  if (typeof r == "string")
    return a(t, [r]);
  i(t, r);
}
function b() {
  let t = !1;
  const r = /* @__PURE__ */ new Set(), n = {
    subscribe(o) {
      return r.add(o), () => void r.delete(o);
    },
    start(o, e) {
      c(t, "controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.");
      const s = [];
      return r.forEach((f) => {
        s.push(u(f, o, {
          transitionOverride: e
        }));
      }), Promise.all(s);
    },
    set(o) {
      return c(t, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook."), r.forEach((e) => {
        h(e, o);
      });
    },
    stop() {
      r.forEach((o) => {
        l(o);
      });
    },
    mount() {
      return t = !0, () => {
        t = !1, n.stop();
      };
    }
  };
  return n;
}
export {
  b as animationControls,
  h as setValues
};
//# sourceMappingURL=animation-controls.js.map
