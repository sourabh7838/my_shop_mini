import { JSAnimation as a } from "./JSAnimation.js";
import { NativeAnimation as m } from "./NativeAnimation.js";
import { replaceTransitionType as r } from "./utils/replace-transition-type.js";
import { replaceStringEasing as l } from "./waapi/utils/unsupported-easing.js";
import { secondsToMilliseconds as p } from "../../../../motion-utils/dist/es/time-conversion.js";
const s = 10;
class y extends m {
  constructor(e) {
    l(e), r(e), super(e), e.startTime && (this.startTime = e.startTime), this.options = e;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read commited styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(e) {
    const { motionValue: t, onUpdate: f, onComplete: d, element: u, ...n } = this.options;
    if (!t)
      return;
    if (e !== void 0) {
      t.set(e);
      return;
    }
    const i = new a({
      ...n,
      autoplay: !1
    }), o = p(this.finishedTime ?? this.time);
    t.setWithVelocity(i.sample(o - s).value, i.sample(o).value, s), i.stop();
  }
}
export {
  y as NativeAnimationExtended
};
//# sourceMappingURL=NativeAnimationExtended.js.map
