{"version":3,"file":"transform.js","sources":["../../../../../../../../../../../../../node_modules/.pnpm/motion@12.17.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/motion/dist/es/framer-motion/dist/es/projection/styles/transform.mjs"],"sourcesContent":["function buildProjectionTransform(delta, treeScale, latestTransform) {\n    let transform = \"\";\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    const xTranslate = delta.x.translate / treeScale.x;\n    const yTranslate = delta.y.translate / treeScale.y;\n    const zTranslate = latestTransform?.z || 0;\n    if (xTranslate || yTranslate || zTranslate) {\n        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;\n    }\n    /**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */\n    if (treeScale.x !== 1 || treeScale.y !== 1) {\n        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n    }\n    if (latestTransform) {\n        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;\n        if (transformPerspective)\n            transform = `perspective(${transformPerspective}px) ${transform}`;\n        if (rotate)\n            transform += `rotate(${rotate}deg) `;\n        if (rotateX)\n            transform += `rotateX(${rotateX}deg) `;\n        if (rotateY)\n            transform += `rotateY(${rotateY}deg) `;\n        if (skewX)\n            transform += `skewX(${skewX}deg) `;\n        if (skewY)\n            transform += `skewY(${skewY}deg) `;\n    }\n    /**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */\n    const elementScaleX = delta.x.scale * treeScale.x;\n    const elementScaleY = delta.y.scale * treeScale.y;\n    if (elementScaleX !== 1 || elementScaleY !== 1) {\n        transform += `scale(${elementScaleX}, ${elementScaleY})`;\n    }\n    return transform || \"none\";\n}\n\nexport { buildProjectionTransform };\n"],"names":["buildProjectionTransform","delta","treeScale","latestTransform","transform","xTranslate","yTranslate","zTranslate","transformPerspective","rotate","rotateX","rotateY","skewX","skewY","elementScaleX","elementScaleY"],"mappings":"AAAA,SAASA,EAAyBC,GAAOC,GAAWC,GAAiB;AACjE,MAAIC,IAAY;AAOhB,QAAMC,IAAaJ,EAAM,EAAE,YAAYC,EAAU,GAC3CI,IAAaL,EAAM,EAAE,YAAYC,EAAU,GAC3CK,IAAaJ,GAAiB,KAAK;AAWzC,OAVIE,KAAcC,KAAcC,OAC5BH,IAAY,eAAeC,CAAU,OAAOC,CAAU,OAAOC,CAAU,UAMvEL,EAAU,MAAM,KAAKA,EAAU,MAAM,OACrCE,KAAa,SAAS,IAAIF,EAAU,CAAC,KAAK,IAAIA,EAAU,CAAC,OAEzDC,GAAiB;AACjB,UAAM,EAAE,sBAAAK,GAAsB,QAAAC,GAAQ,SAAAC,GAAS,SAAAC,GAAS,OAAAC,GAAO,OAAAC,EAAK,IAAKV;AACzE,IAAIK,MACAJ,IAAY,eAAeI,CAAoB,OAAOJ,CAAS,KAC/DK,MACAL,KAAa,UAAUK,CAAM,UAC7BC,MACAN,KAAa,WAAWM,CAAO,UAC/BC,MACAP,KAAa,WAAWO,CAAO,UAC/BC,MACAR,KAAa,SAASQ,CAAK,UAC3BC,MACAT,KAAa,SAASS,CAAK;AAAA,EACvC;AAKI,QAAMC,IAAgBb,EAAM,EAAE,QAAQC,EAAU,GAC1Ca,IAAgBd,EAAM,EAAE,QAAQC,EAAU;AAChD,UAAIY,MAAkB,KAAKC,MAAkB,OACzCX,KAAa,SAASU,CAAa,KAAKC,CAAa,MAElDX,KAAa;AACxB;","x_google_ignoreList":[0]}