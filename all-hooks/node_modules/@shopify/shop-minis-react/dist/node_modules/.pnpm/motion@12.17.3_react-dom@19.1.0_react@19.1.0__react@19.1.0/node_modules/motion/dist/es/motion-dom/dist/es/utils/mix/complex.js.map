{"version":3,"file":"complex.js","sources":["../../../../../../../../../../../../../node_modules/.pnpm/motion@12.17.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/motion/dist/es/motion-dom/dist/es/utils/mix/complex.mjs"],"sourcesContent":["import { isCSSVariableToken } from '../../animation/utils/is-css-variable.mjs';\nimport { color } from '../../value/types/color/index.mjs';\nimport { complex, analyseComplexValue } from '../../value/types/complex/index.mjs';\nimport { mixColor } from './color.mjs';\nimport { mixImmediate } from './immediate.mjs';\nimport { mixNumber as mixNumber$1 } from './number.mjs';\nimport { invisibleValues, mixVisibility } from './visibility.mjs';\nimport { pipe } from '../../../../../motion-utils/dist/es/pipe.mjs';\nimport { warning } from '../../../../../motion-utils/dist/es/errors.mjs';\n\nfunction mixNumber(a, b) {\n    return (p) => mixNumber$1(a, b, p);\n}\nfunction getMixer(a) {\n    if (typeof a === \"number\") {\n        return mixNumber;\n    }\n    else if (typeof a === \"string\") {\n        return isCSSVariableToken(a)\n            ? mixImmediate\n            : color.test(a)\n                ? mixColor\n                : mixComplex;\n    }\n    else if (Array.isArray(a)) {\n        return mixArray;\n    }\n    else if (typeof a === \"object\") {\n        return color.test(a) ? mixColor : mixObject;\n    }\n    return mixImmediate;\n}\nfunction mixArray(a, b) {\n    const output = [...a];\n    const numValues = output.length;\n    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\n    return (p) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](p);\n        }\n        return output;\n    };\n}\nfunction mixObject(a, b) {\n    const output = { ...a, ...b };\n    const blendValue = {};\n    for (const key in output) {\n        if (a[key] !== undefined && b[key] !== undefined) {\n            blendValue[key] = getMixer(a[key])(a[key], b[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n}\nfunction matchOrder(origin, target) {\n    const orderedOrigin = [];\n    const pointers = { color: 0, var: 0, number: 0 };\n    for (let i = 0; i < target.values.length; i++) {\n        const type = target.types[i];\n        const originIndex = origin.indexes[type][pointers[type]];\n        const originValue = origin.values[originIndex] ?? 0;\n        orderedOrigin[i] = originValue;\n        pointers[type]++;\n    }\n    return orderedOrigin;\n}\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = analyseComplexValue(origin);\n    const targetStats = analyseComplexValue(target);\n    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&\n        originStats.indexes.color.length === targetStats.indexes.color.length &&\n        originStats.indexes.number.length >= targetStats.indexes.number.length;\n    if (canInterpolate) {\n        if ((invisibleValues.has(origin) &&\n            !targetStats.values.length) ||\n            (invisibleValues.has(target) &&\n                !originStats.values.length)) {\n            return mixVisibility(origin, target);\n        }\n        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\n    }\n    else {\n        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return mixImmediate(origin, target);\n    }\n};\n\nexport { getMixer, mixArray, mixComplex, mixObject };\n"],"names":["mixNumber","a","b","p","mixNumber$1","getMixer","isCSSVariableToken","mixImmediate","color","mixColor","mixComplex","mixArray","mixObject","output","numValues","blendValue","v","i","key","matchOrder","origin","target","orderedOrigin","pointers","type","originIndex","originValue","template","complex","originStats","analyseComplexValue","targetStats","invisibleValues","mixVisibility","pipe","warning"],"mappings":";;;;;;;;;AAUA,SAASA,EAAUC,GAAGC,GAAG;AACrB,SAAO,CAACC,MAAMC,EAAYH,GAAGC,GAAGC,CAAC;AACrC;AACA,SAASE,EAASJ,GAAG;AACjB,SAAI,OAAOA,KAAM,WACND,IAEF,OAAOC,KAAM,WACXK,EAAmBL,CAAC,IACrBM,IACAC,EAAM,KAAKP,CAAC,IACRQ,IACAC,IAEL,MAAM,QAAQT,CAAC,IACbU,IAEF,OAAOV,KAAM,WACXO,EAAM,KAAKP,CAAC,IAAIQ,IAAWG,IAE/BL;AACX;AACA,SAASI,EAASV,GAAGC,GAAG;AACpB,QAAMW,IAAS,CAAC,GAAGZ,CAAC,GACda,IAAYD,EAAO,QACnBE,IAAad,EAAE,IAAI,CAACe,GAAGC,MAAMZ,EAASW,CAAC,EAAEA,GAAGd,EAAEe,CAAC,CAAC,CAAC;AACvD,SAAO,CAACd,MAAM;AACV,aAASc,IAAI,GAAGA,IAAIH,GAAWG;AAC3B,MAAAJ,EAAOI,CAAC,IAAIF,EAAWE,CAAC,EAAEd,CAAC;AAE/B,WAAOU;AAAA,EACV;AACL;AACA,SAASD,EAAUX,GAAGC,GAAG;AACrB,QAAMW,IAAS,EAAE,GAAGZ,GAAG,GAAGC,EAAG,GACvBa,IAAa,CAAE;AACrB,aAAWG,KAAOL;AACd,IAAIZ,EAAEiB,CAAG,MAAM,UAAahB,EAAEgB,CAAG,MAAM,WACnCH,EAAWG,CAAG,IAAIb,EAASJ,EAAEiB,CAAG,CAAC,EAAEjB,EAAEiB,CAAG,GAAGhB,EAAEgB,CAAG,CAAC;AAGzD,SAAO,CAACF,MAAM;AACV,eAAWE,KAAOH;AACd,MAAAF,EAAOK,CAAG,IAAIH,EAAWG,CAAG,EAAEF,CAAC;AAEnC,WAAOH;AAAA,EACV;AACL;AACA,SAASM,EAAWC,GAAQC,GAAQ;AAChC,QAAMC,IAAgB,CAAE,GAClBC,IAAW,EAAE,OAAO,GAAG,KAAK,GAAG,QAAQ,EAAG;AAChD,WAASN,IAAI,GAAGA,IAAII,EAAO,OAAO,QAAQJ,KAAK;AAC3C,UAAMO,IAAOH,EAAO,MAAMJ,CAAC,GACrBQ,IAAcL,EAAO,QAAQI,CAAI,EAAED,EAASC,CAAI,CAAC,GACjDE,IAAcN,EAAO,OAAOK,CAAW,KAAK;AAClD,IAAAH,EAAcL,CAAC,IAAIS,GACnBH,EAASC,CAAI;AAAA,EACrB;AACI,SAAOF;AACX;AACK,MAACZ,IAAa,CAACU,GAAQC,MAAW;AACnC,QAAMM,IAAWC,EAAQ,kBAAkBP,CAAM,GAC3CQ,IAAcC,EAAoBV,CAAM,GACxCW,IAAcD,EAAoBT,CAAM;AAI9C,SAHuBQ,EAAY,QAAQ,IAAI,WAAWE,EAAY,QAAQ,IAAI,UAC9EF,EAAY,QAAQ,MAAM,WAAWE,EAAY,QAAQ,MAAM,UAC/DF,EAAY,QAAQ,OAAO,UAAUE,EAAY,QAAQ,OAAO,SAE3DC,EAAgB,IAAIZ,CAAM,KAC3B,CAACW,EAAY,OAAO,UACnBC,EAAgB,IAAIX,CAAM,KACvB,CAACQ,EAAY,OAAO,SACjBI,EAAcb,GAAQC,CAAM,IAEhCa,EAAKvB,EAASQ,EAAWU,GAAaE,CAAW,GAAGA,EAAY,MAAM,GAAGJ,CAAQ,KAGxFQ,EAAQ,IAAM,mBAAmBf,CAAM,UAAUC,CAAM,0KAA0K,GAC1Nd,EAAaa,GAAQC,CAAM;AAE1C;","x_google_ignoreList":[0]}