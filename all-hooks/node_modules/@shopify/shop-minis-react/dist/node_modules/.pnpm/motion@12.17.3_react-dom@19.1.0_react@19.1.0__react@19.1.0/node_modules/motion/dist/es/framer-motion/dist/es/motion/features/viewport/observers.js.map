{"version":3,"file":"observers.js","sources":["../../../../../../../../../../../../../../node_modules/.pnpm/motion@12.17.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/motion/dist/es/framer-motion/dist/es/motion/features/viewport/observers.mjs"],"sourcesContent":["/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nconst observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nconst observers = new WeakMap();\nconst fireObserverCallback = (entry) => {\n    const callback = observerCallbacks.get(entry.target);\n    callback && callback(entry);\n};\nconst fireAllObserverCallbacks = (entries) => {\n    entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver({ root, ...options }) {\n    const lookupRoot = root || document;\n    /**\n     * If we don't have an observer lookup map for this root, create one.\n     */\n    if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {});\n    }\n    const rootObservers = observers.get(lookupRoot);\n    const key = JSON.stringify(options);\n    /**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */\n    if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });\n    }\n    return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n    const rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return () => {\n        observerCallbacks.delete(element);\n        rootInteresectionObserver.unobserve(element);\n    };\n}\n\nexport { observeIntersection };\n"],"names":["observerCallbacks","observers","fireObserverCallback","entry","callback","fireAllObserverCallbacks","entries","initIntersectionObserver","root","options","lookupRoot","rootObservers","key","observeIntersection","element","rootInteresectionObserver"],"mappings":"AAKA,MAAMA,IAAoB,oBAAI,QAAS,GAMjCC,IAAY,oBAAI,QAAS,GACzBC,IAAuB,CAACC,MAAU;AACpC,QAAMC,IAAWJ,EAAkB,IAAIG,EAAM,MAAM;AACnD,EAAAC,KAAYA,EAASD,CAAK;AAC9B,GACME,IAA2B,CAACC,MAAY;AAC1C,EAAAA,EAAQ,QAAQJ,CAAoB;AACxC;AACA,SAASK,EAAyB,EAAE,MAAAC,GAAM,GAAGC,KAAW;AACpD,QAAMC,IAAaF,KAAQ;AAI3B,EAAKP,EAAU,IAAIS,CAAU,KACzBT,EAAU,IAAIS,GAAY,EAAE;AAEhC,QAAMC,IAAgBV,EAAU,IAAIS,CAAU,GACxCE,IAAM,KAAK,UAAUH,CAAO;AAKlC,SAAKE,EAAcC,CAAG,MAClBD,EAAcC,CAAG,IAAI,IAAI,qBAAqBP,GAA0B,EAAE,MAAAG,GAAM,GAAGC,GAAS,IAEzFE,EAAcC,CAAG;AAC5B;AACA,SAASC,EAAoBC,GAASL,GAASL,GAAU;AACrD,QAAMW,IAA4BR,EAAyBE,CAAO;AAClE,SAAAT,EAAkB,IAAIc,GAASV,CAAQ,GACvCW,EAA0B,QAAQD,CAAO,GAClC,MAAM;AACT,IAAAd,EAAkB,OAAOc,CAAO,GAChCC,EAA0B,UAAUD,CAAO;AAAA,EAC9C;AACL;","x_google_ignoreList":[0]}