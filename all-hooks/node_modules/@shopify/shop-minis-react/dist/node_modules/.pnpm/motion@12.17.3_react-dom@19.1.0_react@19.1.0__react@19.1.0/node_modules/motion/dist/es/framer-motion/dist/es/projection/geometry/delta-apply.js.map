{"version":3,"file":"delta-apply.js","sources":["../../../../../../../../../../../../../node_modules/.pnpm/motion@12.17.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/motion/dist/es/framer-motion/dist/es/projection/geometry/delta-apply.mjs"],"sourcesContent":["import { hasTransform } from '../utils/has-transform.mjs';\nimport { mixNumber } from '../../../../../motion-dom/dist/es/utils/mix/number.mjs';\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    const distanceFromOrigin = point - originPoint;\n    const scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, { x, y }) {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n    const treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    let node;\n    let delta;\n    for (let i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.projectionDelta;\n        /**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */\n        const { visualElement } = node.options;\n        if (visualElement &&\n            visualElement.props.style &&\n            visualElement.props.style.display === \"contents\") {\n            continue;\n        }\n        if (isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.offset.x,\n                y: -node.scroll.offset.y,\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n    /**\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */\n    if (treeScale.x < TREE_SCALE_SNAP_MAX &&\n        treeScale.x > TREE_SCALE_SNAP_MIN) {\n        treeScale.x = 1.0;\n    }\n    if (treeScale.y < TREE_SCALE_SNAP_MAX &&\n        treeScale.y > TREE_SCALE_SNAP_MIN) {\n        treeScale.y = 1.0;\n    }\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\n    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\n}\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\n}\n\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };\n"],"names":["scalePoint","point","scale","originPoint","distanceFromOrigin","scaled","applyPointDelta","translate","boxScale","applyAxisDelta","axis","applyBoxDelta","box","x","y","TREE_SCALE_SNAP_MIN","TREE_SCALE_SNAP_MAX","applyTreeDeltas","treeScale","treePath","isSharedTransition","treeLength","node","delta","i","visualElement","transformBox","hasTransform","translateAxis","distance","transformAxis","axisTranslate","axisScale","axisOrigin","mixNumber","transform"],"mappings":";;AAMA,SAASA,EAAWC,GAAOC,GAAOC,GAAa;AAC3C,QAAMC,IAAqBH,IAAQE,GAC7BE,IAASH,IAAQE;AACvB,SAAOD,IAAcE;AACzB;AAIA,SAASC,EAAgBL,GAAOM,GAAWL,GAAOC,GAAaK,GAAU;AACrE,SAAIA,MAAa,WACbP,IAAQD,EAAWC,GAAOO,GAAUL,CAAW,IAE5CH,EAAWC,GAAOC,GAAOC,CAAW,IAAII;AACnD;AAIA,SAASE,EAAeC,GAAMH,IAAY,GAAGL,IAAQ,GAAGC,GAAaK,GAAU;AAC3E,EAAAE,EAAK,MAAMJ,EAAgBI,EAAK,KAAKH,GAAWL,GAAOC,GAAaK,CAAQ,GAC5EE,EAAK,MAAMJ,EAAgBI,EAAK,KAAKH,GAAWL,GAAOC,GAAaK,CAAQ;AAChF;AAIA,SAASG,EAAcC,GAAK,EAAE,GAAAC,GAAG,GAAAC,EAAC,GAAI;AAClC,EAAAL,EAAeG,EAAI,GAAGC,EAAE,WAAWA,EAAE,OAAOA,EAAE,WAAW,GACzDJ,EAAeG,EAAI,GAAGE,EAAE,WAAWA,EAAE,OAAOA,EAAE,WAAW;AAC7D;AACA,MAAMC,IAAsB,gBACtBC,IAAsB;AAO5B,SAASC,EAAgBL,GAAKM,GAAWC,GAAUC,IAAqB,IAAO;AAC3E,QAAMC,IAAaF,EAAS;AAC5B,MAAI,CAACE;AACD;AAEJ,EAAAH,EAAU,IAAIA,EAAU,IAAI;AAC5B,MAAII,GACAC;AACJ,WAASC,IAAI,GAAGA,IAAIH,GAAYG,KAAK;AACjC,IAAAF,IAAOH,EAASK,CAAC,GACjBD,IAAQD,EAAK;AAKb,UAAM,EAAE,eAAAG,MAAkBH,EAAK;AAC/B,IAAIG,KACAA,EAAc,MAAM,SACpBA,EAAc,MAAM,MAAM,YAAY,eAGtCL,KACAE,EAAK,QAAQ,gBACbA,EAAK,UACLA,MAASA,EAAK,QACdI,EAAad,GAAK;AAAA,MACd,GAAG,CAACU,EAAK,OAAO,OAAO;AAAA,MACvB,GAAG,CAACA,EAAK,OAAO,OAAO;AAAA,IACvC,CAAa,GAEDC,MAEAL,EAAU,KAAKK,EAAM,EAAE,OACvBL,EAAU,KAAKK,EAAM,EAAE,OAEvBZ,EAAcC,GAAKW,CAAK,IAExBH,KAAsBO,EAAaL,EAAK,YAAY,KACpDI,EAAad,GAAKU,EAAK,YAAY;AAAA,EAE/C;AAKI,EAAIJ,EAAU,IAAIF,KACdE,EAAU,IAAIH,MACdG,EAAU,IAAI,IAEdA,EAAU,IAAIF,KACdE,EAAU,IAAIH,MACdG,EAAU,IAAI;AAEtB;AACA,SAASU,EAAclB,GAAMmB,GAAU;AACnC,EAAAnB,EAAK,MAAMA,EAAK,MAAMmB,GACtBnB,EAAK,MAAMA,EAAK,MAAMmB;AAC1B;AAMA,SAASC,EAAcpB,GAAMqB,GAAeC,GAAWxB,GAAUyB,IAAa,KAAK;AAC/E,QAAM9B,IAAc+B,EAAUxB,EAAK,KAAKA,EAAK,KAAKuB,CAAU;AAE5D,EAAAxB,EAAeC,GAAMqB,GAAeC,GAAW7B,GAAaK,CAAQ;AACxE;AAIA,SAASkB,EAAad,GAAKuB,GAAW;AAClC,EAAAL,EAAclB,EAAI,GAAGuB,EAAU,GAAGA,EAAU,QAAQA,EAAU,OAAOA,EAAU,OAAO,GACtFL,EAAclB,EAAI,GAAGuB,EAAU,GAAGA,EAAU,QAAQA,EAAU,OAAOA,EAAU,OAAO;AAC1F;","x_google_ignoreList":[0]}