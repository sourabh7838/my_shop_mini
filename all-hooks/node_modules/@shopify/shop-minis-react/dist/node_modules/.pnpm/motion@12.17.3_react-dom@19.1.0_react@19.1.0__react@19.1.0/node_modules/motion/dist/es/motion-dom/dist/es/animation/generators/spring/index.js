import { generateLinearEasing as w } from "../../waapi/utils/linear.js";
import { calcGeneratorDuration as B, maxGeneratorDuration as E } from "../utils/calc-duration.js";
import { createGeneratorEasing as K } from "../utils/create-generator-easing.js";
import { calcGeneratorVelocity as O } from "../utils/velocity.js";
import { springDefaults as a } from "./defaults.js";
import { findSpring as V, calcAngularFreq as j } from "./find.js";
import { millisecondsToSeconds as T, secondsToMilliseconds as k } from "../../../../../../motion-utils/dist/es/time-conversion.js";
import { clamp as I } from "../../../../../../motion-utils/dist/es/clamp.js";
const L = ["duration", "bounce"], P = ["stiffness", "damping", "mass"];
function b(t, n) {
  return n.some((s) => t[s] !== void 0);
}
function z(t) {
  let n = {
    velocity: a.velocity,
    stiffness: a.stiffness,
    damping: a.damping,
    mass: a.mass,
    isResolvedFromDuration: !1,
    ...t
  };
  if (!b(t, P) && b(t, L))
    if (t.visualDuration) {
      const s = t.visualDuration, u = 2 * Math.PI / (s * 1.2), m = u * u, h = 2 * I(0.05, 1, 1 - (t.bounce || 0)) * Math.sqrt(m);
      n = {
        ...n,
        mass: a.mass,
        stiffness: m,
        damping: h
      };
    } else {
      const s = V(t);
      n = {
        ...n,
        ...s,
        mass: a.mass
      }, n.isResolvedFromDuration = !0;
    }
  return n;
}
function x(t = a.visualDuration, n = a.bounce) {
  const s = typeof t != "object" ? {
    visualDuration: t,
    keyframes: [0, 1],
    bounce: n
  } : t;
  let { restSpeed: u, restDelta: m } = s;
  const h = s.keyframes[0], f = s.keyframes[s.keyframes.length - 1], d = { done: !1, value: h }, { stiffness: M, damping: G, mass: D, duration: S, velocity: R, isResolvedFromDuration: q } = z({
    ...s,
    velocity: -T(s.velocity || 0)
  }), p = R || 0, o = G / (2 * Math.sqrt(M * D)), c = f - h, i = T(Math.sqrt(M / D)), F = Math.abs(c) < 5;
  u || (u = F ? a.restSpeed.granular : a.restSpeed.default), m || (m = F ? a.restDelta.granular : a.restDelta.default);
  let g;
  if (o < 1) {
    const e = j(i, o);
    g = (r) => {
      const l = Math.exp(-o * i * r);
      return f - l * ((p + o * i * c) / e * Math.sin(e * r) + c * Math.cos(e * r));
    };
  } else if (o === 1)
    g = (e) => f - Math.exp(-i * e) * (c + (p + i * c) * e);
  else {
    const e = i * Math.sqrt(o * o - 1);
    g = (r) => {
      const l = Math.exp(-o * i * r), y = Math.min(e * r, 300);
      return f - l * ((p + o * i * c) * Math.sinh(y) + e * c * Math.cosh(y)) / e;
    };
  }
  const v = {
    calculatedDuration: q && S || null,
    next: (e) => {
      const r = g(e);
      if (q)
        d.done = e >= S;
      else {
        let l = e === 0 ? p : 0;
        o < 1 && (l = e === 0 ? k(p) : O(g, e, r));
        const y = Math.abs(l) <= u, A = Math.abs(f - r) <= m;
        d.done = y && A;
      }
      return d.value = d.done ? f : r, d;
    },
    toString: () => {
      const e = Math.min(B(v), E), r = w((l) => v.next(e * l).value, e, 30);
      return e + "ms " + r;
    },
    toTransition: () => {
    }
  };
  return v;
}
x.applyToOptions = (t) => {
  const n = K(t, 100, x);
  return t.ease = n.ease, t.duration = k(n.duration), t.type = "keyframes", t;
};
export {
  x as spring
};
//# sourceMappingURL=index.js.map
