import { time as d } from "../frameloop/sync-time.js";
import { mix as G } from "../utils/mix/index.js";
import { frameloopDriver as I } from "./drivers/frame.js";
import { inertia as K } from "./generators/inertia.js";
import { keyframes as u } from "./generators/keyframes.js";
import { calcGeneratorDuration as O } from "./generators/utils/calc-duration.js";
import { getFinalKeyframe as C } from "./keyframes/get-final.js";
import { replaceTransitionType as E } from "./utils/replace-transition-type.js";
import { WithPromise as N } from "./utils/WithPromise.js";
import { invariant as V } from "../../../../motion-utils/dist/es/errors.js";
import { pipe as W } from "../../../../motion-utils/dist/es/pipe.js";
import { millisecondsToSeconds as y, secondsToMilliseconds as $ } from "../../../../motion-utils/dist/es/time-conversion.js";
import { clamp as B } from "../../../../motion-utils/dist/es/clamp.js";
const J = (v) => v / 100;
class et extends N {
  constructor(t) {
    super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
      const { motionValue: i } = this.options;
      i && i.updatedAt !== d.now() && this.tick(d.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), this.options.onStop?.());
    }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options: t } = this;
    E(t);
    const { type: i = u, repeat: r = 0, repeatDelay: s = 0, repeatType: m, velocity: c = 0 } = t;
    let { keyframes: e } = t;
    const o = i || u;
    process.env.NODE_ENV !== "production" && o !== u && V(e.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${e}`), o !== u && typeof e[0] != "number" && (this.mixKeyframes = W(J, G(e[0], e[1])), e = [0, 100]);
    const n = o({ ...t, keyframes: e });
    m === "mirror" && (this.mirroredGenerator = o({
      ...t,
      keyframes: [...e].reverse(),
      velocity: -c
    })), n.calculatedDuration === null && (n.calculatedDuration = O(n));
    const { calculatedDuration: l } = n;
    this.calculatedDuration = l, this.resolvedDuration = l + s, this.totalDuration = this.resolvedDuration * (r + 1) - s, this.generator = n;
  }
  updateTime(t) {
    const i = Math.round(t - this.startTime) * this.playbackSpeed;
    this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = i;
  }
  tick(t, i = !1) {
    const { generator: r, totalDuration: s, mixKeyframes: m, mirroredGenerator: c, resolvedDuration: e, calculatedDuration: o } = this;
    if (this.startTime === null)
      return r.next(0);
    const { delay: n = 0, keyframes: l, repeat: k, repeatType: D, repeatDelay: g, type: F, onUpdate: S, finalKeyframe: P } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - s / this.speed, this.startTime)), i ? this.currentTime = t : this.updateTime(t);
    const f = this.currentTime - n * (this.playbackSpeed >= 0 ? 1 : -1), b = this.playbackSpeed >= 0 ? f < 0 : f > s;
    this.currentTime = Math.max(f, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = s);
    let w = this.currentTime, x = r;
    if (k) {
      const T = Math.min(this.currentTime, s) / e;
      let p = Math.floor(T), a = T % 1;
      !a && T >= 1 && (a = 1), a === 1 && p--, p = Math.min(p, k + 1), !!(p % 2) && (D === "reverse" ? (a = 1 - a, g && (a -= g / e)) : D === "mirror" && (x = c)), w = B(0, 1, a) * e;
    }
    const h = b ? { done: !1, value: l[0] } : x.next(w);
    m && (h.value = m(h.value));
    let { done: M } = h;
    !b && o !== null && (M = this.playbackSpeed >= 0 ? this.currentTime >= s : this.currentTime <= 0);
    const A = this.holdTime === null && (this.state === "finished" || this.state === "running" && M);
    return A && F !== K && (h.value = C(l, this.options, P, this.speed)), S && S(h.value), A && this.finish(), h;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(t, i) {
    return this.finished.then(t, i);
  }
  get duration() {
    return y(this.calculatedDuration);
  }
  get time() {
    return y(this.currentTime);
  }
  set time(t) {
    t = $(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), this.driver?.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    this.updateTime(d.now());
    const i = this.playbackSpeed !== t;
    this.playbackSpeed = t, i && (this.time = y(this.currentTime));
  }
  play() {
    if (this.isStopped)
      return;
    const { driver: t = I, startTime: i } = this.options;
    this.driver || (this.driver = t((s) => this.tick(s))), this.options.onPlay?.();
    const r = this.driver.now();
    this.state === "finished" ? (this.updateFinished(), this.startTime = r) : this.holdTime !== null ? this.startTime = r - this.holdTime : this.startTime || (this.startTime = i ?? r), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    this.state = "paused", this.updateTime(d.now()), this.holdTime = this.currentTime;
  }
  complete() {
    this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.notifyFinished(), this.teardown(), this.state = "finished", this.options.onComplete?.();
  }
  cancel() {
    this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null;
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(t) {
    return this.startTime = 0, this.tick(t, !0);
  }
  attachTimeline(t) {
    return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), this.driver?.stop(), t.observe(this);
  }
}
export {
  et as JSAnimation
};
//# sourceMappingURL=JSAnimation.js.map
