import { animateMotionValue as L } from "../../animation/interfaces/motion-value.js";
import { addDomEvent as M } from "../../events/add-dom-event.js";
import { addPointerEvent as S } from "../../events/add-pointer-event.js";
import { extractEventInfo as B } from "../../events/event-info.js";
import { convertBoxToBoundingBox as k, convertBoundingBoxToBox as j } from "../../projection/geometry/conversion.js";
import { calcLength as T } from "../../projection/geometry/delta-calc.js";
import { createBox as w } from "../../projection/geometry/models.js";
import { eachAxis as u } from "../../projection/utils/each-axis.js";
import { measurePageBox as b } from "../../projection/utils/measure.js";
import { getContextWindow as R } from "../../utils/get-context-window.js";
import { isRefObject as D } from "../../utils/is-ref-object.js";
import { addValueToWillChange as V } from "../../value/use-will-change/add-will-change.js";
import { PanSession as W } from "../pan/PanSession.js";
import { applyConstraints as O, calcRelativeConstraints as U, resolveDragElastic as z, calcViewportConstraints as I, defaultElastic as _, rebaseAxisConstraints as F, calcOrigin as K } from "./utils/constraints.js";
import { frame as C } from "../../../../../motion-dom/dist/es/frameloop/frame.js";
import { invariant as N } from "../../../../../motion-utils/dist/es/errors.js";
import { setDragLock as $ } from "../../../../../motion-dom/dist/es/gestures/drag/state/set-active.js";
import { percent as q } from "../../../../../motion-dom/dist/es/value/types/numbers/units.js";
import { mixNumber as x } from "../../../../../motion-dom/dist/es/utils/mix/number.js";
const G = /* @__PURE__ */ new WeakMap();
class ft {
  constructor(t) {
    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = w(), this.visualElement = t;
  }
  start(t, { snapToCursor: n = !1 } = {}) {
    const { presenceContext: s } = this.visualElement;
    if (s && s.isPresent === !1)
      return;
    const i = (r) => {
      const { dragSnapToOrigin: c } = this.getProps();
      c ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(B(r).point);
    }, o = (r, c) => {
      const { drag: f, dragPropagation: d, onDragStart: g } = this.getProps();
      if (f && !d && (this.openDragLock && this.openDragLock(), this.openDragLock = $(f), !this.openDragLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), u((m) => {
        let E = this.getAxisMotionValue(m).get() || 0;
        if (q.test(E)) {
          const { projection: A } = this.visualElement;
          if (A && A.layout) {
            const y = A.layout.layoutBox[m];
            y && (E = T(y) * (parseFloat(E) / 100));
          }
        }
        this.originPoint[m] = E;
      }), g && C.postRender(() => g(r, c)), V(this.visualElement, "transform");
      const { animationState: v } = this.visualElement;
      v && v.setActive("whileDrag", !0);
    }, e = (r, c) => {
      const { dragPropagation: f, dragDirectionLock: d, onDirectionLock: g, onDrag: v } = this.getProps();
      if (!f && !this.openDragLock)
        return;
      const { offset: m } = c;
      if (d && this.currentDirection === null) {
        this.currentDirection = H(m), this.currentDirection !== null && g && g(this.currentDirection);
        return;
      }
      this.updateAxis("x", c.point, m), this.updateAxis("y", c.point, m), this.visualElement.render(), v && v(r, c);
    }, a = (r, c) => this.stop(r, c), l = () => u((r) => this.getAnimationState(r) === "paused" && this.getAxisMotionValue(r).animation?.play()), { dragSnapToOrigin: h } = this.getProps();
    this.panSession = new W(t, {
      onSessionStart: i,
      onStart: o,
      onMove: e,
      onSessionEnd: a,
      resumeAnimation: l
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: h,
      contextWindow: R(this.visualElement)
    });
  }
  stop(t, n) {
    const s = this.isDragging;
    if (this.cancel(), !s)
      return;
    const { velocity: i } = n;
    this.startAnimation(i);
    const { onDragEnd: o } = this.getProps();
    o && C.postRender(() => o(t, n));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: t, animationState: n } = this.visualElement;
    t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: s } = this.getProps();
    !s && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1);
  }
  updateAxis(t, n, s) {
    const { drag: i } = this.getProps();
    if (!s || !P(t, i, this.currentDirection))
      return;
    const o = this.getAxisMotionValue(t);
    let e = this.originPoint[t] + s[t];
    this.constraints && this.constraints[t] && (e = O(e, this.constraints[t], this.elastic[t])), o.set(e);
  }
  resolveConstraints() {
    const { dragConstraints: t, dragElastic: n } = this.getProps(), s = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, i = this.constraints;
    t && D(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && s ? this.constraints = U(s.layoutBox, t) : this.constraints = !1, this.elastic = z(n), i !== this.constraints && s && this.constraints && !this.hasMutatedConstraints && u((o) => {
      this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = F(s.layoutBox[o], this.constraints[o]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps();
    if (!t || !D(t))
      return !1;
    const s = t.current;
    N(s !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: i } = this.visualElement;
    if (!i || !i.layout)
      return !1;
    const o = b(s, i.root, this.visualElement.getTransformPagePoint());
    let e = I(i.layout.layoutBox, o);
    if (n) {
      const a = n(k(e));
      this.hasMutatedConstraints = !!a, a && (e = j(a));
    }
    return e;
  }
  startAnimation(t) {
    const { drag: n, dragMomentum: s, dragElastic: i, dragTransition: o, dragSnapToOrigin: e, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, h = u((r) => {
      if (!P(r, n, this.currentDirection))
        return;
      let c = l && l[r] || {};
      e && (c = { min: 0, max: 0 });
      const f = i ? 200 : 1e6, d = i ? 40 : 1e7, g = {
        type: "inertia",
        velocity: s ? t[r] : 0,
        bounceStiffness: f,
        bounceDamping: d,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...o,
        ...c
      };
      return this.startAxisValueAnimation(r, g);
    });
    return Promise.all(h).then(a);
  }
  startAxisValueAnimation(t, n) {
    const s = this.getAxisMotionValue(t);
    return V(this.visualElement, t), s.start(L(t, s, 0, n, this.visualElement, !1));
  }
  stopAnimation() {
    u((t) => this.getAxisMotionValue(t).stop());
  }
  pauseAnimation() {
    u((t) => this.getAxisMotionValue(t).animation?.pause());
  }
  getAnimationState(t) {
    return this.getAxisMotionValue(t).animation?.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(t) {
    const n = `_drag${t.toUpperCase()}`, s = this.visualElement.getProps(), i = s[n];
    return i || this.visualElement.getValue(t, (s.initial ? s.initial[t] : void 0) || 0);
  }
  snapToCursor(t) {
    u((n) => {
      const { drag: s } = this.getProps();
      if (!P(n, s, this.currentDirection))
        return;
      const { projection: i } = this.visualElement, o = this.getAxisMotionValue(n);
      if (i && i.layout) {
        const { min: e, max: a } = i.layout.layoutBox[n];
        o.set(t[n] - x(e, a, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: t, dragConstraints: n } = this.getProps(), { projection: s } = this.visualElement;
    if (!D(n) || !s || !this.constraints)
      return;
    this.stopAnimation();
    const i = { x: 0, y: 0 };
    u((e) => {
      const a = this.getAxisMotionValue(e);
      if (a && this.constraints !== !1) {
        const l = a.get();
        i[e] = K({ min: l, max: l }, this.constraints[e]);
      }
    });
    const { transformTemplate: o } = this.visualElement.getProps();
    this.visualElement.current.style.transform = o ? o({}, "") : "none", s.root && s.root.updateScroll(), s.updateLayout(), this.resolveConstraints(), u((e) => {
      if (!P(e, t, null))
        return;
      const a = this.getAxisMotionValue(e), { min: l, max: h } = this.constraints[e];
      a.set(x(l, h, i[e]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    G.set(this.visualElement, this);
    const t = this.visualElement.current, n = S(t, "pointerdown", (l) => {
      const { drag: h, dragListener: r = !0 } = this.getProps();
      h && r && this.start(l);
    }), s = () => {
      const { dragConstraints: l } = this.getProps();
      D(l) && l.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: i } = this.visualElement, o = i.addEventListener("measure", s);
    i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), C.read(s);
    const e = M(window, "resize", () => this.scalePositionWithinConstraints()), a = i.addEventListener("didUpdate", ({ delta: l, hasLayoutChanged: h }) => {
      this.isDragging && h && (u((r) => {
        const c = this.getAxisMotionValue(r);
        c && (this.originPoint[r] += l[r].translate, c.set(c.get() + l[r].translate));
      }), this.visualElement.render());
    });
    return () => {
      e(), n(), o(), a && a();
    };
  }
  getProps() {
    const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: s = !1, dragPropagation: i = !1, dragConstraints: o = !1, dragElastic: e = _, dragMomentum: a = !0 } = t;
    return {
      ...t,
      drag: n,
      dragDirectionLock: s,
      dragPropagation: i,
      dragConstraints: o,
      dragElastic: e,
      dragMomentum: a
    };
  }
}
function P(p, t, n) {
  return (t === !0 || t === p) && (n === null || n === p);
}
function H(p, t = 10) {
  let n = null;
  return Math.abs(p.y) > t ? n = "y" : Math.abs(p.x) > t && (n = "x"), n;
}
export {
  ft as VisualElementDragControls,
  G as elementDragControls
};
//# sourceMappingURL=VisualElementDragControls.js.map
