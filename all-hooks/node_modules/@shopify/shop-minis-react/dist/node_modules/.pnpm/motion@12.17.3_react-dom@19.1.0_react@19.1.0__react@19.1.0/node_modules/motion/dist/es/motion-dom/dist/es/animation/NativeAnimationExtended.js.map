{"version":3,"file":"NativeAnimationExtended.js","sources":["../../../../../../../../../../../../node_modules/.pnpm/motion@12.17.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/motion/dist/es/motion-dom/dist/es/animation/NativeAnimationExtended.mjs"],"sourcesContent":["import { JSAnimation } from './JSAnimation.mjs';\nimport { NativeAnimation } from './NativeAnimation.mjs';\nimport { replaceTransitionType } from './utils/replace-transition-type.mjs';\nimport { replaceStringEasing } from './waapi/utils/unsupported-easing.mjs';\nimport { secondsToMilliseconds } from '../../../../motion-utils/dist/es/time-conversion.mjs';\n\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\nclass NativeAnimationExtended extends NativeAnimation {\n    constructor(options) {\n        /**\n         * The base NativeAnimation function only supports a subset\n         * of Motion easings, and WAAPI also only supports some\n         * easing functions via string/cubic-bezier definitions.\n         *\n         * This function replaces those unsupported easing functions\n         * with a JS easing function. This will later get compiled\n         * to a linear() easing function.\n         */\n        replaceStringEasing(options);\n        /**\n         * Ensure we replace the transition type with a generator function\n         * before passing to WAAPI.\n         *\n         * TODO: Does this have a better home? It could be shared with\n         * JSAnimation.\n         */\n        replaceTransitionType(options);\n        super(options);\n        if (options.startTime) {\n            this.startTime = options.startTime;\n        }\n        this.options = options;\n    }\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * Rather than read commited styles back out of the DOM, we can\n     * create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to calculate velocity for any subsequent animation.\n     */\n    updateMotionValue(value) {\n        const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\n        if (!motionValue)\n            return;\n        if (value !== undefined) {\n            motionValue.set(value);\n            return;\n        }\n        const sampleAnimation = new JSAnimation({\n            ...options,\n            autoplay: false,\n        });\n        const sampleTime = secondsToMilliseconds(this.finishedTime ?? this.time);\n        motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n        sampleAnimation.stop();\n    }\n}\n\nexport { NativeAnimationExtended };\n"],"names":["sampleDelta","NativeAnimationExtended","NativeAnimation","options","replaceStringEasing","replaceTransitionType","value","motionValue","onUpdate","onComplete","element","sampleAnimation","JSAnimation","sampleTime","secondsToMilliseconds"],"mappings":";;;;;AAWA,MAAMA,IAAc;AACpB,MAAMC,UAAgCC,EAAgB;AAAA,EAClD,YAAYC,GAAS;AAUjB,IAAAC,EAAoBD,CAAO,GAQ3BE,EAAsBF,CAAO,GAC7B,MAAMA,CAAO,GACTA,EAAQ,cACR,KAAK,YAAYA,EAAQ,YAE7B,KAAK,UAAUA;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASI,kBAAkBG,GAAO;AACrB,UAAM,EAAE,aAAAC,GAAa,UAAAC,GAAU,YAAAC,GAAY,SAAAC,GAAS,GAAGP,EAAO,IAAK,KAAK;AACxE,QAAI,CAACI;AACD;AACJ,QAAID,MAAU,QAAW;AACrB,MAAAC,EAAY,IAAID,CAAK;AACrB;AAAA,IACZ;AACQ,UAAMK,IAAkB,IAAIC,EAAY;AAAA,MACpC,GAAGT;AAAA,MACH,UAAU;AAAA,IACtB,CAAS,GACKU,IAAaC,EAAsB,KAAK,gBAAgB,KAAK,IAAI;AACvE,IAAAP,EAAY,gBAAgBI,EAAgB,OAAOE,IAAab,CAAW,EAAE,OAAOW,EAAgB,OAAOE,CAAU,EAAE,OAAOb,CAAW,GACzIW,EAAgB,KAAM;AAAA,EAC9B;AACA;","x_google_ignoreList":[0]}