import { positionalKeys as h } from "../../render/utils/keys-position.js";
import { findDimensionValueType as u } from "../../value/types/dimensions.js";
import { getVariableValue as p } from "../utils/css-variables-conversion.js";
import { isCSSVariableToken as y } from "../utils/is-css-variable.js";
import { KeyframeResolver as g } from "./KeyframesResolver.js";
import { isNone as c } from "./utils/is-none.js";
import { makeNoneKeyframesAnimatable as K } from "./utils/make-none-animatable.js";
import { isNumOrPxType as d, positionalValues as m } from "./utils/unit-conversion.js";
class k extends g {
  constructor(e, n, r, t, o) {
    super(e, n, r, t, o, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: n, name: r } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let s = 0; s < e.length; s++) {
      let i = e[s];
      if (typeof i == "string" && (i = i.trim(), y(i))) {
        const l = p(i, n.current);
        l !== void 0 && (e[s] = l), s === e.length - 1 && (this.finalKeyframe = i);
      }
    }
    if (this.resolveNoneKeyframes(), !h.has(r) || e.length !== 2)
      return;
    const [t, o] = e, a = u(t), f = u(o);
    if (a !== f)
      if (d(a) && d(f))
        for (let s = 0; s < e.length; s++) {
          const i = e[s];
          typeof i == "string" && (e[s] = parseFloat(i));
        }
      else m[r] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: n } = this, r = [];
    for (let t = 0; t < e.length; t++)
      (e[t] === null || c(e[t])) && r.push(t);
    r.length && K(e, r, n);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: n, name: r } = this;
    if (!e || !e.current)
      return;
    r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = m[r](e.measureViewportBox(), window.getComputedStyle(e.current)), n[0] = this.measuredOrigin;
    const t = n[n.length - 1];
    t !== void 0 && e.getValue(r, t).jump(t, !1);
  }
  measureEndState() {
    const { element: e, name: n, unresolvedKeyframes: r } = this;
    if (!e || !e.current)
      return;
    const t = e.getValue(n);
    t && t.jump(this.measuredOrigin, !1);
    const o = r.length - 1, a = r[o];
    r[o] = m[n](e.measureViewportBox(), window.getComputedStyle(e.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), this.removedTransforms?.length && this.removedTransforms.forEach(([f, s]) => {
      e.getValue(f).set(s);
    }), this.resolveNoneKeyframes();
  }
}
export {
  k as DOMKeyframesResolver
};
//# sourceMappingURL=DOMKeyframesResolver.js.map
