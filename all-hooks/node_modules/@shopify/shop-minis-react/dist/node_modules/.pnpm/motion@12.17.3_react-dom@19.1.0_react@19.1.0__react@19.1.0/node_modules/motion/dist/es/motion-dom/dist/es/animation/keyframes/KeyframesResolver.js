import { fillWildcards as y } from "./utils/fill-wildcards.js";
import { removeNonTranslationalTransform as p } from "./utils/unit-conversion.js";
import { frame as c } from "../../frameloop/frame.js";
const l = /* @__PURE__ */ new Set();
let f = !1, d = !1, m = !1;
function u() {
  if (d) {
    const a = Array.from(l).filter((e) => e.needsMeasurement), s = new Set(a.map((e) => e.element)), r = /* @__PURE__ */ new Map();
    s.forEach((e) => {
      const t = p(e);
      t.length && (r.set(e, t), e.render());
    }), a.forEach((e) => e.measureInitialState()), s.forEach((e) => {
      e.render();
      const t = r.get(e);
      t && t.forEach(([n, i]) => {
        e.getValue(n)?.set(i);
      });
    }), a.forEach((e) => e.measureEndState()), a.forEach((e) => {
      e.suspendedScrollY !== void 0 && window.scrollTo(0, e.suspendedScrollY);
    });
  }
  d = !1, f = !1, l.forEach((a) => a.complete(m)), l.clear();
}
function h() {
  l.forEach((a) => {
    a.readKeyframes(), a.needsMeasurement && (d = !0);
  });
}
function S() {
  m = !0, h(), u(), m = !1;
}
class g {
  constructor(s, r, e, t, n, i = !1) {
    this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...s], this.onComplete = r, this.name = e, this.motionValue = t, this.element = n, this.isAsync = i;
  }
  scheduleResolve() {
    this.state = "scheduled", this.isAsync ? (l.add(this), f || (f = !0, c.read(h), c.resolveKeyframes(u))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: s, name: r, element: e, motionValue: t } = this;
    if (s[0] === null) {
      const n = t?.get(), i = s[s.length - 1];
      if (n !== void 0)
        s[0] = n;
      else if (e && r) {
        const o = e.readValue(r, i);
        o != null && (s[0] = o);
      }
      s[0] === void 0 && (s[0] = i), t && n === void 0 && t.set(s[0]);
    }
    y(s);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(s = !1) {
    this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, s), l.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (l.delete(this), this.state = "pending");
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
export {
  g as KeyframeResolver,
  S as flushKeyframeResolvers
};
//# sourceMappingURL=KeyframesResolver.js.map
