import { jsx as d } from "react/jsx-runtime";
import { useContext as u, Component as m } from "react";
import { usePresence as f } from "../../../components/AnimatePresence/use-presence.js";
import { LayoutGroupContext as c } from "../../../context/LayoutGroupContext.js";
import { SwitchLayoutGroupContext as l } from "../../../context/SwitchLayoutGroupContext.js";
import { globalProjectionState as h } from "../../../projection/node/state.js";
import { correctBorderRadius as n } from "../../../projection/styles/scale-border-radius.js";
import { correctBoxShadow as R } from "../../../projection/styles/scale-box-shadow.js";
import { addScaleCorrector as g } from "../../../projection/styles/scale-correction.js";
import { frame as y } from "../../../../../../motion-dom/dist/es/frameloop/frame.js";
import { microtask as v } from "../../../../../../motion-dom/dist/es/frameloop/microtask.js";
class T extends m {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: o, layoutGroup: t, switchLayoutGroup: r, layoutId: s } = this.props, { projection: e } = o;
    g(L), e && (t.group && t.group.add(e), r && r.register && s && r.register(e), e.root.didUpdate(), e.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), e.setOptions({
      ...e.options,
      onExitComplete: () => this.safeToRemove()
    })), h.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(o) {
    const { layoutDependency: t, visualElement: r, drag: s, isPresent: e } = this.props, { projection: i } = r;
    return i && (i.isPresent = e, s || o.layoutDependency !== t || t === void 0 || o.isPresent !== e ? i.willUpdate() : this.safeToRemove(), o.isPresent !== e && (e ? i.promote() : i.relegate() || y.postRender(() => {
      const p = i.getStack();
      (!p || !p.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: o } = this.props.visualElement;
    o && (o.root.didUpdate(), v.postRender(() => {
      !o.currentAnimation && o.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: o, layoutGroup: t, switchLayoutGroup: r } = this.props, { projection: s } = o;
    s && (s.scheduleCheckAfterUnmount(), t && t.group && t.group.remove(s), r && r.deregister && r.deregister(s));
  }
  safeToRemove() {
    const { safeToRemove: o } = this.props;
    o && o();
  }
  render() {
    return null;
  }
}
function k(a) {
  const [o, t] = f(), r = u(c);
  return d(T, { ...a, layoutGroup: r, switchLayoutGroup: u(l), isPresent: o, safeToRemove: t });
}
const L = {
  borderRadius: {
    ...n,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: n,
  borderTopRightRadius: n,
  borderBottomLeftRadius: n,
  borderBottomRightRadius: n,
  boxShadow: R
};
export {
  k as MeasureLayout
};
//# sourceMappingURL=MeasureLayout.js.map
