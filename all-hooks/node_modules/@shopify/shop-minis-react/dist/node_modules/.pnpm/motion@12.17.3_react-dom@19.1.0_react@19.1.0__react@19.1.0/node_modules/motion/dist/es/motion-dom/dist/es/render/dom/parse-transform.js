const e = (t) => t * 180 / Math.PI, c = (t) => {
  const a = e(Math.atan2(t[1], t[0]));
  return l(a);
}, f = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (t) => (Math.abs(t[0]) + Math.abs(t[3])) / 2,
  rotate: c,
  rotateZ: c,
  skewX: (t) => e(Math.atan(t[1])),
  skewY: (t) => e(Math.atan(t[2])),
  skew: (t) => (Math.abs(t[1]) + Math.abs(t[2])) / 2
}, l = (t) => (t = t % 360, t < 0 && (t += 360), t), h = c, M = (t) => Math.sqrt(t[0] * t[0] + t[1] * t[1]), i = (t) => Math.sqrt(t[4] * t[4] + t[5] * t[5]), x = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX: M,
  scaleY: i,
  scale: (t) => (M(t) + i(t)) / 2,
  rotateX: (t) => l(e(Math.atan2(t[6], t[5]))),
  rotateY: (t) => l(e(Math.atan2(-t[2], t[0]))),
  rotateZ: h,
  rotate: h,
  skewX: (t) => e(Math.atan(t[4])),
  skewY: (t) => e(Math.atan(t[1])),
  skew: (t) => (Math.abs(t[1]) + Math.abs(t[4])) / 2
};
function m(t) {
  return t.includes("scale") ? 1 : 0;
}
function b(t, a) {
  if (!t || t === "none")
    return m(a);
  const s = t.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let n, r;
  if (s)
    n = x, r = s;
  else {
    const d = t.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    n = f, r = d;
  }
  if (!r)
    return m(a);
  const o = n[a], u = r[1].split(",").map(p);
  return typeof o == "function" ? o(u) : u[o];
}
const X = (t, a) => {
  const { transform: s = "none" } = getComputedStyle(t);
  return b(s, a);
};
function p(t) {
  return parseFloat(t.trim());
}
export {
  m as defaultTransformValue,
  b as parseValueFromTransform,
  X as readTransformValue
};
//# sourceMappingURL=parse-transform.js.map
