import { isCSSVariableToken as d } from "../../animation/utils/is-css-variable.js";
import { color as u } from "../../value/types/color/index.js";
import { complex as h, analyseComplexValue as m } from "../../value/types/complex/index.js";
import { mixColor as a } from "./color.js";
import { mixImmediate as l } from "./immediate.js";
import { mixNumber as b } from "./number.js";
import { invisibleValues as c, mixVisibility as y } from "./visibility.js";
import { pipe as v } from "../../../../../motion-utils/dist/es/pipe.js";
import { warning as g } from "../../../../../motion-utils/dist/es/errors.js";
function V(e, t) {
  return (r) => b(e, t, r);
}
function f(e) {
  return typeof e == "number" ? V : typeof e == "string" ? d(e) ? l : u.test(e) ? a : I : Array.isArray(e) ? p : typeof e == "object" ? u.test(e) ? a : C : l;
}
function p(e, t) {
  const r = [...e], o = r.length, n = e.map((i, s) => f(i)(i, t[s]));
  return (i) => {
    for (let s = 0; s < o; s++)
      r[s] = n[s](i);
    return r;
  };
}
function C(e, t) {
  const r = { ...e, ...t }, o = {};
  for (const n in r)
    e[n] !== void 0 && t[n] !== void 0 && (o[n] = f(e[n])(e[n], t[n]));
  return (n) => {
    for (const i in o)
      r[i] = o[i](n);
    return r;
  };
}
function k(e, t) {
  const r = [], o = { color: 0, var: 0, number: 0 };
  for (let n = 0; n < t.values.length; n++) {
    const i = t.types[n], s = e.indexes[i][o[i]], x = e.values[s] ?? 0;
    r[n] = x, o[i]++;
  }
  return r;
}
const I = (e, t) => {
  const r = h.createTransformer(t), o = m(e), n = m(t);
  return o.indexes.var.length === n.indexes.var.length && o.indexes.color.length === n.indexes.color.length && o.indexes.number.length >= n.indexes.number.length ? c.has(e) && !n.values.length || c.has(t) && !o.values.length ? y(e, t) : v(p(k(o, n), n.values), r) : (g(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), l(e, t));
};
export {
  f as getMixer,
  p as mixArray,
  I as mixComplex,
  C as mixObject
};
//# sourceMappingURL=complex.js.map
