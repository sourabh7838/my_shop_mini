{"version":3,"file":"KeyframesResolver.js","sources":["../../../../../../../../../../../../../node_modules/.pnpm/motion@12.17.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/motion/dist/es/motion-dom/dist/es/animation/keyframes/KeyframesResolver.mjs"],"sourcesContent":["import { fillWildcards } from './utils/fill-wildcards.mjs';\nimport { removeNonTranslationalTransform } from './utils/unit-conversion.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\n\nconst toResolve = new Set();\nlet isScheduled = false;\nlet anyNeedsMeasurement = false;\nlet isForced = false;\nfunction measureAllKeyframes() {\n    if (anyNeedsMeasurement) {\n        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);\n        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));\n        const transformsToRestore = new Map();\n        /**\n         * Write pass\n         * If we're measuring elements we want to remove bounding box-changing transforms.\n         */\n        elementsToMeasure.forEach((element) => {\n            const removedTransforms = removeNonTranslationalTransform(element);\n            if (!removedTransforms.length)\n                return;\n            transformsToRestore.set(element, removedTransforms);\n            element.render();\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());\n        // Write\n        elementsToMeasure.forEach((element) => {\n            element.render();\n            const restore = transformsToRestore.get(element);\n            if (restore) {\n                restore.forEach(([key, value]) => {\n                    element.getValue(key)?.set(value);\n                });\n            }\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureEndState());\n        // Write\n        resolversToMeasure.forEach((resolver) => {\n            if (resolver.suspendedScrollY !== undefined) {\n                window.scrollTo(0, resolver.suspendedScrollY);\n            }\n        });\n    }\n    anyNeedsMeasurement = false;\n    isScheduled = false;\n    toResolve.forEach((resolver) => resolver.complete(isForced));\n    toResolve.clear();\n}\nfunction readAllKeyframes() {\n    toResolve.forEach((resolver) => {\n        resolver.readKeyframes();\n        if (resolver.needsMeasurement) {\n            anyNeedsMeasurement = true;\n        }\n    });\n}\nfunction flushKeyframeResolvers() {\n    isForced = true;\n    readAllKeyframes();\n    measureAllKeyframes();\n    isForced = false;\n}\nclass KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\n        this.state = \"pending\";\n        /**\n         * Track whether this resolver is async. If it is, it'll be added to the\n         * resolver queue and flushed in the next frame. Resolvers that aren't going\n         * to trigger read/write thrashing don't need to be async.\n         */\n        this.isAsync = false;\n        /**\n         * Track whether this resolver needs to perform a measurement\n         * to resolve its keyframes.\n         */\n        this.needsMeasurement = false;\n        this.unresolvedKeyframes = [...unresolvedKeyframes];\n        this.onComplete = onComplete;\n        this.name = name;\n        this.motionValue = motionValue;\n        this.element = element;\n        this.isAsync = isAsync;\n    }\n    scheduleResolve() {\n        this.state = \"scheduled\";\n        if (this.isAsync) {\n            toResolve.add(this);\n            if (!isScheduled) {\n                isScheduled = true;\n                frame.read(readAllKeyframes);\n                frame.resolveKeyframes(measureAllKeyframes);\n            }\n        }\n        else {\n            this.readKeyframes();\n            this.complete();\n        }\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, name, element, motionValue } = this;\n        // If initial keyframe is null we need to read it from the DOM\n        if (unresolvedKeyframes[0] === null) {\n            const currentValue = motionValue?.get();\n            // TODO: This doesn't work if the final keyframe is a wildcard\n            const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n            if (currentValue !== undefined) {\n                unresolvedKeyframes[0] = currentValue;\n            }\n            else if (element && name) {\n                const valueAsRead = element.readValue(name, finalKeyframe);\n                if (valueAsRead !== undefined && valueAsRead !== null) {\n                    unresolvedKeyframes[0] = valueAsRead;\n                }\n            }\n            if (unresolvedKeyframes[0] === undefined) {\n                unresolvedKeyframes[0] = finalKeyframe;\n            }\n            if (motionValue && currentValue === undefined) {\n                motionValue.set(unresolvedKeyframes[0]);\n            }\n        }\n        fillWildcards(unresolvedKeyframes);\n    }\n    setFinalKeyframe() { }\n    measureInitialState() { }\n    renderEndStyles() { }\n    measureEndState() { }\n    complete(isForcedComplete = false) {\n        this.state = \"complete\";\n        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);\n        toResolve.delete(this);\n    }\n    cancel() {\n        if (this.state === \"scheduled\") {\n            toResolve.delete(this);\n            this.state = \"pending\";\n        }\n    }\n    resume() {\n        if (this.state === \"pending\")\n            this.scheduleResolve();\n    }\n}\n\nexport { KeyframeResolver, flushKeyframeResolvers };\n"],"names":["toResolve","isScheduled","anyNeedsMeasurement","isForced","measureAllKeyframes","resolversToMeasure","resolver","elementsToMeasure","transformsToRestore","element","removedTransforms","removeNonTranslationalTransform","restore","key","value","readAllKeyframes","flushKeyframeResolvers","KeyframeResolver","unresolvedKeyframes","onComplete","name","motionValue","isAsync","frame","currentValue","finalKeyframe","valueAsRead","fillWildcards","isForcedComplete"],"mappings":"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","x_google_ignoreList":[0]}