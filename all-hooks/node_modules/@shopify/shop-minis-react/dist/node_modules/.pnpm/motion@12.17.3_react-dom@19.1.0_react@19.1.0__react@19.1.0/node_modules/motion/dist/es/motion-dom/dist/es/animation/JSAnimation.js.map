{"version":3,"file":"JSAnimation.js","sources":["../../../../../../../../../../../../node_modules/.pnpm/motion@12.17.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/motion/dist/es/motion-dom/dist/es/animation/JSAnimation.mjs"],"sourcesContent":["import { time } from '../frameloop/sync-time.mjs';\nimport { activeAnimations } from '../stats/animation-count.mjs';\nimport { mix } from '../utils/mix/index.mjs';\nimport { frameloopDriver } from './drivers/frame.mjs';\nimport { inertia } from './generators/inertia.mjs';\nimport { keyframes } from './generators/keyframes.mjs';\nimport { calcGeneratorDuration } from './generators/utils/calc-duration.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { replaceTransitionType } from './utils/replace-transition-type.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { invariant } from '../../../../motion-utils/dist/es/errors.mjs';\nimport { pipe } from '../../../../motion-utils/dist/es/pipe.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../../../motion-utils/dist/es/time-conversion.mjs';\nimport { clamp } from '../../../../motion-utils/dist/es/clamp.mjs';\n\nconst percentToProgress = (percent) => percent / 100;\nclass JSAnimation extends WithPromise {\n    constructor(options) {\n        super();\n        this.state = \"idle\";\n        this.startTime = null;\n        this.isStopped = false;\n        /**\n         * The current time of the animation.\n         */\n        this.currentTime = 0;\n        /**\n         * The time at which the animation was paused.\n         */\n        this.holdTime = null;\n        /**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */\n        this.playbackSpeed = 1;\n        /**\n         * This method is bound to the instance to fix a pattern where\n         * animation.stop is returned as a reference from a useEffect.\n         */\n        this.stop = () => {\n            const { motionValue } = this.options;\n            if (motionValue && motionValue.updatedAt !== time.now()) {\n                this.tick(time.now());\n            }\n            this.isStopped = true;\n            if (this.state === \"idle\")\n                return;\n            this.teardown();\n            this.options.onStop?.();\n        };\n        activeAnimations.mainThread++;\n        this.options = options;\n        this.initAnimation();\n        this.play();\n        if (options.autoplay === false)\n            this.pause();\n    }\n    initAnimation() {\n        const { options } = this;\n        replaceTransitionType(options);\n        const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = options;\n        let { keyframes: keyframes$1 } = options;\n        const generatorFactory = type || keyframes;\n        if (process.env.NODE_ENV !== \"production\" &&\n            generatorFactory !== keyframes) {\n            invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n        }\n        if (generatorFactory !== keyframes &&\n            typeof keyframes$1[0] !== \"number\") {\n            this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n            keyframes$1 = [0, 100];\n        }\n        const generator = generatorFactory({ ...options, keyframes: keyframes$1 });\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */\n        if (repeatType === \"mirror\") {\n            this.mirroredGenerator = generatorFactory({\n                ...options,\n                keyframes: [...keyframes$1].reverse(),\n                velocity: -velocity,\n            });\n        }\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */\n        if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = calcGeneratorDuration(generator);\n        }\n        const { calculatedDuration } = generator;\n        this.calculatedDuration = calculatedDuration;\n        this.resolvedDuration = calculatedDuration + repeatDelay;\n        this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;\n        this.generator = generator;\n    }\n    updateTime(timestamp) {\n        const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;\n        // Update currentTime\n        if (this.holdTime !== null) {\n            this.currentTime = this.holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime = animationTime;\n        }\n    }\n    tick(timestamp, sample = false) {\n        const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration, } = this;\n        if (this.startTime === null)\n            return generator.next(0);\n        const { delay = 0, keyframes, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe, } = this.options;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp);\n        }\n        else if (this.speed < 0) {\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n        }\n        if (sample) {\n            this.currentTime = timestamp;\n        }\n        else {\n            this.updateTime(timestamp);\n        }\n        // Rebase on delay\n        const timeWithoutDelay = this.currentTime - delay * (this.playbackSpeed >= 0 ? 1 : -1);\n        const isInDelayPhase = this.playbackSpeed >= 0\n            ? timeWithoutDelay < 0\n            : timeWithoutDelay > totalDuration;\n        this.currentTime = Math.max(timeWithoutDelay, 0);\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === \"finished\" && this.holdTime === null) {\n            this.currentTime = totalDuration;\n        }\n        let elapsed = this.currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const isOddIteration = Boolean(currentIteration % 2);\n            if (isOddIteration) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes[0] }\n            : frameGenerator.next(elapsed);\n        if (mixKeyframes) {\n            state.value = mixKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done =\n                this.playbackSpeed >= 0\n                    ? this.currentTime >= totalDuration\n                    : this.currentTime <= 0;\n        }\n        const isAnimationFinished = this.holdTime === null &&\n            (this.state === \"finished\" || (this.state === \"running\" && done));\n        // TODO: The exception for inertia could be cleaner here\n        if (isAnimationFinished && type !== inertia) {\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n        }\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            this.finish();\n        }\n        return state;\n    }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.finished.then(resolve, reject);\n    }\n    get duration() {\n        return millisecondsToSeconds(this.calculatedDuration);\n    }\n    get time() {\n        return millisecondsToSeconds(this.currentTime);\n    }\n    set time(newTime) {\n        newTime = secondsToMilliseconds(newTime);\n        this.currentTime = newTime;\n        if (this.startTime === null ||\n            this.holdTime !== null ||\n            this.playbackSpeed === 0) {\n            this.holdTime = newTime;\n        }\n        else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.playbackSpeed;\n        }\n        this.driver?.start(false);\n    }\n    get speed() {\n        return this.playbackSpeed;\n    }\n    set speed(newSpeed) {\n        this.updateTime(time.now());\n        const hasChanged = this.playbackSpeed !== newSpeed;\n        this.playbackSpeed = newSpeed;\n        if (hasChanged) {\n            this.time = millisecondsToSeconds(this.currentTime);\n        }\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { driver = frameloopDriver, startTime } = this.options;\n        if (!this.driver) {\n            this.driver = driver((timestamp) => this.tick(timestamp));\n        }\n        this.options.onPlay?.();\n        const now = this.driver.now();\n        if (this.state === \"finished\") {\n            this.updateFinished();\n            this.startTime = now;\n        }\n        else if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime;\n        }\n        else if (!this.startTime) {\n            this.startTime = startTime ?? now;\n        }\n        if (this.state === \"finished\" && this.speed < 0) {\n            this.startTime += this.calculatedDuration;\n        }\n        this.holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        this.state = \"running\";\n        this.driver.start();\n    }\n    pause() {\n        this.state = \"paused\";\n        this.updateTime(time.now());\n        this.holdTime = this.currentTime;\n    }\n    complete() {\n        if (this.state !== \"running\") {\n            this.play();\n        }\n        this.state = \"finished\";\n        this.holdTime = null;\n    }\n    finish() {\n        this.notifyFinished();\n        this.teardown();\n        this.state = \"finished\";\n        this.options.onComplete?.();\n    }\n    cancel() {\n        this.holdTime = null;\n        this.startTime = 0;\n        this.tick(0);\n        this.teardown();\n        this.options.onCancel?.();\n    }\n    teardown() {\n        this.state = \"idle\";\n        this.stopDriver();\n        this.startTime = this.holdTime = null;\n        activeAnimations.mainThread--;\n    }\n    stopDriver() {\n        if (!this.driver)\n            return;\n        this.driver.stop();\n        this.driver = undefined;\n    }\n    sample(sampleTime) {\n        this.startTime = 0;\n        return this.tick(sampleTime, true);\n    }\n    attachTimeline(timeline) {\n        if (this.options.allowFlatten) {\n            this.options.type = \"keyframes\";\n            this.options.ease = \"linear\";\n            this.initAnimation();\n        }\n        this.driver?.stop();\n        return timeline.observe(this);\n    }\n}\n// Legacy function support\nfunction animateValue(options) {\n    return new JSAnimation(options);\n}\n\nexport { JSAnimation, animateValue };\n"],"names":["percentToProgress","percent","JSAnimation","WithPromise","options","motionValue","time","replaceTransitionType","type","keyframes","repeat","repeatDelay","repeatType","velocity","keyframes$1","generatorFactory","invariant","pipe","mix","generator","calcGeneratorDuration","calculatedDuration","timestamp","animationTime","sample","totalDuration","mixKeyframes","mirroredGenerator","resolvedDuration","delay","onUpdate","finalKeyframe","timeWithoutDelay","isInDelayPhase","elapsed","frameGenerator","progress","currentIteration","iterationProgress","clamp","state","done","isAnimationFinished","inertia","getFinalKeyframe","resolve","reject","millisecondsToSeconds","newTime","secondsToMilliseconds","newSpeed","hasChanged","driver","frameloopDriver","startTime","now","sampleTime","timeline"],"mappings":"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","x_google_ignoreList":[0]}