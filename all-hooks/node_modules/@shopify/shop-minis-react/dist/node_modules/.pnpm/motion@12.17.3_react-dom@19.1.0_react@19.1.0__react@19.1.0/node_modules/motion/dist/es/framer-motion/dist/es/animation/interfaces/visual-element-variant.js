import { resolveVariant as h } from "../../render/utils/resolve-dynamic-variants.js";
import { animateTarget as g } from "./visual-element-target.js";
function l(r, t, n = {}) {
  const i = h(r, t, n.type === "exit" ? r.presenceContext?.custom : void 0);
  let { transition: a = r.getDefaultTransition() || {} } = i || {};
  n.transitionOverride && (a = n.transitionOverride);
  const s = i ? () => Promise.all(g(r, i, n)) : () => Promise.resolve(), o = r.variantChildren && r.variantChildren.size ? (d = 0) => {
    const { delayChildren: e = 0, staggerChildren: c, staggerDirection: m } = a;
    return C(r, t, e + d, c, m, n);
  } : () => Promise.resolve(), { when: f } = a;
  if (f) {
    const [d, e] = f === "beforeChildren" ? [s, o] : [o, s];
    return d().then(() => e());
  } else
    return Promise.all([s(), o(n.delay)]);
}
function C(r, t, n = 0, i = 0, a = 1, s) {
  const o = [], f = (r.variantChildren.size - 1) * i, d = a === 1 ? (e = 0) => e * i : (e = 0) => f - e * i;
  return Array.from(r.variantChildren).sort(y).forEach((e, c) => {
    e.notify("AnimationStart", t), o.push(l(e, t, {
      ...s,
      delay: n + d(c)
    }).then(() => e.notify("AnimationComplete", t)));
  }), Promise.all(o);
}
function y(r, t) {
  return r.sortNodePosition(t);
}
export {
  l as animateVariant,
  y as sortByTreeOrder
};
//# sourceMappingURL=visual-element-variant.js.map
