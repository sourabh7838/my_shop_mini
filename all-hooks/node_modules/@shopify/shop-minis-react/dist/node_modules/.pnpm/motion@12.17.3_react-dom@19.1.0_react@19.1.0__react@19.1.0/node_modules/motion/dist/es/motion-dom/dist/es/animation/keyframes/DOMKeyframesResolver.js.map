{"version":3,"file":"DOMKeyframesResolver.js","sources":["../../../../../../../../../../../../../node_modules/.pnpm/motion@12.17.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/motion/dist/es/motion-dom/dist/es/animation/keyframes/DOMKeyframesResolver.mjs"],"sourcesContent":["import { positionalKeys } from '../../render/utils/keys-position.mjs';\nimport { findDimensionValueType } from '../../value/types/dimensions.mjs';\nimport { getVariableValue } from '../utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from '../utils/is-css-variable.mjs';\nimport { KeyframeResolver } from './KeyframesResolver.mjs';\nimport { isNone } from './utils/is-none.mjs';\nimport { makeNoneKeyframesAnimatable } from './utils/make-none-animatable.mjs';\nimport { isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this;\n        if (!element || !element.current)\n            return;\n        super.readKeyframes();\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            let keyframe = unresolvedKeyframes[i];\n            if (typeof keyframe === \"string\") {\n                keyframe = keyframe.trim();\n                if (isCSSVariableToken(keyframe)) {\n                    const resolved = getVariableValue(keyframe, element.current);\n                    if (resolved !== undefined) {\n                        unresolvedKeyframes[i] = resolved;\n                    }\n                    if (i === unresolvedKeyframes.length - 1) {\n                        this.finalKeyframe = keyframe;\n                    }\n                }\n            }\n        }\n        /**\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n         * have a far bigger performance impact.\n         */\n        this.resolveNoneKeyframes();\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn't a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return;\n        }\n        const [origin, target] = unresolvedKeyframes;\n        const originType = findDimensionValueType(origin);\n        const targetType = findDimensionValueType(target);\n        /**\n         * Either we don't recognise these value types or we can animate between them.\n         */\n        if (originType === targetType)\n            return;\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\n                const value = unresolvedKeyframes[i];\n                if (typeof value === \"string\") {\n                    unresolvedKeyframes[i] = parseFloat(value);\n                }\n            }\n        }\n        else if (positionalValues[name]) {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */\n            this.needsMeasurement = true;\n        }\n    }\n    resolveNoneKeyframes() {\n        const { unresolvedKeyframes, name } = this;\n        const noneKeyframeIndexes = [];\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (unresolvedKeyframes[i] === null ||\n                isNone(unresolvedKeyframes[i])) {\n                noneKeyframeIndexes.push(i);\n            }\n        }\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n        }\n    }\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this;\n        if (!element || !element.current)\n            return;\n        if (name === \"height\") {\n            this.suspendedScrollY = window.pageYOffset;\n        }\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        unresolvedKeyframes[0] = this.measuredOrigin;\n        // Set final key frame to measure after next render\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n        if (measureKeyframe !== undefined) {\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n        }\n    }\n    measureEndState() {\n        const { element, name, unresolvedKeyframes } = this;\n        if (!element || !element.current)\n            return;\n        const value = element.getValue(name);\n        value && value.jump(this.measuredOrigin, false);\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n            this.finalKeyframe = finalKeyframe;\n        }\n        // If we removed transform values, reapply them before the next render\n        if (this.removedTransforms?.length) {\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n                element\n                    .getValue(unsetTransformName)\n                    .set(unsetTransformValue);\n            });\n        }\n        this.resolveNoneKeyframes();\n    }\n}\n\nexport { DOMKeyframesResolver };\n"],"names":["DOMKeyframesResolver","KeyframeResolver","unresolvedKeyframes","onComplete","name","motionValue","element","i","keyframe","isCSSVariableToken","resolved","getVariableValue","positionalKeys","origin","target","originType","findDimensionValueType","targetType","isNumOrPxType","value","positionalValues","noneKeyframeIndexes","isNone","makeNoneKeyframesAnimatable","measureKeyframe","finalKeyframeIndex","finalKeyframe","unsetTransformName","unsetTransformValue"],"mappings":"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","x_google_ignoreList":[0]}