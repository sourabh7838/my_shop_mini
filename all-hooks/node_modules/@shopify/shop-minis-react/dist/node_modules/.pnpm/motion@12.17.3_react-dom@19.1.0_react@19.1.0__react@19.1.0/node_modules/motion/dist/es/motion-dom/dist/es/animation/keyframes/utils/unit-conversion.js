import { parseValueFromTransform as e } from "../../../render/dom/parse-transform.js";
import { transformPropOrder as n } from "../../../render/utils/keys-transform.js";
import { number as m } from "../../../value/types/numbers/index.js";
import { px as l } from "../../../value/types/numbers/units.js";
const c = (o) => o === m || o === l, i = /* @__PURE__ */ new Set(["x", "y", "z"]), p = n.filter((o) => !i.has(o));
function F(o) {
  const r = [];
  return p.forEach((a) => {
    const s = o.getValue(a);
    s !== void 0 && (r.push([a, s.get()]), s.set(a.startsWith("scale") ? 1 : 0));
  }), r;
}
const t = {
  // Dimensions
  width: ({ x: o }, { paddingLeft: r = "0", paddingRight: a = "0" }) => o.max - o.min - parseFloat(r) - parseFloat(a),
  height: ({ y: o }, { paddingTop: r = "0", paddingBottom: a = "0" }) => o.max - o.min - parseFloat(r) - parseFloat(a),
  top: (o, { top: r }) => parseFloat(r),
  left: (o, { left: r }) => parseFloat(r),
  bottom: ({ y: o }, { top: r }) => parseFloat(r) + (o.max - o.min),
  right: ({ x: o }, { left: r }) => parseFloat(r) + (o.max - o.min),
  // Transform
  x: (o, { transform: r }) => e(r, "x"),
  y: (o, { transform: r }) => e(r, "y")
};
t.translateX = t.x;
t.translateY = t.y;
export {
  c as isNumOrPxType,
  t as positionalValues,
  F as removeNonTranslationalTransform
};
//# sourceMappingURL=unit-conversion.js.map
