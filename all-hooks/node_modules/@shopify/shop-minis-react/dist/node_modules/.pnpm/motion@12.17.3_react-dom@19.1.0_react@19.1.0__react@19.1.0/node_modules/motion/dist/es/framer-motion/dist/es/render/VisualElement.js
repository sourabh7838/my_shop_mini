import { featureDefinitions as d } from "../motion/features/definitions.js";
import { createBox as v } from "../projection/geometry/models.js";
import { initPrefersReducedMotion as g } from "../utils/reduced-motion/index.js";
import { hasReducedMotionListener as M, prefersReducedMotion as S } from "../utils/reduced-motion/state.js";
import { visualElementStore as C } from "./store.js";
import { isControllingVariants as b, isVariantNode as T } from "./utils/is-controlling-variants.js";
import { updateMotionValuesFromProps as P } from "./utils/motion-values.js";
import { resolveVariantFromProps as w } from "./utils/resolve-variants.js";
import { KeyframeResolver as F } from "../../../../motion-dom/dist/es/animation/keyframes/KeyframesResolver.js";
import { time as R } from "../../../../motion-dom/dist/es/frameloop/sync-time.js";
import { frame as f, cancelFrame as c } from "../../../../motion-dom/dist/es/frameloop/frame.js";
import { isMotionValue as h } from "../../../../motion-dom/dist/es/value/utils/is-motion-value.js";
import { warnOnce as B } from "../../../../motion-utils/dist/es/warn-once.js";
import { transformProps as N } from "../../../../motion-dom/dist/es/render/utils/keys-transform.js";
import { motionValue as E } from "../../../../motion-dom/dist/es/value/index.js";
import { isNumericalString as x } from "../../../../motion-utils/dist/es/is-numerical-string.js";
import { isZeroValueString as A } from "../../../../motion-utils/dist/es/is-zero-value-string.js";
import { findValueType as j } from "../../../../motion-dom/dist/es/value/types/utils/find.js";
import { complex as y } from "../../../../motion-dom/dist/es/value/types/complex/index.js";
import { getAnimatableNone as I } from "../../../../motion-dom/dist/es/value/types/utils/animatable-none.js";
import { SubscriptionManager as U } from "../../../../motion-utils/dist/es/subscription-manager.js";
const m = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class ot {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, e, i) {
    return {};
  }
  constructor({ parent: t, props: e, presenceContext: i, reducedMotionConfig: s, blockInitialAnimation: r, visualState: n }, u = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = F, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const o = R.now();
      this.renderScheduledAt < o && (this.renderScheduledAt = o, f.render(this.render, !1, !0));
    };
    const { latestValues: a, renderState: V } = n;
    this.latestValues = a, this.baseTarget = { ...a }, this.initialValues = e.initial ? { ...a } : {}, this.renderState = V, this.parent = t, this.props = e, this.presenceContext = i, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = s, this.options = u, this.blockInitialAnimation = !!r, this.isControllingVariants = b(e), this.isVariantNode = T(e), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: L, ...l } = this.scrapeMotionValuesFromProps(e, {}, this);
    for (const o in l) {
      const p = l[o];
      a[o] !== void 0 && h(p) && p.set(a[o], !1);
    }
  }
  mount(t) {
    this.current = t, C.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((e, i) => this.bindToMotionValue(i, e)), M.current || g(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : S.current, process.env.NODE_ENV !== "production" && B(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount(), c(this.notifyUpdate), c(this.render), this.valueSubscriptions.forEach((t) => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const t in this.events)
      this.events[t].clear();
    for (const t in this.features) {
      const e = this.features[t];
      e && (e.unmount(), e.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(t, e) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const i = N.has(t);
    i && this.onBindTransform && this.onBindTransform();
    const s = e.on("change", (u) => {
      this.latestValues[t] = u, this.props.onUpdate && f.preRender(this.notifyUpdate), i && this.projection && (this.projection.isTransformDirty = !0);
    }), r = e.on("renderRequest", this.scheduleRender);
    let n;
    window.MotionCheckAppearSync && (n = window.MotionCheckAppearSync(this, t, e)), this.valueSubscriptions.set(t, () => {
      s(), r(), n && n(), e.owner && e.stop();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in d) {
      const e = d[t];
      if (!e)
        continue;
      const { isEnabled: i, Feature: s } = e;
      if (!this.features[t] && s && i(this.props) && (this.features[t] = new s(this)), this.features[t]) {
        const r = this.features[t];
        r.isMounted ? r.update() : (r.mount(), r.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : v();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, e) {
    this.latestValues[t] = e;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, e) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = e;
    for (let i = 0; i < m.length; i++) {
      const s = m[i];
      this.propEventSubscriptions[s] && (this.propEventSubscriptions[s](), delete this.propEventSubscriptions[s]);
      const r = "on" + s, n = t[r];
      n && (this.propEventSubscriptions[s] = this.on(s, n));
    }
    this.prevMotionValues = P(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const e = this.getClosestVariantNode();
    if (e)
      return e.variantChildren && e.variantChildren.add(t), () => e.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, e) {
    const i = this.values.get(t);
    e !== i && (i && this.removeValue(t), this.bindToMotionValue(t, e), this.values.set(t, e), this.latestValues[t] = e.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const e = this.valueSubscriptions.get(t);
    e && (e(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, e) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let i = this.values.get(t);
    return i === void 0 && e !== void 0 && (i = E(e === null ? void 0 : e, { owner: this }), this.addValue(t, i)), i;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t, e) {
    let i = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options);
    return i != null && (typeof i == "string" && (x(i) || A(i)) ? i = parseFloat(i) : !j(i) && y.test(e) && (i = I(t, e)), this.setBaseTarget(t, h(i) ? i.get() : i)), h(i) ? i.get() : i;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, e) {
    this.baseTarget[t] = e;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    const { initial: e } = this.props;
    let i;
    if (typeof e == "string" || typeof e == "object") {
      const r = w(this.props, e, this.presenceContext?.custom);
      r && (i = r[t]);
    }
    if (e && i !== void 0)
      return i;
    const s = this.getBaseTargetFromProps(this.props, t);
    return s !== void 0 && !h(s) ? s : this.initialValues[t] !== void 0 && i === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, e) {
    return this.events[t] || (this.events[t] = new U()), this.events[t].add(e);
  }
  notify(t, ...e) {
    this.events[t] && this.events[t].notify(...e);
  }
}
export {
  ot as VisualElement
};
//# sourceMappingURL=VisualElement.js.map
