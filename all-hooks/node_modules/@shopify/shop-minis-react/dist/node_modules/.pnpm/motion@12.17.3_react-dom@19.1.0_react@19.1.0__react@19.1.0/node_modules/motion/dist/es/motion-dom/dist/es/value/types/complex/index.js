import { color as u } from "../color/index.js";
import { colorRegex as N } from "../utils/color-regex.js";
import { floatRegex as d } from "../utils/float-regex.js";
import { sanitize as b } from "../utils/sanitize.js";
function x(t) {
  return isNaN(t) && typeof t == "string" && (t.match(d)?.length || 0) + (t.match(N)?.length || 0) > 0;
}
const p = "number", m = "color", T = "var", O = "var(", a = "${}", R = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function f(t) {
  const r = t.toString(), n = [], c = {
    color: [],
    number: [],
    var: []
  }, s = [];
  let e = 0;
  const l = r.replace(R, (i) => (u.test(i) ? (c.color.push(e), s.push(m), n.push(u.parse(i))) : i.startsWith(O) ? (c.var.push(e), s.push(T), n.push(i)) : (c.number.push(e), s.push(p), n.push(parseFloat(i))), ++e, a)).split(a);
  return { values: n, split: l, indexes: c, types: s };
}
function h(t) {
  return f(t).values;
}
function g(t) {
  const { split: r, types: n } = f(t), c = r.length;
  return (s) => {
    let e = "";
    for (let o = 0; o < c; o++)
      if (e += r[o], s[o] !== void 0) {
        const l = n[o];
        l === p ? e += b(s[o]) : l === m ? e += u.transform(s[o]) : e += s[o];
      }
    return e;
  };
}
const y = (t) => typeof t == "number" ? 0 : u.test(t) ? u.getAnimatableNone(t) : t;
function E(t) {
  const r = h(t);
  return g(t)(r.map(y));
}
const S = {
  test: x,
  parse: h,
  createTransformer: g,
  getAnimatableNone: E
};
export {
  f as analyseComplexValue,
  S as complex
};
//# sourceMappingURL=index.js.map
