{"version":3,"file":"mix-values.js","sources":["../../../../../../../../../../../../../node_modules/.pnpm/motion@12.17.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/motion/dist/es/framer-motion/dist/es/projection/animation/mix-values.mjs"],"sourcesContent":["import { mixNumber } from '../../../../../motion-dom/dist/es/utils/mix/number.mjs';\nimport { percent, px } from '../../../../../motion-dom/dist/es/value/types/numbers/units.mjs';\nimport { progress } from '../../../../../motion-utils/dist/es/progress.mjs';\nimport { circOut } from '../../../../../motion-utils/dist/es/easing/circ.mjs';\nimport { noop } from '../../../../../motion-utils/dist/es/noop.mjs';\n\nconst borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nconst numBorders = borders.length;\nconst asNumber = (value) => typeof value === \"string\" ? parseFloat(value) : value;\nconst isPx = (value) => typeof value === \"number\" || px.test(value);\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n    if (shouldCrossfadeOpacity) {\n        target.opacity = mixNumber(0, lead.opacity ?? 1, easeCrossfadeIn(progress));\n        target.opacityExit = mixNumber(follow.opacity ?? 1, 0, easeCrossfadeOut(progress));\n    }\n    else if (isOnlyMember) {\n        target.opacity = mixNumber(follow.opacity ?? 1, lead.opacity ?? 1, progress);\n    }\n    /**\n     * Mix border radius\n     */\n    for (let i = 0; i < numBorders; i++) {\n        const borderLabel = `border${borders[i]}Radius`;\n        let followRadius = getRadius(follow, borderLabel);\n        let leadRadius = getRadius(lead, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        const canMix = followRadius === 0 ||\n            leadRadius === 0 ||\n            isPx(followRadius) === isPx(leadRadius);\n        if (canMix) {\n            target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\n                target[borderLabel] += \"%\";\n            }\n        }\n        else {\n            target[borderLabel] = leadRadius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (follow.rotate || lead.rotate) {\n        target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress);\n    }\n}\nfunction getRadius(values, radiusName) {\n    return values[radiusName] !== undefined\n        ? values[radiusName]\n        : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nconst easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);\nconst easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop);\nfunction compress(min, max, easing) {\n    return (p) => {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(progress(min, max, p));\n    };\n}\n\nexport { mixValues };\n"],"names":["borders","numBorders","asNumber","value","isPx","px","mixValues","target","follow","lead","progress","shouldCrossfadeOpacity","isOnlyMember","mixNumber","easeCrossfadeIn","easeCrossfadeOut","i","borderLabel","followRadius","getRadius","leadRadius","percent","values","radiusName","compress","circOut","noop","min","max","easing","p"],"mappings":";;;;;AAMA,MAAMA,IAAU,CAAC,WAAW,YAAY,cAAc,aAAa,GAC7DC,IAAaD,EAAQ,QACrBE,IAAW,CAACC,MAAU,OAAOA,KAAU,WAAW,WAAWA,CAAK,IAAIA,GACtEC,IAAO,CAACD,MAAU,OAAOA,KAAU,YAAYE,EAAG,KAAKF,CAAK;AAClE,SAASG,EAAUC,GAAQC,GAAQC,GAAMC,GAAUC,GAAwBC,GAAc;AACrF,EAAID,KACAJ,EAAO,UAAUM,EAAU,GAAGJ,EAAK,WAAW,GAAGK,EAAgBJ,CAAQ,CAAC,GAC1EH,EAAO,cAAcM,EAAUL,EAAO,WAAW,GAAG,GAAGO,EAAiBL,CAAQ,CAAC,KAE5EE,MACLL,EAAO,UAAUM,EAAUL,EAAO,WAAW,GAAGC,EAAK,WAAW,GAAGC,CAAQ;AAK/E,WAASM,IAAI,GAAGA,IAAIf,GAAYe,KAAK;AACjC,UAAMC,IAAc,SAASjB,EAAQgB,CAAC,CAAC;AACvC,QAAIE,IAAeC,EAAUX,GAAQS,CAAW,GAC5CG,IAAaD,EAAUV,GAAMQ,CAAW;AAC5C,QAAIC,MAAiB,UAAaE,MAAe;AAC7C;AACJ,IAAAF,MAAiBA,IAAe,IAChCE,MAAeA,IAAa,IACbF,MAAiB,KAC5BE,MAAe,KACfhB,EAAKc,CAAY,MAAMd,EAAKgB,CAAU,KAEtCb,EAAOU,CAAW,IAAI,KAAK,IAAIJ,EAAUX,EAASgB,CAAY,GAAGhB,EAASkB,CAAU,GAAGV,CAAQ,GAAG,CAAC,IAC/FW,EAAQ,KAAKD,CAAU,KAAKC,EAAQ,KAAKH,CAAY,OACrDX,EAAOU,CAAW,KAAK,QAI3BV,EAAOU,CAAW,IAAIG;AAAA,EAElC;AAII,GAAIZ,EAAO,UAAUC,EAAK,YACtBF,EAAO,SAASM,EAAUL,EAAO,UAAU,GAAGC,EAAK,UAAU,GAAGC,CAAQ;AAEhF;AACA,SAASS,EAAUG,GAAQC,GAAY;AACnC,SAAOD,EAAOC,CAAU,MAAM,SACxBD,EAAOC,CAAU,IACjBD,EAAO;AACjB;AAwBA,MAAMR,IAAgC,gBAAAU,EAAS,GAAG,KAAKC,CAAO,GACxDV,IAAiC,gBAAAS,EAAS,KAAK,MAAME,CAAI;AAC/D,SAASF,EAASG,GAAKC,GAAKC,GAAQ;AAChC,SAAO,CAACC,MAEAA,IAAIH,IACG,IACPG,IAAIF,IACG,IACJC,EAAOnB,EAASiB,GAAKC,GAAKE,CAAC,CAAC;AAE3C;","x_google_ignoreList":[0]}