import { setStyle as p } from "../render/dom/style-set.js";
import { supportsScrollTimeline as f } from "../utils/supports/scroll-timeline.js";
import { getFinalKeyframe as u } from "./keyframes/get-final.js";
import { WithPromise as d } from "./utils/WithPromise.js";
import { startWaapiAnimation as c } from "./waapi/start-waapi-animation.js";
import { applyGeneratorOptions as y } from "./waapi/utils/apply-generator.js";
import { invariant as T } from "../../../../motion-utils/dist/es/errors.js";
import { millisecondsToSeconds as m, secondsToMilliseconds as g } from "../../../../motion-utils/dist/es/time-conversion.js";
import { noop as S } from "../../../../motion-utils/dist/es/noop.js";
class x extends d {
  constructor(i) {
    if (super(), this.finishedTime = null, this.isStopped = !1, !i)
      return;
    const { element: t, name: n, keyframes: s, pseudoElement: e, allowFlatten: r = !1, finalKeyframe: h, onComplete: l } = i;
    this.isPseudoElement = !!e, this.allowFlatten = r, this.options = i, T(typeof i.type != "string", `animateMini doesn't support "type" as a string. Did you mean to import { spring } from "motion"?`);
    const a = y(i);
    this.animation = c(t, n, s, a, e), a.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
      if (this.finishedTime = this.time, !e) {
        const o = u(s, this.options, h, this.speed);
        this.updateMotionValue ? this.updateMotionValue(o) : p(t, n, o), this.animation.cancel();
      }
      l?.(), this.notifyFinished();
    };
  }
  play() {
    this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.finish?.();
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = !0;
    const { state: i } = this;
    i === "idle" || i === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    this.isPseudoElement || this.animation.commitStyles?.();
  }
  get duration() {
    const i = this.animation.effect?.getComputedTiming?.().duration || 0;
    return m(Number(i));
  }
  get time() {
    return m(Number(this.animation.currentTime) || 0);
  }
  set time(i) {
    this.finishedTime = null, this.animation.currentTime = g(i);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(i) {
    i < 0 && (this.finishedTime = null), this.animation.playbackRate = i;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(i) {
    this.animation.startTime = i;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline: i, observe: t }) {
    return this.allowFlatten && this.animation.effect?.updateTiming({ easing: "linear" }), this.animation.onfinish = null, i && f() ? (this.animation.timeline = i, S) : t(this);
  }
}
export {
  x as NativeAnimation
};
//# sourceMappingURL=NativeAnimation.js.map
