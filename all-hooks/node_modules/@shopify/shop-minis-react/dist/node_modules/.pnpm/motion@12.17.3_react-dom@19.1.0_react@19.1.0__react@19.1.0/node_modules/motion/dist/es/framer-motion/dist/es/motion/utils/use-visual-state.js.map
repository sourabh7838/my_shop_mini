{"version":3,"file":"use-visual-state.js","sources":["../../../../../../../../../../../../../node_modules/.pnpm/motion@12.17.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/motion/dist/es/framer-motion/dist/es/motion/utils/use-visual-state.mjs"],"sourcesContent":["import { useContext } from 'react';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { isControllingVariants, isVariantNode } from '../../render/utils/is-controlling-variants.mjs';\nimport { resolveVariantFromProps } from '../../render/utils/resolve-variants.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\n\nfunction makeState({ scrapeMotionValuesFromProps, createRenderState, }, props, context, presenceContext) {\n    const state = {\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n        renderState: createRenderState(),\n    };\n    return state;\n}\nconst makeUseVisualState = (config) => (props, isStatic) => {\n    const context = useContext(MotionContext);\n    const presenceContext = useContext(PresenceContext);\n    const make = () => makeState(config, props, context, presenceContext);\n    return isStatic ? make() : useConstant(make);\n};\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    const values = {};\n    const motionValues = scrapeMotionValues(props, {});\n    for (const key in motionValues) {\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    let { initial, animate } = props;\n    const isControllingVariants$1 = isControllingVariants(props);\n    const isVariantNode$1 = isVariantNode(props);\n    if (context &&\n        isVariantNode$1 &&\n        !isControllingVariants$1 &&\n        props.inherit !== false) {\n        if (initial === undefined)\n            initial = context.initial;\n        if (animate === undefined)\n            animate = context.animate;\n    }\n    let isInitialAnimationBlocked = presenceContext\n        ? presenceContext.initial === false\n        : false;\n    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n    const variantToSet = isInitialAnimationBlocked ? animate : initial;\n    if (variantToSet &&\n        typeof variantToSet !== \"boolean\" &&\n        !isAnimationControls(variantToSet)) {\n        const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n        for (let i = 0; i < list.length; i++) {\n            const resolved = resolveVariantFromProps(props, list[i]);\n            if (resolved) {\n                const { transitionEnd, transition, ...target } = resolved;\n                for (const key in target) {\n                    let valueTarget = target[key];\n                    if (Array.isArray(valueTarget)) {\n                        /**\n                         * Take final keyframe if the initial animation is blocked because\n                         * we want to initialise at the end of that blocked animation.\n                         */\n                        const index = isInitialAnimationBlocked\n                            ? valueTarget.length - 1\n                            : 0;\n                        valueTarget = valueTarget[index];\n                    }\n                    if (valueTarget !== null) {\n                        values[key] = valueTarget;\n                    }\n                }\n                for (const key in transitionEnd) {\n                    values[key] = transitionEnd[key];\n                }\n            }\n        }\n    }\n    return values;\n}\n\nexport { makeUseVisualState };\n"],"names":["makeState","scrapeMotionValuesFromProps","createRenderState","props","context","presenceContext","makeLatestValues","makeUseVisualState","config","isStatic","useContext","MotionContext","PresenceContext","make","useConstant","scrapeMotionValues","values","motionValues","key","resolveMotionValue","initial","animate","isControllingVariants$1","isControllingVariants","isVariantNode$1","isVariantNode","isInitialAnimationBlocked","variantToSet","isAnimationControls","list","i","resolved","resolveVariantFromProps","transitionEnd","transition","target","valueTarget","index"],"mappings":";;;;;;;;AASA,SAASA,EAAU,EAAE,6BAAAC,GAA6B,mBAAAC,EAAoB,GAAEC,GAAOC,GAASC,GAAiB;AAKrG,SAJc;AAAA,IACV,cAAcC,EAAiBH,GAAOC,GAASC,GAAiBJ,CAA2B;AAAA,IAC3F,aAAaC,EAAmB;AAAA,EACnC;AAEL;AACK,MAACK,IAAqB,CAACC,MAAW,CAACL,GAAOM,MAAa;AACxD,QAAML,IAAUM,EAAWC,CAAa,GAClCN,IAAkBK,EAAWE,CAAe,GAC5CC,IAAO,MAAMb,EAAUQ,GAAQL,GAAOC,GAASC,CAAe;AACpE,SAAOI,IAAWI,MAASC,EAAYD,CAAI;AAC/C;AACA,SAASP,EAAiBH,GAAOC,GAASC,GAAiBU,GAAoB;AAC3E,QAAMC,IAAS,CAAE,GACXC,IAAeF,EAAmBZ,GAAO,EAAE;AACjD,aAAWe,KAAOD;AACd,IAAAD,EAAOE,CAAG,IAAIC,EAAmBF,EAAaC,CAAG,CAAC;AAEtD,MAAI,EAAE,SAAAE,GAAS,SAAAC,EAAO,IAAKlB;AAC3B,QAAMmB,IAA0BC,EAAsBpB,CAAK,GACrDqB,IAAkBC,EAActB,CAAK;AAC3C,EAAIC,KACAoB,KACA,CAACF,KACDnB,EAAM,YAAY,OACdiB,MAAY,WACZA,IAAUhB,EAAQ,UAClBiB,MAAY,WACZA,IAAUjB,EAAQ;AAE1B,MAAIsB,IAA4BrB,IAC1BA,EAAgB,YAAY,KAC5B;AACN,EAAAqB,IAA4BA,KAA6BN,MAAY;AACrE,QAAMO,IAAeD,IAA4BL,IAAUD;AAC3D,MAAIO,KACA,OAAOA,KAAiB,aACxB,CAACC,EAAoBD,CAAY,GAAG;AACpC,UAAME,IAAO,MAAM,QAAQF,CAAY,IAAIA,IAAe,CAACA,CAAY;AACvE,aAASG,IAAI,GAAGA,IAAID,EAAK,QAAQC,KAAK;AAClC,YAAMC,IAAWC,EAAwB7B,GAAO0B,EAAKC,CAAC,CAAC;AACvD,UAAIC,GAAU;AACV,cAAM,EAAE,eAAAE,GAAe,YAAAC,GAAY,GAAGC,EAAQ,IAAGJ;AACjD,mBAAWb,KAAOiB,GAAQ;AACtB,cAAIC,IAAcD,EAAOjB,CAAG;AAC5B,cAAI,MAAM,QAAQkB,CAAW,GAAG;AAK5B,kBAAMC,IAAQX,IACRU,EAAY,SAAS,IACrB;AACN,YAAAA,IAAcA,EAAYC,CAAK;AAAA,UACvD;AACoB,UAAID,MAAgB,SAChBpB,EAAOE,CAAG,IAAIkB;AAAA,QAEtC;AACgB,mBAAWlB,KAAOe;AACd,UAAAjB,EAAOE,CAAG,IAAIe,EAAcf,CAAG;AAAA,MAEnD;AAAA,IACA;AAAA,EACA;AACI,SAAOF;AACX;","x_google_ignoreList":[0]}