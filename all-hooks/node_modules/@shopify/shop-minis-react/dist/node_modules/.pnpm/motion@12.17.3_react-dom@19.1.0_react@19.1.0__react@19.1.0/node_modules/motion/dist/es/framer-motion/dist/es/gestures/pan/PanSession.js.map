{"version":3,"file":"PanSession.js","sources":["../../../../../../../../../../../../../node_modules/.pnpm/motion@12.17.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/motion/dist/es/framer-motion/dist/es/gestures/pan/PanSession.mjs"],"sourcesContent":["import { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { distance2D } from '../../utils/distance.mjs';\nimport { frame, cancelFrame, frameData } from '../../../../../motion-dom/dist/es/frameloop/frame.mjs';\nimport { isPrimaryPointer } from '../../../../../motion-dom/dist/es/gestures/utils/is-primary-pointer.mjs';\nimport { pipe } from '../../../../../motion-utils/dist/es/pipe.mjs';\nimport { secondsToMilliseconds, millisecondsToSeconds } from '../../../../../motion-utils/dist/es/time-conversion.mjs';\n\n/**\n * @internal\n */\nclass PanSession {\n    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false, } = {}) {\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        /**\n         * @internal\n         */\n        this.contextWindow = window;\n        this.updatePoint = () => {\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\n            const isPanStarted = this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            const { point } = info;\n            const { timestamp } = frameData;\n            this.history.push({ ...point, timestamp });\n            const { onStart, onMove } = this.handlers;\n            if (!isPanStarted) {\n                onStart && onStart(this.lastMoveEvent, info);\n                this.startEvent = this.lastMoveEvent;\n            }\n            onMove && onMove(this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = (event, info) => {\n            this.lastMoveEvent = event;\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n            // Throttle mouse move event to once per frame\n            frame.update(this.updatePoint, true);\n        };\n        this.handlePointerUp = (event, info) => {\n            this.end();\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\n            if (this.dragSnapToOrigin)\n                resumeAnimation && resumeAnimation();\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const panInfo = getPanInfo(event.type === \"pointercancel\"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint), this.history);\n            if (this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (!isPrimaryPointer(event))\n            return;\n        this.dragSnapToOrigin = dragSnapToOrigin;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        this.contextWindow = contextWindow || window;\n        const info = extractEventInfo(event);\n        const initialInfo = transformPoint(info, this.transformPagePoint);\n        const { point } = initialInfo;\n        const { timestamp } = frameData;\n        this.history = [{ ...point, timestamp }];\n        const { onSessionStart } = handlers;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp));\n    }\n    updateHandlers(handlers) {\n        this.handlers = handlers;\n    }\n    end() {\n        this.removeListeners && this.removeListeners();\n        cancelFrame(this.updatePoint);\n    }\n}\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo({ point }, history) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nexport { PanSession };\n"],"names":["PanSession","event","handlers","transformPagePoint","contextWindow","dragSnapToOrigin","info","getPanInfo","isPanStarted","isDistancePastThreshold","distance2D","point","timestamp","frameData","onStart","onMove","transformPoint","frame","onEnd","onSessionEnd","resumeAnimation","panInfo","isPrimaryPointer","extractEventInfo","initialInfo","onSessionStart","pipe","addPointerEvent","cancelFrame","subtractPoint","a","b","history","lastDevicePoint","startDevicePoint","getVelocity","timeDelta","i","timestampedPoint","lastPoint","secondsToMilliseconds","time","millisecondsToSeconds","currentVelocity"],"mappings":"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","x_google_ignoreList":[0]}