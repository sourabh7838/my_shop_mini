import { mixNumber as s } from "../../../../../motion-dom/dist/es/utils/mix/number.js";
import { px as R, percent as u } from "../../../../../motion-dom/dist/es/value/types/numbers/units.js";
import { progress as h } from "../../../../../motion-utils/dist/es/progress.js";
import { circOut as B } from "../../../../../motion-utils/dist/es/easing/circ.js";
import { noop as L } from "../../../../../motion-utils/dist/es/noop.js";
const a = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], M = a.length, m = (t) => typeof t == "string" ? parseFloat(t) : t, p = (t) => typeof t == "number" || R.test(t);
function V(t, o, n, i, b, x) {
  b ? (t.opacity = s(0, n.opacity ?? 1, C(i)), t.opacityExit = s(o.opacity ?? 1, 0, O(i))) : x && (t.opacity = s(o.opacity ?? 1, n.opacity ?? 1, i));
  for (let f = 0; f < M; f++) {
    const c = `border${a[f]}Radius`;
    let r = d(o, c), e = d(n, c);
    if (r === void 0 && e === void 0)
      continue;
    r || (r = 0), e || (e = 0), r === 0 || e === 0 || p(r) === p(e) ? (t[c] = Math.max(s(m(r), m(e), i), 0), (u.test(e) || u.test(r)) && (t[c] += "%")) : t[c] = e;
  }
  (o.rotate || n.rotate) && (t.rotate = s(o.rotate || 0, n.rotate || 0, i));
}
function d(t, o) {
  return t[o] !== void 0 ? t[o] : t.borderRadius;
}
const C = /* @__PURE__ */ y(0, 0.5, B), O = /* @__PURE__ */ y(0.5, 0.95, L);
function y(t, o, n) {
  return (i) => i < t ? 0 : i > o ? 1 : n(h(t, o, i));
}
export {
  V as mixValues
};
//# sourceMappingURL=mix-values.js.map
