import { useContext as f, useRef as l, useInsertionEffect as M, useEffect as g } from "react";
import { optimizedAppearDataAttribute as x } from "../../animation/optimized-appear/data-id.js";
import { LazyContext as j } from "../../context/LazyContext.js";
import { MotionConfigContext as I } from "../../context/MotionConfigContext.js";
import { MotionContext as h } from "../../context/MotionContext/index.js";
import { PresenceContext as A } from "../../context/PresenceContext.js";
import { SwitchLayoutGroupContext as S } from "../../context/SwitchLayoutGroupContext.js";
import { isRefObject as L } from "../../utils/is-ref-object.js";
import { useIsomorphicLayoutEffect as b } from "../../utils/use-isomorphic-effect.js";
import { microtask as k } from "../../../../../motion-dom/dist/es/frameloop/microtask.js";
function T(o, s, e, r, u) {
  const { visualElement: a } = f(h), m = f(j), n = f(A), p = f(I).reducedMotion, i = l(null);
  r = r || m.renderer, !i.current && r && (i.current = r(o, {
    visualState: s,
    parent: a,
    props: e,
    presenceContext: n,
    blockInitialAnimation: n ? n.initial === !1 : !1,
    reducedMotionConfig: p
  }));
  const t = i.current, w = f(S);
  t && !t.projection && u && (t.type === "html" || t.type === "svg") && H(i.current, e, u, w);
  const C = l(!1);
  M(() => {
    t && C.current && t.update(e, n);
  });
  const c = e[x], d = l(!!c && !window.MotionHandoffIsComplete?.(c) && window.MotionHasOptimisedAnimation?.(c));
  return b(() => {
    t && (C.current = !0, window.MotionIsMounted = !0, t.updateFeatures(), k.render(t.render), d.current && t.animationState && t.animationState.animateChanges());
  }), g(() => {
    t && (!d.current && t.animationState && t.animationState.animateChanges(), d.current && (queueMicrotask(() => {
      window.MotionHandoffMarkAsComplete?.(c);
    }), d.current = !1));
  }), t;
}
function H(o, s, e, r) {
  const { layoutId: u, layout: a, drag: m, dragConstraints: n, layoutScroll: p, layoutRoot: i, layoutCrossfade: t } = s;
  o.projection = new e(o.latestValues, s["data-framer-portal-id"] ? void 0 : y(o.parent)), o.projection.setOptions({
    layoutId: u,
    layout: a,
    alwaysMeasureLayout: !!m || n && L(n),
    visualElement: o,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof a == "string" ? a : "both",
    initialPromotionConfig: r,
    crossfade: t,
    layoutScroll: p,
    layoutRoot: i
  });
}
function y(o) {
  if (o)
    return o.options.allowProjection !== !1 ? o.projection : y(o.parent);
}
export {
  T as useVisualElement
};
//# sourceMappingURL=use-visual-element.js.map
