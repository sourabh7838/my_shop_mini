{"version":3,"file":"index.js","sources":["../../../../../../../../../../../../../../node_modules/.pnpm/motion@12.17.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/motion/dist/es/motion-dom/dist/es/animation/generators/spring/index.mjs"],"sourcesContent":["import { generateLinearEasing } from '../../waapi/utils/linear.mjs';\nimport { calcGeneratorDuration, maxGeneratorDuration } from '../utils/calc-duration.mjs';\nimport { createGeneratorEasing } from '../utils/create-generator-easing.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { springDefaults } from './defaults.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../../../../../motion-utils/dist/es/time-conversion.mjs';\nimport { clamp } from '../../../../../../motion-utils/dist/es/clamp.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: springDefaults.velocity,\n        stiffness: springDefaults.stiffness,\n        damping: springDefaults.damping,\n        mass: springDefaults.mass,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        if (options.visualDuration) {\n            const visualDuration = options.visualDuration;\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\n            const stiffness = root * root;\n            const damping = 2 *\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\n                Math.sqrt(stiffness);\n            springOptions = {\n                ...springOptions,\n                mass: springDefaults.mass,\n                stiffness,\n                damping,\n            };\n        }\n        else {\n            const derived = findSpring(options);\n            springOptions = {\n                ...springOptions,\n                ...derived,\n                mass: springDefaults.mass,\n            };\n            springOptions.isResolvedFromDuration = true;\n        }\n    }\n    return springOptions;\n}\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\n    const options = typeof optionsOrVisualDuration !== \"object\"\n        ? {\n            visualDuration: optionsOrVisualDuration,\n            keyframes: [0, 1],\n            bounce,\n        }\n        : optionsOrVisualDuration;\n    let { restSpeed, restDelta } = options;\n    const origin = options.keyframes[0];\n    const target = options.keyframes[options.keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\n        ...options,\n        velocity: -millisecondsToSeconds(options.velocity || 0),\n    });\n    const initialVelocity = velocity || 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale\n        ? springDefaults.restSpeed.granular\n        : springDefaults.restSpeed.default);\n    restDelta || (restDelta = isGranularScale\n        ? springDefaults.restDelta.granular\n        : springDefaults.restDelta.default);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    const generator = {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = t === 0 ? initialVelocity : 0.0;\n                /**\n                 * We only need to calculate velocity for under-damped springs\n                 * as over- and critically-damped springs can't overshoot, so\n                 * checking only for displacement is enough.\n                 */\n                if (dampingRatio < 1) {\n                    currentVelocity =\n                        t === 0\n                            ? secondsToMilliseconds(initialVelocity)\n                            : calcGeneratorVelocity(resolveSpring, t, current);\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n        toString: () => {\n            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\n            return calculatedDuration + \"ms \" + easing;\n        },\n        toTransition: () => { },\n    };\n    return generator;\n}\nspring.applyToOptions = (options) => {\n    const generatorOptions = createGeneratorEasing(options, 100, spring);\n    options.ease = generatorOptions.ease;\n    options.duration = secondsToMilliseconds(generatorOptions.duration);\n    options.type = \"keyframes\";\n    return options;\n};\n\nexport { spring };\n"],"names":["durationKeys","physicsKeys","isSpringType","options","keys","key","getSpringOptions","springOptions","springDefaults","visualDuration","root","stiffness","damping","clamp","derived","findSpring","spring","optionsOrVisualDuration","bounce","restSpeed","restDelta","origin","target","state","mass","duration","velocity","isResolvedFromDuration","millisecondsToSeconds","initialVelocity","dampingRatio","initialDelta","undampedAngularFreq","isGranularScale","resolveSpring","angularFreq","calcAngularFreq","t","envelope","dampedAngularFreq","freqForT","generator","current","currentVelocity","secondsToMilliseconds","calcGeneratorVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","calculatedDuration","calcGeneratorDuration","maxGeneratorDuration","easing","generateLinearEasing","progress","generatorOptions","createGeneratorEasing"],"mappings":"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","x_google_ignoreList":[0]}