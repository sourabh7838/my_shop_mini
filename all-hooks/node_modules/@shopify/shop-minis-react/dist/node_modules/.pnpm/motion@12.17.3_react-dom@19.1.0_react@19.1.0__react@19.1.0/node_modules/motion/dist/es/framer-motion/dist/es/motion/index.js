import { jsxs as p, jsx as v } from "react/jsx-runtime";
import { forwardRef as E, useContext as f } from "react";
import { LayoutGroupContext as x } from "../context/LayoutGroupContext.js";
import { LazyContext as g } from "../context/LazyContext.js";
import { MotionConfigContext as L } from "../context/MotionConfigContext.js";
import { MotionContext as j } from "../context/MotionContext/index.js";
import { useCreateMotionContext as N } from "../context/MotionContext/create.js";
import { isBrowser as P } from "../utils/is-browser.js";
import { featureDefinitions as w } from "./features/definitions.js";
import { loadFeatures as C } from "./features/load-features.js";
import { motionComponentSymbol as S } from "./utils/symbol.js";
import { useMotionRef as b } from "./utils/use-motion-ref.js";
import { useVisualElement as h } from "./utils/use-visual-element.js";
import { warning as R, invariant as k } from "../../../../motion-utils/dist/es/errors.js";
function Q({ preloadedFeatures: o, createVisualElement: t, useRender: e, useVisualState: n, Component: i }) {
  o && C(o);
  function l(a, M) {
    let m;
    const s = {
      ...f(L),
      ...a,
      layoutId: z(a)
    }, { isStatic: u } = s, r = N(a), c = n(a, u);
    if (!u && P) {
      D(s, o);
      const y = G(s);
      m = y.MeasureLayout, r.visualElement = h(i, c, s, t, y.ProjectionNode);
    }
    return p(j.Provider, { value: r, children: [m && r.visualElement ? v(m, { visualElement: r.visualElement, ...s }) : null, e(i, a, b(c, r.visualElement, M), c, u, r.visualElement)] });
  }
  l.displayName = `motion.${typeof i == "string" ? i : `create(${i.displayName ?? i.name ?? ""})`}`;
  const d = E(l);
  return d[S] = i, d;
}
function z({ layoutId: o }) {
  const t = f(x).id;
  return t && o !== void 0 ? t + "-" + o : o;
}
function D(o, t) {
  const e = f(g).strict;
  if (process.env.NODE_ENV !== "production" && t && e) {
    const n = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    o.ignoreStrict ? R(!1, n) : k(!1, n);
  }
}
function G(o) {
  const { drag: t, layout: e } = w;
  if (!t && !e)
    return {};
  const n = { ...t, ...e };
  return {
    MeasureLayout: t?.isEnabled(o) || e?.isEnabled(o) ? n.MeasureLayout : void 0,
    ProjectionNode: n.ProjectionNode
  };
}
export {
  Q as createRendererMotionComponent
};
//# sourceMappingURL=index.js.map
