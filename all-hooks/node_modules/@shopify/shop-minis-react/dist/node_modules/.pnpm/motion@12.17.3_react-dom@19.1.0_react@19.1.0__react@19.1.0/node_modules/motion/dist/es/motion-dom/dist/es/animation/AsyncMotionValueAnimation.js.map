{"version":3,"file":"AsyncMotionValueAnimation.js","sources":["../../../../../../../../../../../../node_modules/.pnpm/motion@12.17.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/motion/dist/es/motion-dom/dist/es/animation/AsyncMotionValueAnimation.mjs"],"sourcesContent":["import { time } from '../frameloop/sync-time.mjs';\nimport { JSAnimation } from './JSAnimation.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { KeyframeResolver, flushKeyframeResolvers } from './keyframes/KeyframesResolver.mjs';\nimport { NativeAnimationExtended } from './NativeAnimationExtended.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { supportsBrowserAnimation } from './waapi/supports/waapi.mjs';\nimport { MotionGlobalConfig } from '../../../../motion-utils/dist/es/global-config.mjs';\nimport { noop } from '../../../../motion-utils/dist/es/noop.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass AsyncMotionValueAnimation extends WithPromise {\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", keyframes, name, motionValue, element, ...options }) {\n        super();\n        /**\n         * Bound to support return animation.stop pattern\n         */\n        this.stop = () => {\n            if (this._animation) {\n                this._animation.stop();\n                this.stopTimeline?.();\n            }\n            this.keyframeResolver?.cancel();\n        };\n        this.createdAt = time.now();\n        const optionsWithDefaults = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            name,\n            motionValue,\n            element,\n            ...options,\n        };\n        const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;\n        this.keyframeResolver = new KeyframeResolver$1(keyframes, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue, element);\n        this.keyframeResolver?.scheduleResolve();\n    }\n    onKeyframesResolved(keyframes, finalKeyframe, options, sync) {\n        this.keyframeResolver = undefined;\n        const { name, type, velocity, delay, isHandoff, onUpdate } = options;\n        this.resolvedAt = time.now();\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!canAnimate(keyframes, name, type, velocity)) {\n            if (MotionGlobalConfig.instantAnimations || !delay) {\n                onUpdate?.(getFinalKeyframe(keyframes, options, finalKeyframe));\n            }\n            keyframes[0] = keyframes[keyframes.length - 1];\n            options.duration = 0;\n            options.repeat = 0;\n        }\n        /**\n         * Resolve startTime for the animation.\n         *\n         * This method uses the createdAt and resolvedAt to calculate the\n         * animation startTime. *Ideally*, we would use the createdAt time as t=0\n         * as the following frame would then be the first frame of the animation in\n         * progress, which would feel snappier.\n         *\n         * However, if there's a delay (main thread work) between the creation of\n         * the animation and the first commited frame, we prefer to use resolvedAt\n         * to avoid a sudden jump into the animation.\n         */\n        const startTime = sync\n            ? !this.resolvedAt\n                ? this.createdAt\n                : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n                    ? this.resolvedAt\n                    : this.createdAt\n            : undefined;\n        const resolvedOptions = {\n            startTime,\n            finalKeyframe,\n            ...options,\n            keyframes,\n        };\n        /**\n         * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n         * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n         * optimised animation.\n         */\n        const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions)\n            ? new NativeAnimationExtended({\n                ...resolvedOptions,\n                element: resolvedOptions.motionValue.owner.current,\n            })\n            : new JSAnimation(resolvedOptions);\n        animation.finished.then(() => this.notifyFinished()).catch(noop);\n        if (this.pendingTimeline) {\n            this.stopTimeline = animation.attachTimeline(this.pendingTimeline);\n            this.pendingTimeline = undefined;\n        }\n        this._animation = animation;\n    }\n    get finished() {\n        if (!this._animation) {\n            return this._finished;\n        }\n        else {\n            return this.animation.finished;\n        }\n    }\n    then(onResolve, _onReject) {\n        return this.finished.finally(onResolve).then(() => { });\n    }\n    get animation() {\n        if (!this._animation) {\n            this.keyframeResolver?.resume();\n            flushKeyframeResolvers();\n        }\n        return this._animation;\n    }\n    get duration() {\n        return this.animation.duration;\n    }\n    get time() {\n        return this.animation.time;\n    }\n    set time(newTime) {\n        this.animation.time = newTime;\n    }\n    get speed() {\n        return this.animation.speed;\n    }\n    get state() {\n        return this.animation.state;\n    }\n    set speed(newSpeed) {\n        this.animation.speed = newSpeed;\n    }\n    get startTime() {\n        return this.animation.startTime;\n    }\n    attachTimeline(timeline) {\n        if (this._animation) {\n            this.stopTimeline = this.animation.attachTimeline(timeline);\n        }\n        else {\n            this.pendingTimeline = timeline;\n        }\n        return () => this.stop();\n    }\n    play() {\n        this.animation.play();\n    }\n    pause() {\n        this.animation.pause();\n    }\n    complete() {\n        this.animation.complete();\n    }\n    cancel() {\n        if (this._animation) {\n            this.animation.cancel();\n        }\n        this.keyframeResolver?.cancel();\n    }\n}\n\nexport { AsyncMotionValueAnimation };\n"],"names":["MAX_RESOLVE_DELAY","AsyncMotionValueAnimation","WithPromise","autoplay","delay","type","repeat","repeatDelay","repeatType","keyframes","name","motionValue","element","options","time","optionsWithDefaults","KeyframeResolver$1","KeyframeResolver","resolvedKeyframes","finalKeyframe","forced","sync","velocity","isHandoff","onUpdate","canAnimate","MotionGlobalConfig","getFinalKeyframe","resolvedOptions","animation","supportsBrowserAnimation","NativeAnimationExtended","JSAnimation","noop","onResolve","_onReject","flushKeyframeResolvers","newTime","newSpeed","timeline"],"mappings":"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","x_google_ignoreList":[0]}