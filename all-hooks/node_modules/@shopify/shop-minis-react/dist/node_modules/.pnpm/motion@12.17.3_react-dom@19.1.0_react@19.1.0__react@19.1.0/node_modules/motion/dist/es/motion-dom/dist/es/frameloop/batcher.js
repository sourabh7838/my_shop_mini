import { stepsOrder as o } from "./order.js";
import { createRenderStep as b } from "./render-step.js";
import { MotionGlobalConfig as i } from "../../../../motion-utils/dist/es/global-config.js";
const v = 40;
function N(c, l) {
  let r = !1, a = !0;
  const e = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, m = () => r = !0, n = o.reduce((s, t) => (s[t] = b(m), s), {}), { setup: u, read: f, resolveKeyframes: d, preUpdate: g, update: h, preRender: M, render: R, postRender: x } = n, p = () => {
    const s = i.useManualTiming ? e.timestamp : performance.now();
    r = !1, i.useManualTiming || (e.delta = a ? 1e3 / 60 : Math.max(Math.min(s - e.timestamp, v), 1)), e.timestamp = s, e.isProcessing = !0, u.process(e), f.process(e), d.process(e), g.process(e), h.process(e), M.process(e), R.process(e), x.process(e), e.isProcessing = !1, r && l && (a = !1, c(p));
  }, P = () => {
    r = !0, a = !0, e.isProcessing || c(p);
  };
  return { schedule: o.reduce((s, t) => {
    const w = n[t];
    return s[t] = (E, F = !1, T = !1) => (r || P(), w.schedule(E, F, T)), s;
  }, {}), cancel: (s) => {
    for (let t = 0; t < o.length; t++)
      n[o[t]].cancel(s);
  }, state: e, steps: n };
}
export {
  N as createRenderBatcher
};
//# sourceMappingURL=batcher.js.map
