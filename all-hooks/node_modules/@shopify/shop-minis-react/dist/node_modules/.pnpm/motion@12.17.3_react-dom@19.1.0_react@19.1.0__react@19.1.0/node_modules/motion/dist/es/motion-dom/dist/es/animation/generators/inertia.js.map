{"version":3,"file":"inertia.js","sources":["../../../../../../../../../../../../../node_modules/.pnpm/motion@12.17.3_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/motion/dist/es/motion-dom/dist/es/animation/generators/inertia.mjs"],"sourcesContent":["import { spring } from './spring/index.mjs';\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\n\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.value))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [state.value, nearestBoundary(state.value)],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t) => {\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don't want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */\n            let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */\n            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            }\n            else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        },\n    };\n}\n\nexport { inertia };\n"],"names":["inertia","keyframes","velocity","power","timeConstant","bounceDamping","bounceStiffness","modifyTarget","min","max","restDelta","restSpeed","origin","state","isOutOfBounds","v","nearestBoundary","amplitude","ideal","target","calcDelta","t","calcLatest","applyFriction","delta","latest","timeReachedBoundary","spring$1","checkCatchBoundary","spring","calcGeneratorVelocity","hasUpdatedFrame"],"mappings":";;AAGA,SAASA,EAAQ,EAAE,WAAAC,GAAW,UAAAC,IAAW,GAAK,OAAAC,IAAQ,KAAK,cAAAC,IAAe,KAAK,eAAAC,IAAgB,IAAI,iBAAAC,IAAkB,KAAK,cAAAC,GAAc,KAAAC,GAAK,KAAAC,GAAK,WAAAC,IAAY,KAAK,WAAAC,KAAc;AAC7K,QAAMC,IAASX,EAAU,CAAC,GACpBY,IAAQ;AAAA,IACV,MAAM;AAAA,IACN,OAAOD;AAAA,EACV,GACKE,IAAgB,CAACC,MAAOP,MAAQ,UAAaO,IAAIP,KAASC,MAAQ,UAAaM,IAAIN,GACnFO,IAAkB,CAACD,MACjBP,MAAQ,SACDC,IACPA,MAAQ,UAEL,KAAK,IAAID,IAAMO,CAAC,IAAI,KAAK,IAAIN,IAAMM,CAAC,IADhCP,IAC0CC;AAEzD,MAAIQ,IAAYd,IAAQD;AACxB,QAAMgB,IAAQN,IAASK,GACjBE,IAASZ,MAAiB,SAAYW,IAAQX,EAAaW,CAAK;AAKtE,EAAIC,MAAWD,MACXD,IAAYE,IAASP;AACzB,QAAMQ,IAAY,CAACC,MAAM,CAACJ,IAAY,KAAK,IAAI,CAACI,IAAIjB,CAAY,GAC1DkB,IAAa,CAACD,MAAMF,IAASC,EAAUC,CAAC,GACxCE,IAAgB,CAACF,MAAM;AACzB,UAAMG,IAAQJ,EAAUC,CAAC,GACnBI,IAASH,EAAWD,CAAC;AAC3B,IAAAR,EAAM,OAAO,KAAK,IAAIW,CAAK,KAAKd,GAChCG,EAAM,QAAQA,EAAM,OAAOM,IAASM;AAAA,EACvC;AAOD,MAAIC,GACAC;AACJ,QAAMC,IAAqB,CAACP,MAAM;AAC9B,IAAKP,EAAcD,EAAM,KAAK,MAE9Ba,IAAsBL,GACtBM,IAAWE,EAAO;AAAA,MACd,WAAW,CAAChB,EAAM,OAAOG,EAAgBH,EAAM,KAAK,CAAC;AAAA,MACrD,UAAUiB,EAAsBR,GAAYD,GAAGR,EAAM,KAAK;AAAA;AAAA,MAC1D,SAASR;AAAA,MACT,WAAWC;AAAA,MACX,WAAAI;AAAA,MACA,WAAAC;AAAA,IACZ,CAAS;AAAA,EACJ;AACD,SAAAiB,EAAmB,CAAC,GACb;AAAA,IACH,oBAAoB;AAAA,IACpB,MAAM,CAACP,MAAM;AAOT,UAAIU,IAAkB;AAUtB,aATI,CAACJ,KAAYD,MAAwB,WACrCK,IAAkB,IAClBR,EAAcF,CAAC,GACfO,EAAmBP,CAAC,IAMpBK,MAAwB,UAAaL,KAAKK,IACnCC,EAAS,KAAKN,IAAIK,CAAmB,KAG5C,CAACK,KAAmBR,EAAcF,CAAC,GAC5BR;AAAA,IAEd;AAAA,EACJ;AACL;","x_google_ignoreList":[0]}