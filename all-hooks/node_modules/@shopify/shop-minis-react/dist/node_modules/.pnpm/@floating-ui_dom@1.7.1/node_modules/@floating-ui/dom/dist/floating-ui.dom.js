import { offset as ot, shift as st, flip as rt, size as ct, hide as lt, limitShift as ft, computePosition as ut, arrow as ht } from "../../../../../@floating-ui_core@1.7.1/node_modules/@floating-ui/core/dist/floating-ui.core.js";
import { createCoords as m, round as A, max as E, min as V, rectToClientRect as J, floor as D } from "../../../../../@floating-ui_utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.js";
import { isElement as v, getDocumentElement as O, getOverflowAncestors as $, getComputedStyle as R, isHTMLElement as b, getWindow as L, isTopLayer as S, getParentNode as W, isLastTraversableNode as H, isTableElement as at, isContainingBlock as Q, getContainingBlock as dt, getNodeName as M, isOverflowElement as _, getNodeScroll as N, getFrameElement as K, isWebKit as Y } from "../../../../../@floating-ui_utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.js";
function Z(t) {
  const e = R(t);
  let i = parseFloat(e.width) || 0, n = parseFloat(e.height) || 0;
  const o = b(t), r = o ? t.offsetWidth : i, s = o ? t.offsetHeight : n, c = A(i) !== r || A(n) !== s;
  return c && (i = r, n = s), {
    width: i,
    height: n,
    $: c
  };
}
function q(t) {
  return v(t) ? t : t.contextElement;
}
function F(t) {
  const e = q(t);
  if (!b(e))
    return m(1);
  const i = e.getBoundingClientRect(), {
    width: n,
    height: o,
    $: r
  } = Z(e);
  let s = (r ? A(i.width) : i.width) / n, c = (r ? A(i.height) : i.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: s,
    y: c
  };
}
const gt = /* @__PURE__ */ m(0);
function X(t) {
  const e = L(t);
  return !Y() || !e.visualViewport ? gt : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function pt(t, e, i) {
  return e === void 0 && (e = !1), !i || e && i !== L(t) ? !1 : e;
}
function T(t, e, i, n) {
  e === void 0 && (e = !1), i === void 0 && (i = !1);
  const o = t.getBoundingClientRect(), r = q(t);
  let s = m(1);
  e && (n ? v(n) && (s = F(n)) : s = F(t));
  const c = pt(r, i, n) ? X(r) : m(0);
  let l = (o.left + c.x) / s.x, f = (o.top + c.y) / s.y, u = o.width / s.x, h = o.height / s.y;
  if (r) {
    const p = L(r), a = n && v(n) ? L(n) : n;
    let y = p, g = K(y);
    for (; g && n && a !== y; ) {
      const w = F(g), d = g.getBoundingClientRect(), x = R(g), C = d.left + (g.clientLeft + parseFloat(x.paddingLeft)) * w.x, B = d.top + (g.clientTop + parseFloat(x.paddingTop)) * w.y;
      l *= w.x, f *= w.y, u *= w.x, h *= w.y, l += C, f += B, y = L(g), g = K(y);
    }
  }
  return J({
    width: u,
    height: h,
    x: l,
    y: f
  });
}
function k(t, e) {
  const i = N(t).scrollLeft;
  return e ? e.left + i : T(O(t)).left + i;
}
function tt(t, e, i) {
  i === void 0 && (i = !1);
  const n = t.getBoundingClientRect(), o = n.left + e.scrollLeft - (i ? 0 : (
    // RTL <body> scrollbar.
    k(t, n)
  )), r = n.top + e.scrollTop;
  return {
    x: o,
    y: r
  };
}
function wt(t) {
  let {
    elements: e,
    rect: i,
    offsetParent: n,
    strategy: o
  } = t;
  const r = o === "fixed", s = O(n), c = e ? S(e.floating) : !1;
  if (n === s || c && r)
    return i;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, f = m(1);
  const u = m(0), h = b(n);
  if ((h || !h && !r) && ((M(n) !== "body" || _(s)) && (l = N(n)), b(n))) {
    const a = T(n);
    f = F(n), u.x = a.x + n.clientLeft, u.y = a.y + n.clientTop;
  }
  const p = s && !h && !r ? tt(s, l, !0) : m(0);
  return {
    width: i.width * f.x,
    height: i.height * f.y,
    x: i.x * f.x - l.scrollLeft * f.x + u.x + p.x,
    y: i.y * f.y - l.scrollTop * f.y + u.y + p.y
  };
}
function mt(t) {
  return Array.from(t.getClientRects());
}
function yt(t) {
  const e = O(t), i = N(t), n = t.ownerDocument.body, o = E(e.scrollWidth, e.clientWidth, n.scrollWidth, n.clientWidth), r = E(e.scrollHeight, e.clientHeight, n.scrollHeight, n.clientHeight);
  let s = -i.scrollLeft + k(t);
  const c = -i.scrollTop;
  return R(n).direction === "rtl" && (s += E(e.clientWidth, n.clientWidth) - o), {
    width: o,
    height: r,
    x: s,
    y: c
  };
}
function xt(t, e) {
  const i = L(t), n = O(t), o = i.visualViewport;
  let r = n.clientWidth, s = n.clientHeight, c = 0, l = 0;
  if (o) {
    r = o.width, s = o.height;
    const f = Y();
    (!f || f && e === "fixed") && (c = o.offsetLeft, l = o.offsetTop);
  }
  return {
    width: r,
    height: s,
    x: c,
    y: l
  };
}
function vt(t, e) {
  const i = T(t, !0, e === "fixed"), n = i.top + t.clientTop, o = i.left + t.clientLeft, r = b(t) ? F(t) : m(1), s = t.clientWidth * r.x, c = t.clientHeight * r.y, l = o * r.x, f = n * r.y;
  return {
    width: s,
    height: c,
    x: l,
    y: f
  };
}
function j(t, e, i) {
  let n;
  if (e === "viewport")
    n = xt(t, i);
  else if (e === "document")
    n = yt(O(t));
  else if (v(e))
    n = vt(e, i);
  else {
    const o = X(t);
    n = {
      x: e.x - o.x,
      y: e.y - o.y,
      width: e.width,
      height: e.height
    };
  }
  return J(n);
}
function et(t, e) {
  const i = W(t);
  return i === e || !v(i) || H(i) ? !1 : R(i).position === "fixed" || et(i, e);
}
function Rt(t, e) {
  const i = e.get(t);
  if (i)
    return i;
  let n = $(t, [], !1).filter((c) => v(c) && M(c) !== "body"), o = null;
  const r = R(t).position === "fixed";
  let s = r ? W(t) : t;
  for (; v(s) && !H(s); ) {
    const c = R(s), l = Q(s);
    !l && c.position === "fixed" && (o = null), (r ? !l && !o : !l && c.position === "static" && !!o && ["absolute", "fixed"].includes(o.position) || _(s) && !l && et(t, s)) ? n = n.filter((u) => u !== s) : o = c, s = W(s);
  }
  return e.set(t, n), n;
}
function Ot(t) {
  let {
    element: e,
    boundary: i,
    rootBoundary: n,
    strategy: o
  } = t;
  const s = [...i === "clippingAncestors" ? S(e) ? [] : Rt(e, this._c) : [].concat(i), n], c = s[0], l = s.reduce((f, u) => {
    const h = j(e, u, o);
    return f.top = E(h.top, f.top), f.right = V(h.right, f.right), f.bottom = V(h.bottom, f.bottom), f.left = E(h.left, f.left), f;
  }, j(e, c, o));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function bt(t) {
  const {
    width: e,
    height: i
  } = Z(t);
  return {
    width: e,
    height: i
  };
}
function Ct(t, e, i) {
  const n = b(e), o = O(e), r = i === "fixed", s = T(t, !0, r, e);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = m(0);
  function f() {
    l.x = k(o);
  }
  if (n || !n && !r)
    if ((M(e) !== "body" || _(o)) && (c = N(e)), n) {
      const a = T(e, !0, r, e);
      l.x = a.x + e.clientLeft, l.y = a.y + e.clientTop;
    } else o && f();
  r && !n && o && f();
  const u = o && !n && !r ? tt(o, c) : m(0), h = s.left + c.scrollLeft - l.x - u.x, p = s.top + c.scrollTop - l.y - u.y;
  return {
    x: h,
    y: p,
    width: s.width,
    height: s.height
  };
}
function I(t) {
  return R(t).position === "static";
}
function G(t, e) {
  if (!b(t) || R(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let i = t.offsetParent;
  return O(t) === i && (i = i.ownerDocument.body), i;
}
function it(t, e) {
  const i = L(t);
  if (S(t))
    return i;
  if (!b(t)) {
    let o = W(t);
    for (; o && !H(o); ) {
      if (v(o) && !I(o))
        return o;
      o = W(o);
    }
    return i;
  }
  let n = G(t, e);
  for (; n && at(n) && I(n); )
    n = G(n, e);
  return n && H(n) && I(n) && !Q(n) ? i : n || dt(t) || i;
}
const Lt = async function(t) {
  const e = this.getOffsetParent || it, i = this.getDimensions, n = await i(t.floating);
  return {
    reference: Ct(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: n.width,
      height: n.height
    }
  };
};
function Tt(t) {
  return R(t).direction === "rtl";
}
const Et = {
  convertOffsetParentRelativeRectToViewportRelativeRect: wt,
  getDocumentElement: O,
  getClippingRect: Ot,
  getOffsetParent: it,
  getElementRects: Lt,
  getClientRects: mt,
  getDimensions: bt,
  getScale: F,
  isElement: v,
  isRTL: Tt
};
function nt(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function Ft(t, e) {
  let i = null, n;
  const o = O(t);
  function r() {
    var c;
    clearTimeout(n), (c = i) == null || c.disconnect(), i = null;
  }
  function s(c, l) {
    c === void 0 && (c = !1), l === void 0 && (l = 1), r();
    const f = t.getBoundingClientRect(), {
      left: u,
      top: h,
      width: p,
      height: a
    } = f;
    if (c || e(), !p || !a)
      return;
    const y = D(h), g = D(o.clientWidth - (u + p)), w = D(o.clientHeight - (h + a)), d = D(u), C = {
      rootMargin: -y + "px " + -g + "px " + -w + "px " + -d + "px",
      threshold: E(0, V(1, l)) || 1
    };
    let B = !0;
    function P(U) {
      const z = U[0].intersectionRatio;
      if (z !== l) {
        if (!B)
          return s();
        z ? s(!1, z) : n = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      z === 1 && !nt(f, t.getBoundingClientRect()) && s(), B = !1;
    }
    try {
      i = new IntersectionObserver(P, {
        ...C,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      i = new IntersectionObserver(P, C);
    }
    i.observe(t);
  }
  return s(!0), r;
}
function Dt(t, e, i, n) {
  n === void 0 && (n = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: r = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = n, f = q(t), u = o || r ? [...f ? $(f) : [], ...$(e)] : [];
  u.forEach((d) => {
    o && d.addEventListener("scroll", i, {
      passive: !0
    }), r && d.addEventListener("resize", i);
  });
  const h = f && c ? Ft(f, i) : null;
  let p = -1, a = null;
  s && (a = new ResizeObserver((d) => {
    let [x] = d;
    x && x.target === f && a && (a.unobserve(e), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var C;
      (C = a) == null || C.observe(e);
    })), i();
  }), f && !l && a.observe(f), a.observe(e));
  let y, g = l ? T(t) : null;
  l && w();
  function w() {
    const d = T(t);
    g && !nt(g, d) && i(), g = d, y = requestAnimationFrame(w);
  }
  return i(), () => {
    var d;
    u.forEach((x) => {
      o && x.removeEventListener("scroll", i), r && x.removeEventListener("resize", i);
    }), h?.(), (d = a) == null || d.disconnect(), a = null, l && cancelAnimationFrame(y);
  };
}
const At = ot, Ht = st, Nt = rt, It = ct, Vt = lt, $t = ht, St = ft, Mt = (t, e, i) => {
  const n = /* @__PURE__ */ new Map(), o = {
    platform: Et,
    ...i
  }, r = {
    ...o.platform,
    _c: n
  };
  return ut(t, e, {
    ...o,
    platform: r
  });
};
export {
  $t as arrow,
  Dt as autoUpdate,
  Mt as computePosition,
  Nt as flip,
  $ as getOverflowAncestors,
  Vt as hide,
  St as limitShift,
  At as offset,
  Et as platform,
  Ht as shift,
  It as size
};
//# sourceMappingURL=floating-ui.dom.js.map
