import { Trigger as me, Close as pe, Title as we, Description as he, Root as ge, Portal as ve, Overlay as ye, Content as be } from "../../../../@radix-ui_react-dialog@1.1.14_@types_react-dom@19.1.6_@types_react@19.1.6__@types_react@19.1._sjczexpvrqz6fttoobpwnns2oa/node_modules/@radix-ui/react-dialog/dist/index.js";
import * as Se from "react";
import r, { useLayoutEffect as Te, useEffect as Re, useMemo as Ee } from "react";
function De(t) {
  if (typeof document > "u") return;
  let n = document.head || document.getElementsByTagName("head")[0], e = document.createElement("style");
  e.type = "text/css", n.appendChild(e), e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
const Wt = r.createContext({
  drawerRef: {
    current: null
  },
  overlayRef: {
    current: null
  },
  onPress: () => {
  },
  onRelease: () => {
  },
  onDrag: () => {
  },
  onNestedDrag: () => {
  },
  onNestedOpenChange: () => {
  },
  onNestedRelease: () => {
  },
  openProp: void 0,
  dismissible: !1,
  isOpen: !1,
  isDragging: !1,
  keyboardIsOpen: {
    current: !1
  },
  snapPointsOffset: null,
  snapPoints: null,
  handleOnly: !1,
  modal: !1,
  shouldFade: !1,
  activeSnapPoint: null,
  onOpenChange: () => {
  },
  setActiveSnapPoint: () => {
  },
  closeDrawer: () => {
  },
  direction: "bottom",
  shouldAnimate: {
    current: !0
  },
  shouldScaleBackground: !1,
  setBackgroundColorOnScale: !0,
  noBodyStyles: !1,
  container: null,
  autoFocus: !1
}), ut = () => {
  const t = r.useContext(Wt);
  if (!t)
    throw new Error("useDrawerContext must be used within a Drawer.Root");
  return t;
};
De(`[data-vaul-drawer]{touch-action:none;will-change:transform;transition:transform .5s cubic-bezier(.32, .72, 0, 1);animation-duration:.5s;animation-timing-function:cubic-bezier(0.32,0.72,0,1)}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=open]{animation-name:slideFromBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=closed]{animation-name:slideToBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=open]{animation-name:slideFromTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=closed]{animation-name:slideToTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=open]{animation-name:slideFromLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=closed]{animation-name:slideToLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=open]{animation-name:slideFromRight}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=closed]{animation-name:slideToRight}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--initial-transform,100%),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,calc(var(--initial-transform,100%) * -1),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(calc(var(--initial-transform,100%) * -1),0,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--initial-transform,100%),0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,var(--snap-point-height,0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height,0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(var(--snap-point-height,0),0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height,0),0,0)}[data-vaul-overlay][data-vaul-snap-points=false]{animation-duration:.5s;animation-timing-function:cubic-bezier(0.32,0.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=false][data-state=open]{animation-name:fadeIn}[data-vaul-overlay][data-state=closed]{animation-name:fadeOut}[data-vaul-animate=false]{animation:none!important}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:0;transition:opacity .5s cubic-bezier(.32, .72, 0, 1)}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:1}[data-vaul-drawer]:not([data-vaul-custom-container=true])::after{content:'';position:absolute;background:inherit;background-color:inherit}[data-vaul-drawer][data-vaul-drawer-direction=top]::after{top:initial;bottom:100%;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=bottom]::after{top:100%;bottom:initial;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=left]::after{left:initial;right:100%;top:0;bottom:0;width:200%}[data-vaul-drawer][data-vaul-drawer-direction=right]::after{left:100%;right:initial;top:0;bottom:0;width:200%}[data-vaul-overlay][data-vaul-snap-points=true]:not([data-vaul-snap-points-overlay=true]):not(
[data-state=closed]
){opacity:0}[data-vaul-overlay][data-vaul-snap-points-overlay=true]{opacity:1}[data-vaul-handle]{display:block;position:relative;opacity:.7;background:#e2e2e4;margin-left:auto;margin-right:auto;height:5px;width:32px;border-radius:1rem;touch-action:pan-y}[data-vaul-handle]:active,[data-vaul-handle]:hover{opacity:1}[data-vaul-handle-hitarea]{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:max(100%,2.75rem);height:max(100%,2.75rem);touch-action:inherit}@media (hover:hover) and (pointer:fine){[data-vaul-drawer]{user-select:none}}@media (pointer:fine){[data-vaul-handle-hitarea]:{width:100%;height:100%}}@keyframes fadeIn{from{opacity:0}to{opacity:1}}@keyframes fadeOut{to{opacity:0}}@keyframes slideFromBottom{from{transform:translate3d(0,var(--initial-transform,100%),0)}to{transform:translate3d(0,0,0)}}@keyframes slideToBottom{to{transform:translate3d(0,var(--initial-transform,100%),0)}}@keyframes slideFromTop{from{transform:translate3d(0,calc(var(--initial-transform,100%) * -1),0)}to{transform:translate3d(0,0,0)}}@keyframes slideToTop{to{transform:translate3d(0,calc(var(--initial-transform,100%) * -1),0)}}@keyframes slideFromLeft{from{transform:translate3d(calc(var(--initial-transform,100%) * -1),0,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToLeft{to{transform:translate3d(calc(var(--initial-transform,100%) * -1),0,0)}}@keyframes slideFromRight{from{transform:translate3d(var(--initial-transform,100%),0,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToRight{to{transform:translate3d(var(--initial-transform,100%),0,0)}}`);
function Oe() {
  const t = navigator.userAgent;
  return typeof window < "u" && (/Firefox/.test(t) && /Mobile/.test(t) || // Android Firefox
  /FxiOS/.test(t));
}
function xe() {
  return xt(/^Mac/);
}
function Ce() {
  return xt(/^iPhone/);
}
function kt() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function $e() {
  return xt(/^iPad/) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  xe() && navigator.maxTouchPoints > 1;
}
function zt() {
  return Ce() || $e();
}
function xt(t) {
  return typeof window < "u" && window.navigator != null ? t.test(window.navigator.platform) : void 0;
}
const Ae = 24, Me = typeof window < "u" ? Te : Re;
function Bt(...t) {
  return (...n) => {
    for (let e of t)
      typeof e == "function" && e(...n);
  };
}
const St = typeof document < "u" && window.visualViewport;
function Ut(t) {
  let n = window.getComputedStyle(t);
  return /(auto|scroll)/.test(n.overflow + n.overflowX + n.overflowY);
}
function Vt(t) {
  for (Ut(t) && (t = t.parentElement); t && !Ut(t); )
    t = t.parentElement;
  return t || document.scrollingElement || document.documentElement;
}
const Pe = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
let mt = 0, Tt;
function Ie(t = {}) {
  let { isDisabled: n } = t;
  Me(() => {
    if (!n)
      return mt++, mt === 1 && zt() && (Tt = _e()), () => {
        mt--, mt === 0 && Tt?.();
      };
  }, [
    n
  ]);
}
function _e() {
  let t, n = 0, e = (f) => {
    t = Vt(f.target), !(t === document.documentElement && t === document.body) && (n = f.changedTouches[0].pageY);
  }, o = (f) => {
    if (!t || t === document.documentElement || t === document.body) {
      f.preventDefault();
      return;
    }
    let m = f.changedTouches[0].pageY, B = t.scrollTop, L = t.scrollHeight - t.clientHeight;
    L !== 0 && ((B <= 0 && m > n || B >= L && m < n) && f.preventDefault(), n = m);
  }, i = (f) => {
    let m = f.target;
    Dt(m) && m !== document.activeElement && (f.preventDefault(), m.style.transform = "translateY(-2000px)", m.focus(), requestAnimationFrame(() => {
      m.style.transform = "";
    }));
  }, a = (f) => {
    let m = f.target;
    Dt(m) && (m.style.transform = "translateY(-2000px)", requestAnimationFrame(() => {
      m.style.transform = "", St && (St.height < window.innerHeight ? requestAnimationFrame(() => {
        Ft(m);
      }) : St.addEventListener("resize", () => Ft(m), {
        once: !0
      }));
    }));
  }, v = () => {
    window.scrollTo(0, 0);
  }, w = window.pageXOffset, T = window.pageYOffset, E = Bt(He(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`));
  window.scrollTo(0, 0);
  let h = Bt(lt(document, "touchstart", e, {
    passive: !1,
    capture: !0
  }), lt(document, "touchmove", o, {
    passive: !1,
    capture: !0
  }), lt(document, "touchend", i, {
    passive: !1,
    capture: !0
  }), lt(document, "focus", a, !0), lt(window, "scroll", v));
  return () => {
    E(), h(), window.scrollTo(w, T);
  };
}
function He(t, n, e) {
  let o = t.style[n];
  return t.style[n] = e, () => {
    t.style[n] = o;
  };
}
function lt(t, n, e, o) {
  return t.addEventListener(n, e, o), () => {
    t.removeEventListener(n, e, o);
  };
}
function Ft(t) {
  let n = document.scrollingElement || document.documentElement;
  for (; t && t !== n; ) {
    let e = Vt(t);
    if (e !== document.documentElement && e !== document.body && e !== t) {
      let o = e.getBoundingClientRect().top, i = t.getBoundingClientRect().top, a = t.getBoundingClientRect().bottom;
      const v = e.getBoundingClientRect().bottom + Ae;
      a > v && (e.scrollTop += i - o);
    }
    t = e.parentElement;
  }
}
function Dt(t) {
  return t instanceof HTMLInputElement && !Pe.has(t.type) || t instanceof HTMLTextAreaElement || t instanceof HTMLElement && t.isContentEditable;
}
function Ne(t, n) {
  typeof t == "function" ? t(n) : t != null && (t.current = n);
}
function Le(...t) {
  return (n) => t.forEach((e) => Ne(e, n));
}
function Yt(...t) {
  return Se.useCallback(Le(...t), t);
}
const jt = /* @__PURE__ */ new WeakMap();
function $(t, n, e = !1) {
  if (!t || !(t instanceof HTMLElement)) return;
  let o = {};
  Object.entries(n).forEach(([i, a]) => {
    if (i.startsWith("--")) {
      t.style.setProperty(i, a);
      return;
    }
    o[i] = t.style[i], t.style[i] = a;
  }), !e && jt.set(t, o);
}
function ke(t, n) {
  if (!t || !(t instanceof HTMLElement)) return;
  let e = jt.get(t);
  e && (t.style[n] = e[n]);
}
const C = (t) => {
  switch (t) {
    case "top":
    case "bottom":
      return !0;
    case "left":
    case "right":
      return !1;
    default:
      return t;
  }
};
function pt(t, n) {
  if (!t)
    return null;
  const e = window.getComputedStyle(t), o = (
    // @ts-ignore
    e.transform || e.webkitTransform || e.mozTransform
  );
  let i = o.match(/^matrix3d\((.+)\)$/);
  return i ? parseFloat(i[1].split(", ")[C(n) ? 13 : 12]) : (i = o.match(/^matrix\((.+)\)$/), i ? parseFloat(i[1].split(", ")[C(n) ? 5 : 4]) : null);
}
function Be(t) {
  return 8 * (Math.log(t + 1) - 2);
}
function Rt(t, n) {
  if (!t) return () => {
  };
  const e = t.style.cssText;
  return Object.assign(t.style, n), () => {
    t.style.cssText = e;
  };
}
function Ue(...t) {
  return (...n) => {
    for (const e of t)
      typeof e == "function" && e(...n);
  };
}
const O = {
  DURATION: 0.5,
  EASE: [
    0.32,
    0.72,
    0,
    1
  ]
}, qt = 0.4, Fe = 0.25, We = 100, Xt = 8, wt = 16, Ot = 26, Et = "vaul-dragging";
function Kt(t) {
  const n = r.useRef(t);
  return r.useEffect(() => {
    n.current = t;
  }), r.useMemo(() => (...e) => n.current == null ? void 0 : n.current.call(n, ...e), []);
}
function ze({ defaultProp: t, onChange: n }) {
  const e = r.useState(t), [o] = e, i = r.useRef(o), a = Kt(n);
  return r.useEffect(() => {
    i.current !== o && (a(o), i.current = o);
  }, [
    o,
    i,
    a
  ]), e;
}
function Gt({ prop: t, defaultProp: n, onChange: e = () => {
} }) {
  const [o, i] = ze({
    defaultProp: n,
    onChange: e
  }), a = t !== void 0, v = a ? t : o, w = Kt(e), T = r.useCallback((E) => {
    if (a) {
      const f = typeof E == "function" ? E(t) : E;
      f !== t && w(f);
    } else
      i(E);
  }, [
    a,
    t,
    i,
    w
  ]);
  return [
    v,
    T
  ];
}
function Ve({ activeSnapPointProp: t, setActiveSnapPointProp: n, snapPoints: e, drawerRef: o, overlayRef: i, fadeFromIndex: a, onSnapPointChange: v, direction: w = "bottom", container: T, snapToSequentialPoint: E }) {
  const [h, f] = Gt({
    prop: t,
    defaultProp: e?.[0],
    onChange: n
  }), [m, B] = r.useState(typeof window < "u" ? {
    innerWidth: window.innerWidth,
    innerHeight: window.innerHeight
  } : void 0);
  r.useEffect(() => {
    function u() {
      B({
        innerWidth: window.innerWidth,
        innerHeight: window.innerHeight
      });
    }
    return window.addEventListener("resize", u), () => window.removeEventListener("resize", u);
  }, []);
  const L = r.useMemo(() => h === e?.[e.length - 1] || null, [
    e,
    h
  ]), D = r.useMemo(() => {
    var u;
    return (u = e?.findIndex((b) => b === h)) != null ? u : null;
  }, [
    e,
    h
  ]), U = e && e.length > 0 && (a || a === 0) && !Number.isNaN(a) && e[a] === h || !e, p = r.useMemo(() => {
    const u = T ? {
      width: T.getBoundingClientRect().width,
      height: T.getBoundingClientRect().height
    } : typeof window < "u" ? {
      width: window.innerWidth,
      height: window.innerHeight
    } : {
      width: 0,
      height: 0
    };
    var b;
    return (b = e?.map((y) => {
      const _ = typeof y == "string";
      let P = 0;
      if (_ && (P = parseInt(y, 10)), C(w)) {
        const s = _ ? P : m ? y * u.height : 0;
        return m ? w === "bottom" ? u.height - s : -u.height + s : s;
      }
      const W = _ ? P : m ? y * u.width : 0;
      return m ? w === "right" ? u.width - W : -u.width + W : W;
    })) != null ? b : [];
  }, [
    e,
    m,
    T
  ]), M = r.useMemo(() => D !== null ? p?.[D] : null, [
    p,
    D
  ]), A = r.useCallback((u) => {
    var b;
    const y = (b = p?.findIndex((_) => _ === u)) != null ? b : null;
    v(y), $(o.current, {
      transition: `transform ${O.DURATION}s cubic-bezier(${O.EASE.join(",")})`,
      transform: C(w) ? `translate3d(0, ${u}px, 0)` : `translate3d(${u}px, 0, 0)`
    }), p && y !== p.length - 1 && a !== void 0 && y !== a && y < a ? $(i.current, {
      transition: `opacity ${O.DURATION}s cubic-bezier(${O.EASE.join(",")})`,
      opacity: "0"
    }) : $(i.current, {
      transition: `opacity ${O.DURATION}s cubic-bezier(${O.EASE.join(",")})`,
      opacity: "1"
    }), f(e?.[Math.max(y, 0)]);
  }, [
    o.current,
    e,
    p,
    a,
    i,
    f
  ]);
  r.useEffect(() => {
    if (h || t) {
      var u;
      const b = (u = e?.findIndex((y) => y === t || y === h)) != null ? u : -1;
      p && b !== -1 && typeof p[b] == "number" && A(p[b]);
    }
  }, [
    h,
    t,
    e,
    p,
    A
  ]);
  function c({ draggedDistance: u, closeDrawer: b, velocity: y, dismissible: _ }) {
    if (a === void 0) return;
    const P = w === "bottom" || w === "right" ? (M ?? 0) - u : (M ?? 0) + u, W = D === a - 1, s = D === 0, F = u > 0;
    if (W && $(i.current, {
      transition: `opacity ${O.DURATION}s cubic-bezier(${O.EASE.join(",")})`
    }), !E && y > 2 && !F) {
      _ ? b() : A(p[0]);
      return;
    }
    if (!E && y > 2 && F && p && e) {
      A(p[e.length - 1]);
      return;
    }
    const H = p?.reduce((I, q) => typeof I != "number" || typeof q != "number" ? I : Math.abs(q - P) < Math.abs(I - P) ? q : I), z = C(w) ? window.innerHeight : window.innerWidth;
    if (y > qt && Math.abs(u) < z * 0.4) {
      const I = F ? 1 : -1;
      if (I > 0 && L && e) {
        A(p[e.length - 1]);
        return;
      }
      if (s && I < 0 && _ && b(), D === null) return;
      A(p[D + I]);
      return;
    }
    A(H);
  }
  function Y({ draggedDistance: u }) {
    if (M === null) return;
    const b = w === "bottom" || w === "right" ? M - u : M + u;
    (w === "bottom" || w === "right") && b < p[p.length - 1] || (w === "top" || w === "left") && b > p[p.length - 1] || $(o.current, {
      transform: C(w) ? `translate3d(0, ${b}px, 0)` : `translate3d(${b}px, 0, 0)`
    });
  }
  function J(u, b) {
    if (!e || typeof D != "number" || !p || a === void 0) return null;
    const y = D === a - 1;
    if (D >= a && b)
      return 0;
    if (y && !b) return 1;
    if (!U && !y) return null;
    const P = y ? D + 1 : D - 1, W = y ? p[P] - p[P - 1] : p[P + 1] - p[P], s = u / Math.abs(W);
    return y ? 1 - s : s;
  }
  return {
    isLastSnapPoint: L,
    activeSnapPoint: h,
    shouldFade: U,
    getPercentageDragged: J,
    setActiveSnapPoint: f,
    activeSnapPointIndex: D,
    onRelease: c,
    onDrag: Y,
    snapPointsOffset: p
  };
}
const Ye = () => () => {
};
function je() {
  const { direction: t, isOpen: n, shouldScaleBackground: e, setBackgroundColorOnScale: o, noBodyStyles: i } = ut(), a = r.useRef(null), v = Ee(() => document.body.style.backgroundColor, []);
  function w() {
    return (window.innerWidth - Ot) / window.innerWidth;
  }
  r.useEffect(() => {
    if (n && e) {
      a.current && clearTimeout(a.current);
      const T = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
      if (!T) return;
      Ue(o && !i ? Rt(document.body, {
        background: "black"
      }) : Ye, Rt(T, {
        transformOrigin: C(t) ? "top" : "left",
        transitionProperty: "transform, border-radius",
        transitionDuration: `${O.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${O.EASE.join(",")})`
      }));
      const E = Rt(T, {
        borderRadius: `${Xt}px`,
        overflow: "hidden",
        ...C(t) ? {
          transform: `scale(${w()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`
        } : {
          transform: `scale(${w()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`
        }
      });
      return () => {
        E(), a.current = window.setTimeout(() => {
          v ? document.body.style.background = v : document.body.style.removeProperty("background");
        }, O.DURATION * 1e3);
      };
    }
  }, [
    n,
    e,
    v
  ]);
}
let st = null;
function qe({ isOpen: t, modal: n, nested: e, hasBeenOpened: o, preventScrollRestoration: i, noBodyStyles: a }) {
  const [v, w] = r.useState(() => typeof window < "u" ? window.location.href : ""), T = r.useRef(0), E = r.useCallback(() => {
    if (kt() && st === null && t && !a) {
      st = {
        position: document.body.style.position,
        top: document.body.style.top,
        left: document.body.style.left,
        height: document.body.style.height,
        right: "unset"
      };
      const { scrollX: f, innerHeight: m } = window;
      document.body.style.setProperty("position", "fixed", "important"), Object.assign(document.body.style, {
        top: `${-T.current}px`,
        left: `${-f}px`,
        right: "0px",
        height: "auto"
      }), window.setTimeout(() => window.requestAnimationFrame(() => {
        const B = m - window.innerHeight;
        B && T.current >= m && (document.body.style.top = `${-(T.current + B)}px`);
      }), 300);
    }
  }, [
    t
  ]), h = r.useCallback(() => {
    if (kt() && st !== null && !a) {
      const f = -parseInt(document.body.style.top, 10), m = -parseInt(document.body.style.left, 10);
      Object.assign(document.body.style, st), window.requestAnimationFrame(() => {
        if (i && v !== window.location.href) {
          w(window.location.href);
          return;
        }
        window.scrollTo(m, f);
      }), st = null;
    }
  }, [
    v
  ]);
  return r.useEffect(() => {
    function f() {
      T.current = window.scrollY;
    }
    return f(), window.addEventListener("scroll", f), () => {
      window.removeEventListener("scroll", f);
    };
  }, []), r.useEffect(() => {
    if (n)
      return () => {
        typeof document > "u" || document.querySelector("[data-vaul-drawer]") || h();
      };
  }, [
    n,
    h
  ]), r.useEffect(() => {
    e || !o || (t ? (!window.matchMedia("(display-mode: standalone)").matches && E(), n || window.setTimeout(() => {
      h();
    }, 500)) : h());
  }, [
    t,
    o,
    v,
    n,
    e,
    E,
    h
  ]), {
    restorePositionSetting: h
  };
}
function Xe({ open: t, onOpenChange: n, children: e, onDrag: o, onRelease: i, snapPoints: a, shouldScaleBackground: v = !1, setBackgroundColorOnScale: w = !0, closeThreshold: T = Fe, scrollLockTimeout: E = We, dismissible: h = !0, handleOnly: f = !1, fadeFromIndex: m = a && a.length - 1, activeSnapPoint: B, setActiveSnapPoint: L, fixed: D, modal: U = !0, onClose: p, nested: M, noBodyStyles: A = !1, direction: c = "bottom", defaultOpen: Y = !1, disablePreventScroll: J = !0, snapToSequentialPoint: u = !1, preventScrollRestoration: b = !1, repositionInputs: y = !0, onAnimationEnd: _, container: P, autoFocus: W = !1 }) {
  var s, F;
  const [H = !1, z] = Gt({
    defaultProp: Y,
    prop: t,
    onChange: (l) => {
      n?.(l), !l && !M && oe(), setTimeout(() => {
        _?.(l);
      }, O.DURATION * 1e3), l && !U && typeof window < "u" && window.requestAnimationFrame(() => {
        document.body.style.pointerEvents = "auto";
      }), l || (document.body.style.pointerEvents = "auto");
    }
  }), [I, q] = r.useState(!1), [X, nt] = r.useState(!1), [Zt, Ct] = r.useState(!1), Z = r.useRef(null), ct = r.useRef(null), ht = r.useRef(null), gt = r.useRef(null), rt = r.useRef(null), at = r.useRef(!1), vt = r.useRef(null), yt = r.useRef(0), tt = r.useRef(!1), $t = r.useRef(!Y), At = r.useRef(0), d = r.useRef(null), Mt = r.useRef(((s = d.current) == null ? void 0 : s.getBoundingClientRect().height) || 0), Pt = r.useRef(((F = d.current) == null ? void 0 : F.getBoundingClientRect().width) || 0), bt = r.useRef(0), te = r.useCallback((l) => {
    a && l === ot.length - 1 && (ct.current = /* @__PURE__ */ new Date());
  }, []), { activeSnapPoint: ee, activeSnapPointIndex: et, setActiveSnapPoint: It, onRelease: ne, snapPointsOffset: ot, onDrag: re, shouldFade: _t, getPercentageDragged: ae } = Ve({
    snapPoints: a,
    activeSnapPointProp: B,
    setActiveSnapPointProp: L,
    drawerRef: d,
    fadeFromIndex: m,
    overlayRef: Z,
    onSnapPointChange: te,
    direction: c,
    container: P,
    snapToSequentialPoint: u
  });
  Ie({
    isDisabled: !H || X || !U || Zt || !I || !y || !J
  });
  const { restorePositionSetting: oe } = qe({
    isOpen: H,
    modal: U,
    nested: M ?? !1,
    hasBeenOpened: I,
    preventScrollRestoration: b,
    noBodyStyles: A
  });
  function dt() {
    return (window.innerWidth - Ot) / window.innerWidth;
  }
  function ie(l) {
    var S, R;
    !h && !a || d.current && !d.current.contains(l.target) || (Mt.current = ((S = d.current) == null ? void 0 : S.getBoundingClientRect().height) || 0, Pt.current = ((R = d.current) == null ? void 0 : R.getBoundingClientRect().width) || 0, nt(!0), ht.current = /* @__PURE__ */ new Date(), zt() && window.addEventListener("touchend", () => at.current = !1, {
      once: !0
    }), l.target.setPointerCapture(l.pointerId), yt.current = C(c) ? l.pageY : l.pageX);
  }
  function Ht(l, S) {
    var R;
    let g = l;
    const x = (R = window.getSelection()) == null ? void 0 : R.toString(), k = d.current ? pt(d.current, c) : null, N = /* @__PURE__ */ new Date();
    if (g.tagName === "SELECT" || g.hasAttribute("data-vaul-no-drag") || g.closest("[data-vaul-no-drag]"))
      return !1;
    if (c === "right" || c === "left")
      return !0;
    if (ct.current && N.getTime() - ct.current.getTime() < 500)
      return !1;
    if (k !== null && (c === "bottom" ? k > 0 : k < 0))
      return !0;
    if (x && x.length > 0)
      return !1;
    if (rt.current && N.getTime() - rt.current.getTime() < E && k === 0 || S)
      return rt.current = N, !1;
    for (; g; ) {
      if (g.scrollHeight > g.clientHeight) {
        if (g.scrollTop !== 0)
          return rt.current = /* @__PURE__ */ new Date(), !1;
        if (g.getAttribute("role") === "dialog")
          return !0;
      }
      g = g.parentNode;
    }
    return !0;
  }
  function le(l) {
    if (d.current && X) {
      const S = c === "bottom" || c === "right" ? 1 : -1, R = (yt.current - (C(c) ? l.pageY : l.pageX)) * S, g = R > 0, x = a && !h && !g;
      if (x && et === 0) return;
      const k = Math.abs(R), N = document.querySelector("[data-vaul-drawer-wrapper]"), K = c === "bottom" || c === "top" ? Mt.current : Pt.current;
      let V = k / K;
      const Q = ae(k, g);
      if (Q !== null && (V = Q), x && V >= 1 || !at.current && !Ht(l.target, g)) return;
      if (d.current.classList.add(Et), at.current = !0, $(d.current, {
        transition: "none"
      }), $(Z.current, {
        transition: "none"
      }), a && re({
        draggedDistance: R
      }), g && !a) {
        const j = Be(R), ft = Math.min(j * -1, 0) * S;
        $(d.current, {
          transform: C(c) ? `translate3d(0, ${ft}px, 0)` : `translate3d(${ft}px, 0, 0)`
        });
        return;
      }
      const G = 1 - V;
      if ((_t || m && et === m - 1) && (o?.(l, V), $(Z.current, {
        opacity: `${G}`,
        transition: "none"
      }, !0)), N && Z.current && v) {
        const j = Math.min(dt() + V * (1 - dt()), 1), ft = 8 - V * 8, Lt = Math.max(0, 14 - V * 14);
        $(N, {
          borderRadius: `${ft}px`,
          transform: C(c) ? `scale(${j}) translate3d(0, ${Lt}px, 0)` : `scale(${j}) translate3d(${Lt}px, 0, 0)`,
          transition: "none"
        }, !0);
      }
      if (!a) {
        const j = k * S;
        $(d.current, {
          transform: C(c) ? `translate3d(0, ${j}px, 0)` : `translate3d(${j}px, 0, 0)`
        });
      }
    }
  }
  r.useEffect(() => {
    window.requestAnimationFrame(() => {
      $t.current = !0;
    });
  }, []), r.useEffect(() => {
    var l;
    function S() {
      if (!d.current || !y) return;
      const R = document.activeElement;
      if (Dt(R) || tt.current) {
        var g;
        const x = ((g = window.visualViewport) == null ? void 0 : g.height) || 0, k = window.innerHeight;
        let N = k - x;
        const K = d.current.getBoundingClientRect().height || 0, V = K > k * 0.8;
        bt.current || (bt.current = K);
        const Q = d.current.getBoundingClientRect().top;
        if (Math.abs(At.current - N) > 60 && (tt.current = !tt.current), a && a.length > 0 && ot && et) {
          const G = ot[et] || 0;
          N += G;
        }
        if (At.current = N, K > x || tt.current) {
          const G = d.current.getBoundingClientRect().height;
          let j = G;
          G > x && (j = x - (V ? Q : Ot)), D ? d.current.style.height = `${G - Math.max(N, 0)}px` : d.current.style.height = `${Math.max(j, x - Q)}px`;
        } else Oe() || (d.current.style.height = `${bt.current}px`);
        a && a.length > 0 && !tt.current ? d.current.style.bottom = "0px" : d.current.style.bottom = `${Math.max(N, 0)}px`;
      }
    }
    return (l = window.visualViewport) == null || l.addEventListener("resize", S), () => {
      var R;
      return (R = window.visualViewport) == null ? void 0 : R.removeEventListener("resize", S);
    };
  }, [
    et,
    a,
    ot
  ]);
  function it(l) {
    se(), p?.(), l || z(!1), setTimeout(() => {
      a && It(a[0]);
    }, O.DURATION * 1e3);
  }
  function Nt() {
    if (!d.current) return;
    const l = document.querySelector("[data-vaul-drawer-wrapper]"), S = pt(d.current, c);
    $(d.current, {
      transform: "translate3d(0, 0, 0)",
      transition: `transform ${O.DURATION}s cubic-bezier(${O.EASE.join(",")})`
    }), $(Z.current, {
      transition: `opacity ${O.DURATION}s cubic-bezier(${O.EASE.join(",")})`,
      opacity: "1"
    }), v && S && S > 0 && H && $(l, {
      borderRadius: `${Xt}px`,
      overflow: "hidden",
      ...C(c) ? {
        transform: `scale(${dt()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
        transformOrigin: "top"
      } : {
        transform: `scale(${dt()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
        transformOrigin: "left"
      },
      transitionProperty: "transform, border-radius",
      transitionDuration: `${O.DURATION}s`,
      transitionTimingFunction: `cubic-bezier(${O.EASE.join(",")})`
    }, !0);
  }
  function se() {
    !X || !d.current || (d.current.classList.remove(Et), at.current = !1, nt(!1), gt.current = /* @__PURE__ */ new Date());
  }
  function ue(l) {
    if (!X || !d.current) return;
    d.current.classList.remove(Et), at.current = !1, nt(!1), gt.current = /* @__PURE__ */ new Date();
    const S = pt(d.current, c);
    if (!l || !Ht(l.target, !1) || !S || Number.isNaN(S) || ht.current === null) return;
    const R = gt.current.getTime() - ht.current.getTime(), g = yt.current - (C(c) ? l.pageY : l.pageX), x = Math.abs(g) / R;
    if (x > 0.05 && (Ct(!0), setTimeout(() => {
      Ct(!1);
    }, 200)), a) {
      ne({
        draggedDistance: g * (c === "bottom" || c === "right" ? 1 : -1),
        closeDrawer: it,
        velocity: x,
        dismissible: h
      }), i?.(l, !0);
      return;
    }
    if (c === "bottom" || c === "right" ? g > 0 : g < 0) {
      Nt(), i?.(l, !0);
      return;
    }
    if (x > qt) {
      it(), i?.(l, !1);
      return;
    }
    var k;
    const N = Math.min((k = d.current.getBoundingClientRect().height) != null ? k : 0, window.innerHeight);
    var K;
    const V = Math.min((K = d.current.getBoundingClientRect().width) != null ? K : 0, window.innerWidth), Q = c === "left" || c === "right";
    if (Math.abs(S) >= (Q ? V : N) * T) {
      it(), i?.(l, !1);
      return;
    }
    i?.(l, !0), Nt();
  }
  r.useEffect(() => (H && ($(document.documentElement, {
    scrollBehavior: "auto"
  }), ct.current = /* @__PURE__ */ new Date()), () => {
    ke(document.documentElement, "scrollBehavior");
  }), [
    H
  ]);
  function ce(l) {
    const S = l ? (window.innerWidth - wt) / window.innerWidth : 1, R = l ? -16 : 0;
    vt.current && window.clearTimeout(vt.current), $(d.current, {
      transition: `transform ${O.DURATION}s cubic-bezier(${O.EASE.join(",")})`,
      transform: C(c) ? `scale(${S}) translate3d(0, ${R}px, 0)` : `scale(${S}) translate3d(${R}px, 0, 0)`
    }), !l && d.current && (vt.current = setTimeout(() => {
      const g = pt(d.current, c);
      $(d.current, {
        transition: "none",
        transform: C(c) ? `translate3d(0, ${g}px, 0)` : `translate3d(${g}px, 0, 0)`
      });
    }, 500));
  }
  function de(l, S) {
    if (S < 0) return;
    const R = (window.innerWidth - wt) / window.innerWidth, g = R + S * (1 - R), x = -16 + S * wt;
    $(d.current, {
      transform: C(c) ? `scale(${g}) translate3d(0, ${x}px, 0)` : `scale(${g}) translate3d(${x}px, 0, 0)`,
      transition: "none"
    });
  }
  function fe(l, S) {
    const R = C(c) ? window.innerHeight : window.innerWidth, g = S ? (R - wt) / R : 1, x = S ? -16 : 0;
    S && $(d.current, {
      transition: `transform ${O.DURATION}s cubic-bezier(${O.EASE.join(",")})`,
      transform: C(c) ? `scale(${g}) translate3d(0, ${x}px, 0)` : `scale(${g}) translate3d(${x}px, 0, 0)`
    });
  }
  return r.useEffect(() => {
    U || window.requestAnimationFrame(() => {
      document.body.style.pointerEvents = "auto";
    });
  }, [
    U
  ]), /* @__PURE__ */ r.createElement(ge, {
    defaultOpen: Y,
    onOpenChange: (l) => {
      !h && !l || (l ? q(!0) : it(!0), z(l));
    },
    open: H
  }, /* @__PURE__ */ r.createElement(Wt.Provider, {
    value: {
      activeSnapPoint: ee,
      snapPoints: a,
      setActiveSnapPoint: It,
      drawerRef: d,
      overlayRef: Z,
      onOpenChange: n,
      onPress: ie,
      onRelease: ue,
      onDrag: le,
      dismissible: h,
      shouldAnimate: $t,
      handleOnly: f,
      isOpen: H,
      isDragging: X,
      shouldFade: _t,
      closeDrawer: it,
      onNestedDrag: de,
      onNestedOpenChange: ce,
      onNestedRelease: fe,
      keyboardIsOpen: tt,
      modal: U,
      snapPointsOffset: ot,
      activeSnapPointIndex: et,
      direction: c,
      shouldScaleBackground: v,
      setBackgroundColorOnScale: w,
      noBodyStyles: A,
      container: P,
      autoFocus: W
    }
  }, e));
}
const Jt = /* @__PURE__ */ r.forwardRef(function({ ...t }, n) {
  const { overlayRef: e, snapPoints: o, onRelease: i, shouldFade: a, isOpen: v, modal: w, shouldAnimate: T } = ut(), E = Yt(n, e), h = o && o.length > 0;
  if (!w)
    return null;
  const f = r.useCallback((m) => i(m), [
    i
  ]);
  return /* @__PURE__ */ r.createElement(ye, {
    onMouseUp: f,
    ref: E,
    "data-vaul-overlay": "",
    "data-vaul-snap-points": v && h ? "true" : "false",
    "data-vaul-snap-points-overlay": v && a ? "true" : "false",
    "data-vaul-animate": T?.current ? "true" : "false",
    ...t
  });
});
Jt.displayName = "Drawer.Overlay";
const Qt = /* @__PURE__ */ r.forwardRef(function({ onPointerDownOutside: t, style: n, onOpenAutoFocus: e, ...o }, i) {
  const { drawerRef: a, onPress: v, onRelease: w, onDrag: T, keyboardIsOpen: E, snapPointsOffset: h, activeSnapPointIndex: f, modal: m, isOpen: B, direction: L, snapPoints: D, container: U, handleOnly: p, shouldAnimate: M, autoFocus: A } = ut(), [c, Y] = r.useState(!1), J = Yt(i, a), u = r.useRef(null), b = r.useRef(null), y = r.useRef(!1), _ = D && D.length > 0;
  je();
  const P = (s, F, H = 0) => {
    if (y.current) return !0;
    const z = Math.abs(s.y), I = Math.abs(s.x), q = I > z, X = [
      "bottom",
      "right"
    ].includes(F) ? 1 : -1;
    if (F === "left" || F === "right") {
      if (!(s.x * X < 0) && I >= 0 && I <= H)
        return q;
    } else if (!(s.y * X < 0) && z >= 0 && z <= H)
      return !q;
    return y.current = !0, !0;
  };
  r.useEffect(() => {
    _ && window.requestAnimationFrame(() => {
      Y(!0);
    });
  }, []);
  function W(s) {
    u.current = null, y.current = !1, w(s);
  }
  return /* @__PURE__ */ r.createElement(be, {
    "data-vaul-drawer-direction": L,
    "data-vaul-drawer": "",
    "data-vaul-delayed-snap-points": c ? "true" : "false",
    "data-vaul-snap-points": B && _ ? "true" : "false",
    "data-vaul-custom-container": U ? "true" : "false",
    "data-vaul-animate": M?.current ? "true" : "false",
    ...o,
    ref: J,
    style: h && h.length > 0 ? {
      "--snap-point-height": `${h[f ?? 0]}px`,
      ...n
    } : n,
    onPointerDown: (s) => {
      p || (o.onPointerDown == null || o.onPointerDown.call(o, s), u.current = {
        x: s.pageX,
        y: s.pageY
      }, v(s));
    },
    onOpenAutoFocus: (s) => {
      e?.(s), A || s.preventDefault();
    },
    onPointerDownOutside: (s) => {
      if (t?.(s), !m || s.defaultPrevented) {
        s.preventDefault();
        return;
      }
      E.current && (E.current = !1);
    },
    onFocusOutside: (s) => {
      if (!m) {
        s.preventDefault();
        return;
      }
    },
    onPointerMove: (s) => {
      if (b.current = s, p || (o.onPointerMove == null || o.onPointerMove.call(o, s), !u.current)) return;
      const F = s.pageY - u.current.y, H = s.pageX - u.current.x, z = s.pointerType === "touch" ? 10 : 2;
      P({
        x: H,
        y: F
      }, L, z) ? T(s) : (Math.abs(H) > z || Math.abs(F) > z) && (u.current = null);
    },
    onPointerUp: (s) => {
      o.onPointerUp == null || o.onPointerUp.call(o, s), u.current = null, y.current = !1, w(s);
    },
    onPointerOut: (s) => {
      o.onPointerOut == null || o.onPointerOut.call(o, s), W(b.current);
    },
    onContextMenu: (s) => {
      o.onContextMenu == null || o.onContextMenu.call(o, s), b.current && W(b.current);
    }
  });
});
Qt.displayName = "Drawer.Content";
const Ke = 250, Ge = 120, Je = /* @__PURE__ */ r.forwardRef(function({ preventCycle: t = !1, children: n, ...e }, o) {
  const { closeDrawer: i, isDragging: a, snapPoints: v, activeSnapPoint: w, setActiveSnapPoint: T, dismissible: E, handleOnly: h, isOpen: f, onPress: m, onDrag: B } = ut(), L = r.useRef(null), D = r.useRef(!1);
  function U() {
    if (D.current) {
      A();
      return;
    }
    window.setTimeout(() => {
      p();
    }, Ge);
  }
  function p() {
    if (a || t || D.current) {
      A();
      return;
    }
    if (A(), !v || v.length === 0) {
      E || i();
      return;
    }
    if (w === v[v.length - 1] && E) {
      i();
      return;
    }
    const Y = v.findIndex((u) => u === w);
    if (Y === -1) return;
    const J = v[Y + 1];
    T(J);
  }
  function M() {
    L.current = window.setTimeout(() => {
      D.current = !0;
    }, Ke);
  }
  function A() {
    L.current && window.clearTimeout(L.current), D.current = !1;
  }
  return /* @__PURE__ */ r.createElement("div", {
    onClick: U,
    onPointerCancel: A,
    onPointerDown: (c) => {
      h && m(c), M();
    },
    onPointerMove: (c) => {
      h && B(c);
    },
    // onPointerUp is already handled by the content component
    ref: o,
    "data-vaul-drawer-visible": f ? "true" : "false",
    "data-vaul-handle": "",
    "aria-hidden": "true",
    ...e
  }, /* @__PURE__ */ r.createElement("span", {
    "data-vaul-handle-hitarea": "",
    "aria-hidden": "true"
  }, n));
});
Je.displayName = "Drawer.Handle";
function Qe(t) {
  const n = ut(), { container: e = n.container, ...o } = t;
  return /* @__PURE__ */ r.createElement(ve, {
    container: e,
    ...o
  });
}
const en = {
  Root: Xe,
  Content: Qt,
  Overlay: Jt,
  Trigger: me,
  Portal: Qe,
  Close: pe,
  Title: we,
  Description: he
};
export {
  Qt as Content,
  en as Drawer,
  Je as Handle,
  Jt as Overlay,
  Qe as Portal,
  Xe as Root
};
//# sourceMappingURL=index.js.map
