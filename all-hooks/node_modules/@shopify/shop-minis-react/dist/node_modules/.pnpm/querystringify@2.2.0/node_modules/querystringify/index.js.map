{"version":3,"file":"index.js","sources":["../../../../../../node_modules/.pnpm/querystringify@2.2.0/node_modules/querystringify/index.js"],"sourcesContent":["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , undef;\n\n/**\n * Decode a URI encoded string.\n *\n * @param {String} input The URI encoded string.\n * @returns {String|Null} The decoded string.\n * @api private\n */\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input.replace(/\\+/g, ' '));\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Attempts to encode a given input.\n *\n * @param {String} input The string that needs to be encoded.\n * @returns {String|Null} The encoded string.\n * @api private\n */\nfunction encode(input) {\n  try {\n    return encodeURIComponent(input);\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?#&]+)=?([^&]*)/g\n    , result = {}\n    , part;\n\n  while (part = parser.exec(query)) {\n    var key = decode(part[1])\n      , value = decode(part[2]);\n\n    //\n    // Prevent overriding of existing properties. This ensures that build-in\n    // methods like `toString` or __proto__ are not overriden by malicious\n    // querystrings.\n    //\n    // In the case if failed decoding, we want to omit the key/value pairs\n    // from the result.\n    //\n    if (key === null || value === null || key in result) continue;\n    result[key] = value;\n  }\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = []\n    , value\n    , key;\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      value = obj[key];\n\n      //\n      // Edge cases where we actually want to encode the value to an empty\n      // string instead of the stringified value.\n      //\n      if (!value && (value === null || value === undef || isNaN(value))) {\n        value = '';\n      }\n\n      key = encode(key);\n      value = encode(value);\n\n      //\n      // If we failed to encode the strings, we should bail out as we don't\n      // want to add invalid strings to the query.\n      //\n      if (key === null || value === null) continue;\n      pairs.push(key +'='+ value);\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;\n"],"names":["has","undef","decode","input","encode","querystring","query","parser","result","part","key","value","querystringify","obj","prefix","pairs","querystringify_1"],"mappings":";;;;;AAEA,MAAIA,IAAM,OAAO,UAAU,gBACvBC;AASJ,WAASC,EAAOC,GAAO;AACrB,QAAI;AACF,aAAO,mBAAmBA,EAAM,QAAQ,OAAO,GAAG,CAAC;AAAA,IACpD,QAAW;AACV,aAAO;AAAA,IACX;AAAA,EACA;AASA,WAASC,EAAOD,GAAO;AACrB,QAAI;AACF,aAAO,mBAAmBA,CAAK;AAAA,IAChC,QAAW;AACV,aAAO;AAAA,IACX;AAAA,EACA;AASA,WAASE,EAAYC,GAAO;AAK1B,aAJIC,IAAS,wBACTC,IAAS,CAAA,GACTC,GAEGA,IAAOF,EAAO,KAAKD,CAAK,KAAG;AAChC,UAAII,IAAMR,EAAOO,EAAK,CAAC,CAAC,GACpBE,IAAQT,EAAOO,EAAK,CAAC,CAAC;AAU1B,MAAIC,MAAQ,QAAQC,MAAU,QAAQD,KAAOF,MAC7CA,EAAOE,CAAG,IAAIC;AAAA,IAClB;AAEE,WAAOH;AAAA,EACT;AAUA,WAASI,EAAeC,GAAKC,GAAQ;AACnC,IAAAA,IAASA,KAAU;AAEnB,QAAIC,IAAQ,CAAA,GACRJ,GACAD;AAKJ,IAAiB,OAAOI,KAApB,aAA4BA,IAAS;AAEzC,SAAKJ,KAAOG;AACV,UAAIb,EAAI,KAAKa,GAAKH,CAAG,GAAG;AAkBtB,YAjBAC,IAAQE,EAAIH,CAAG,GAMX,CAACC,MAAUA,MAAU,QAAQA,MAAUV,KAAS,MAAMU,CAAK,OAC7DA,IAAQ,KAGVD,IAAMN,EAAOM,CAAG,GAChBC,IAAQP,EAAOO,CAAK,GAMhBD,MAAQ,QAAQC,MAAU,KAAM;AACpC,QAAAI,EAAM,KAAKL,IAAK,MAAKC,CAAK;AAAA,MAChC;AAGE,WAAOI,EAAM,SAASD,IAASC,EAAM,KAAK,GAAG,IAAI;AAAA,EACnD;AAKAC,SAAAA,EAAA,YAAoBJ,GACpBI,EAAA,QAAgBX;;","x_google_ignoreList":[0]}