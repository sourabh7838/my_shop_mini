import * as t from "react";
import * as be from "react-dom";
import { clamp as Re } from "../../../../../@radix-ui_number@1.1.1/node_modules/@radix-ui/number/dist/index.js";
import { composeEventHandlers as R } from "../../../../../@radix-ui_primitive@1.1.2/node_modules/@radix-ui/primitive/dist/index.js";
import { createCollection as lt } from "../../../../../@radix-ui_react-collection@1.1.7_@types_react-dom@19.1.6_@types_react@19.1.6__@types_react@19_5kif5qsljjcymh5vn5h26ovoye/node_modules/@radix-ui/react-collection/dist/index.js";
import { useComposedRefs as k } from "../../../../../@radix-ui_react-compose-refs@1.1.2_@types_react@19.1.6_react@19.1.0/node_modules/@radix-ui/react-compose-refs/dist/index.js";
import { createContextScope as ct } from "../../../../../@radix-ui_react-context@1.1.2_@types_react@19.1.6_react@19.1.0/node_modules/@radix-ui/react-context/dist/index.js";
import { useDirection as st } from "../../../../../@radix-ui_react-direction@1.1.1_@types_react@19.1.6_react@19.1.0/node_modules/@radix-ui/react-direction/dist/index.js";
import { DismissableLayer as it } from "../../../../../@radix-ui_react-dismissable-layer@1.1.10_@types_react-dom@19.1.6_@types_react@19.1.6__@types__ipor64qsap4jnr6m7nflv4q5v4/node_modules/@radix-ui/react-dismissable-layer/dist/index.js";
import { useFocusGuards as at } from "../../../../../@radix-ui_react-focus-guards@1.1.2_@types_react@19.1.6_react@19.1.0/node_modules/@radix-ui/react-focus-guards/dist/index.js";
import { FocusScope as dt } from "../../../../../@radix-ui_react-focus-scope@1.1.7_@types_react-dom@19.1.6_@types_react@19.1.6__@types_react@1_zpdtvgogfsfavk62phevpdv4fu/node_modules/@radix-ui/react-focus-scope/dist/index.js";
import { useId as Ie } from "../../../../../@radix-ui_react-id@1.1.1_@types_react@19.1.6_react@19.1.0/node_modules/@radix-ui/react-id/dist/index.js";
import { createPopperScope as _e, Root as ut, Anchor as pt, Content as ft, Arrow as mt } from "../../../../../@radix-ui_react-popper@1.2.7_@types_react-dom@19.1.6_@types_react@19.1.6__@types_react@19.1.6_2sktqq4blwmd3t7e5jqffehtuu/node_modules/@radix-ui/react-popper/dist/index.js";
import { Portal as ht } from "../../../../../@radix-ui_react-portal@1.1.9_@types_react-dom@19.1.6_@types_react@19.1.6__@types_react@19.1.6_sr45arufxpp6hzdn2l7kcrtvqe/node_modules/@radix-ui/react-portal/dist/index.js";
import { Primitive as M } from "../../../../../@radix-ui_react-primitive@2.1.3_@types_react-dom@19.1.6_@types_react@19.1.6__@types_react@19._5iu4xtybujtep4zwi6jviky6tu/node_modules/@radix-ui/react-primitive/dist/index.js";
import { createSlot as vt } from "../../../../../@radix-ui_react-slot@1.2.3_@types_react@19.1.6_react@19.1.0/node_modules/@radix-ui/react-slot/dist/index.js";
import { useCallbackRef as gt } from "../../../../../@radix-ui_react-use-callback-ref@1.1.1_@types_react@19.1.6_react@19.1.0/node_modules/@radix-ui/react-use-callback-ref/dist/index.js";
import { useControllableState as Ee } from "../../../../../@radix-ui_react-use-controllable-state@1.2.2_@types_react@19.1.6_react@19.1.0/node_modules/@radix-ui/react-use-controllable-state/dist/index.js";
import { useLayoutEffect as Y } from "../../../../../@radix-ui_react-use-layout-effect@1.1.1_@types_react@19.1.6_react@19.1.0/node_modules/@radix-ui/react-use-layout-effect/dist/index.js";
import { usePrevious as St } from "../../../../../@radix-ui_react-use-previous@1.1.1_@types_react@19.1.6_react@19.1.0/node_modules/@radix-ui/react-use-previous/dist/index.js";
import { VISUALLY_HIDDEN_STYLES as wt } from "../../../../../@radix-ui_react-visually-hidden@1.2.3_@types_react-dom@19.1.6_@types_react@19.1.6__@types_rea_3rnyx4jgemf4vn7spx7uohk4ne/node_modules/@radix-ui/react-visually-hidden/dist/index.js";
import { hideOthers as Ct } from "../../../../../aria-hidden@1.2.6/node_modules/aria-hidden/dist/es2015/index.js";
import xt from "../../../../../react-remove-scroll@2.7.1_@types_react@19.1.6_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/Combination.js";
import { jsx as p, jsxs as se, Fragment as Te } from "react/jsx-runtime";
var yt = [" ", "Enter", "ArrowUp", "ArrowDown"], It = [" ", "Enter"], J = "Select", [ae, de, Tt] = lt(J), [te, uo] = ct(J, [
  Tt,
  _e
]), ue = _e(), [Pt, j] = te(J), [Rt, Et] = te(J), Ne = (o) => {
  const {
    __scopeSelect: s,
    children: e,
    open: i,
    defaultOpen: l,
    onOpenChange: d,
    value: n,
    defaultValue: r,
    onValueChange: c,
    dir: f,
    name: g,
    autoComplete: C,
    disabled: E,
    required: T,
    form: y
  } = o, a = ue(s), [h, S] = t.useState(null), [m, v] = t.useState(null), [F, A] = t.useState(!1), oe = st(f), [b, D] = Ee({
    prop: i,
    defaultProp: l ?? !1,
    onChange: d,
    caller: J
  }), [K, X] = Ee({
    prop: n,
    defaultProp: r,
    onChange: c,
    caller: J
  }), B = t.useRef(null), V = h ? y || !!h.closest("form") : !0, [G, H] = t.useState(/* @__PURE__ */ new Set()), U = Array.from(G).map((_) => _.props.value).join(";");
  return /* @__PURE__ */ p(ut, { ...a, children: /* @__PURE__ */ se(
    Pt,
    {
      required: T,
      scope: s,
      trigger: h,
      onTriggerChange: S,
      valueNode: m,
      onValueNodeChange: v,
      valueNodeHasChildren: F,
      onValueNodeHasChildrenChange: A,
      contentId: Ie(),
      value: K,
      onValueChange: X,
      open: b,
      onOpenChange: D,
      dir: oe,
      triggerPointerDownPosRef: B,
      disabled: E,
      children: [
        /* @__PURE__ */ p(ae.Provider, { scope: s, children: /* @__PURE__ */ p(
          Rt,
          {
            scope: o.__scopeSelect,
            onNativeOptionAdd: t.useCallback((_) => {
              H((L) => new Set(L).add(_));
            }, []),
            onNativeOptionRemove: t.useCallback((_) => {
              H((L) => {
                const W = new Set(L);
                return W.delete(_), W;
              });
            }, []),
            children: e
          }
        ) }),
        V ? /* @__PURE__ */ se(
          tt,
          {
            "aria-hidden": !0,
            required: T,
            tabIndex: -1,
            name: g,
            autoComplete: C,
            value: K,
            onChange: (_) => X(_.target.value),
            disabled: E,
            form: y,
            children: [
              K === void 0 ? /* @__PURE__ */ p("option", { value: "" }) : null,
              Array.from(G)
            ]
          },
          U
        ) : null
      ]
    }
  ) });
};
Ne.displayName = J;
var Me = "SelectTrigger", Ae = t.forwardRef(
  (o, s) => {
    const { __scopeSelect: e, disabled: i = !1, ...l } = o, d = ue(e), n = j(Me, e), r = n.disabled || i, c = k(s, n.onTriggerChange), f = de(e), g = t.useRef("touch"), [C, E, T] = nt((a) => {
      const h = f().filter((v) => !v.disabled), S = h.find((v) => v.value === n.value), m = rt(h, a, S);
      m !== void 0 && n.onValueChange(m.value);
    }), y = (a) => {
      r || (n.onOpenChange(!0), T()), a && (n.triggerPointerDownPosRef.current = {
        x: Math.round(a.pageX),
        y: Math.round(a.pageY)
      });
    };
    return /* @__PURE__ */ p(pt, { asChild: !0, ...d, children: /* @__PURE__ */ p(
      M.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": n.contentId,
        "aria-expanded": n.open,
        "aria-required": n.required,
        "aria-autocomplete": "none",
        dir: n.dir,
        "data-state": n.open ? "open" : "closed",
        disabled: r,
        "data-disabled": r ? "" : void 0,
        "data-placeholder": ot(n.value) ? "" : void 0,
        ...l,
        ref: c,
        onClick: R(l.onClick, (a) => {
          a.currentTarget.focus(), g.current !== "mouse" && y(a);
        }),
        onPointerDown: R(l.onPointerDown, (a) => {
          g.current = a.pointerType;
          const h = a.target;
          h.hasPointerCapture(a.pointerId) && h.releasePointerCapture(a.pointerId), a.button === 0 && a.ctrlKey === !1 && a.pointerType === "mouse" && (y(a), a.preventDefault());
        }),
        onKeyDown: R(l.onKeyDown, (a) => {
          const h = C.current !== "";
          !(a.ctrlKey || a.altKey || a.metaKey) && a.key.length === 1 && E(a.key), !(h && a.key === " ") && yt.includes(a.key) && (y(), a.preventDefault());
        })
      }
    ) });
  }
);
Ae.displayName = Me;
var Oe = "SelectValue", De = t.forwardRef(
  (o, s) => {
    const { __scopeSelect: e, className: i, style: l, children: d, placeholder: n = "", ...r } = o, c = j(Oe, e), { onValueNodeHasChildrenChange: f } = c, g = d !== void 0, C = k(s, c.onValueNodeChange);
    return Y(() => {
      f(g);
    }, [f, g]), /* @__PURE__ */ p(
      M.span,
      {
        ...r,
        ref: C,
        style: { pointerEvents: "none" },
        children: ot(c.value) ? /* @__PURE__ */ p(Te, { children: n }) : d
      }
    );
  }
);
De.displayName = Oe;
var bt = "SelectIcon", Le = t.forwardRef(
  (o, s) => {
    const { __scopeSelect: e, children: i, ...l } = o;
    return /* @__PURE__ */ p(M.span, { "aria-hidden": !0, ...l, ref: s, children: i || "â–¼" });
  }
);
Le.displayName = bt;
var _t = "SelectPortal", ke = (o) => /* @__PURE__ */ p(ht, { asChild: !0, ...o });
ke.displayName = _t;
var Q = "SelectContent", Be = t.forwardRef(
  (o, s) => {
    const e = j(Q, o.__scopeSelect), [i, l] = t.useState();
    if (Y(() => {
      l(new DocumentFragment());
    }, []), !e.open) {
      const d = i;
      return d ? be.createPortal(
        /* @__PURE__ */ p(Ve, { scope: o.__scopeSelect, children: /* @__PURE__ */ p(ae.Slot, { scope: o.__scopeSelect, children: /* @__PURE__ */ p("div", { children: o.children }) }) }),
        d
      ) : null;
    }
    return /* @__PURE__ */ p(He, { ...o, ref: s });
  }
);
Be.displayName = Q;
var O = 10, [Ve, q] = te(Q), Nt = "SelectContentImpl", Mt = vt("SelectContent.RemoveScroll"), He = t.forwardRef(
  (o, s) => {
    const {
      __scopeSelect: e,
      position: i = "item-aligned",
      onCloseAutoFocus: l,
      onEscapeKeyDown: d,
      onPointerDownOutside: n,
      //
      // PopperContent props
      side: r,
      sideOffset: c,
      align: f,
      alignOffset: g,
      arrowPadding: C,
      collisionBoundary: E,
      collisionPadding: T,
      sticky: y,
      hideWhenDetached: a,
      avoidCollisions: h,
      //
      ...S
    } = o, m = j(Q, e), [v, F] = t.useState(null), [A, oe] = t.useState(null), b = k(s, (u) => F(u)), [D, K] = t.useState(null), [X, B] = t.useState(
      null
    ), V = de(e), [G, H] = t.useState(!1), U = t.useRef(!1);
    t.useEffect(() => {
      if (v) return Ct(v);
    }, [v]), at();
    const _ = t.useCallback(
      (u) => {
        const [I, ...N] = V().map((P) => P.ref.current), [w] = N.slice(-1), x = document.activeElement;
        for (const P of u)
          if (P === x || (P?.scrollIntoView({ block: "nearest" }), P === I && A && (A.scrollTop = 0), P === w && A && (A.scrollTop = A.scrollHeight), P?.focus(), document.activeElement !== x)) return;
      },
      [V, A]
    ), L = t.useCallback(
      () => _([D, v]),
      [_, D, v]
    );
    t.useEffect(() => {
      G && L();
    }, [G, L]);
    const { onOpenChange: W, triggerPointerDownPosRef: z } = m;
    t.useEffect(() => {
      if (v) {
        let u = { x: 0, y: 0 };
        const I = (w) => {
          u = {
            x: Math.abs(Math.round(w.pageX) - (z.current?.x ?? 0)),
            y: Math.abs(Math.round(w.pageY) - (z.current?.y ?? 0))
          };
        }, N = (w) => {
          u.x <= 10 && u.y <= 10 ? w.preventDefault() : v.contains(w.target) || W(!1), document.removeEventListener("pointermove", I), z.current = null;
        };
        return z.current !== null && (document.addEventListener("pointermove", I), document.addEventListener("pointerup", N, { capture: !0, once: !0 })), () => {
          document.removeEventListener("pointermove", I), document.removeEventListener("pointerup", N, { capture: !0 });
        };
      }
    }, [v, W, z]), t.useEffect(() => {
      const u = () => W(!1);
      return window.addEventListener("blur", u), window.addEventListener("resize", u), () => {
        window.removeEventListener("blur", u), window.removeEventListener("resize", u);
      };
    }, [W]);
    const [pe, le] = nt((u) => {
      const I = V().filter((x) => !x.disabled), N = I.find((x) => x.ref.current === document.activeElement), w = rt(I, u, N);
      w && setTimeout(() => w.ref.current.focus());
    }), fe = t.useCallback(
      (u, I, N) => {
        const w = !U.current && !N;
        (m.value !== void 0 && m.value === I || w) && (K(u), w && (U.current = !0));
      },
      [m.value]
    ), me = t.useCallback(() => v?.focus(), [v]), ee = t.useCallback(
      (u, I, N) => {
        const w = !U.current && !N;
        (m.value !== void 0 && m.value === I || w) && B(u);
      },
      [m.value]
    ), ce = i === "popper" ? Se : Ue, ne = ce === Se ? {
      side: r,
      sideOffset: c,
      align: f,
      alignOffset: g,
      arrowPadding: C,
      collisionBoundary: E,
      collisionPadding: T,
      sticky: y,
      hideWhenDetached: a,
      avoidCollisions: h
    } : {};
    return /* @__PURE__ */ p(
      Ve,
      {
        scope: e,
        content: v,
        viewport: A,
        onViewportChange: oe,
        itemRefCallback: fe,
        selectedItem: D,
        onItemLeave: me,
        itemTextRefCallback: ee,
        focusSelectedItem: L,
        selectedItemText: X,
        position: i,
        isPositioned: G,
        searchRef: pe,
        children: /* @__PURE__ */ p(xt, { as: Mt, allowPinchZoom: !0, children: /* @__PURE__ */ p(
          dt,
          {
            asChild: !0,
            trapped: m.open,
            onMountAutoFocus: (u) => {
              u.preventDefault();
            },
            onUnmountAutoFocus: R(l, (u) => {
              m.trigger?.focus({ preventScroll: !0 }), u.preventDefault();
            }),
            children: /* @__PURE__ */ p(
              it,
              {
                asChild: !0,
                disableOutsidePointerEvents: !0,
                onEscapeKeyDown: d,
                onPointerDownOutside: n,
                onFocusOutside: (u) => u.preventDefault(),
                onDismiss: () => m.onOpenChange(!1),
                children: /* @__PURE__ */ p(
                  ce,
                  {
                    role: "listbox",
                    id: m.contentId,
                    "data-state": m.open ? "open" : "closed",
                    dir: m.dir,
                    onContextMenu: (u) => u.preventDefault(),
                    ...S,
                    ...ne,
                    onPlaced: () => H(!0),
                    ref: b,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...S.style
                    },
                    onKeyDown: R(S.onKeyDown, (u) => {
                      const I = u.ctrlKey || u.altKey || u.metaKey;
                      if (u.key === "Tab" && u.preventDefault(), !I && u.key.length === 1 && le(u.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(u.key)) {
                        let w = V().filter((x) => !x.disabled).map((x) => x.ref.current);
                        if (["ArrowUp", "End"].includes(u.key) && (w = w.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(u.key)) {
                          const x = u.target, P = w.indexOf(x);
                          w = w.slice(P + 1);
                        }
                        setTimeout(() => _(w)), u.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
He.displayName = Nt;
var At = "SelectItemAlignedPosition", Ue = t.forwardRef((o, s) => {
  const { __scopeSelect: e, onPlaced: i, ...l } = o, d = j(Q, e), n = q(Q, e), [r, c] = t.useState(null), [f, g] = t.useState(null), C = k(s, (b) => g(b)), E = de(e), T = t.useRef(!1), y = t.useRef(!0), { viewport: a, selectedItem: h, selectedItemText: S, focusSelectedItem: m } = n, v = t.useCallback(() => {
    if (d.trigger && d.valueNode && r && f && a && h && S) {
      const b = d.trigger.getBoundingClientRect(), D = f.getBoundingClientRect(), K = d.valueNode.getBoundingClientRect(), X = S.getBoundingClientRect();
      if (d.dir !== "rtl") {
        const x = X.left - D.left, P = K.left - x, Z = b.left - P, $ = b.width + Z, he = Math.max($, D.width), ve = window.innerWidth - O, ge = Re(P, [
          O,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(O, ve - he)
        ]);
        r.style.minWidth = $ + "px", r.style.left = ge + "px";
      } else {
        const x = D.right - X.right, P = window.innerWidth - K.right - x, Z = window.innerWidth - b.right - P, $ = b.width + Z, he = Math.max($, D.width), ve = window.innerWidth - O, ge = Re(P, [
          O,
          Math.max(O, ve - he)
        ]);
        r.style.minWidth = $ + "px", r.style.right = ge + "px";
      }
      const B = E(), V = window.innerHeight - O * 2, G = a.scrollHeight, H = window.getComputedStyle(f), U = parseInt(H.borderTopWidth, 10), _ = parseInt(H.paddingTop, 10), L = parseInt(H.borderBottomWidth, 10), W = parseInt(H.paddingBottom, 10), z = U + _ + G + W + L, pe = Math.min(h.offsetHeight * 5, z), le = window.getComputedStyle(a), fe = parseInt(le.paddingTop, 10), me = parseInt(le.paddingBottom, 10), ee = b.top + b.height / 2 - O, ce = V - ee, ne = h.offsetHeight / 2, u = h.offsetTop + ne, I = U + _ + u, N = z - I;
      if (I <= ee) {
        const x = B.length > 0 && h === B[B.length - 1].ref.current;
        r.style.bottom = "0px";
        const P = f.clientHeight - a.offsetTop - a.offsetHeight, Z = Math.max(
          ce,
          ne + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (x ? me : 0) + P + L
        ), $ = I + Z;
        r.style.height = $ + "px";
      } else {
        const x = B.length > 0 && h === B[0].ref.current;
        r.style.top = "0px";
        const Z = Math.max(
          ee,
          U + a.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (x ? fe : 0) + ne
        ) + N;
        r.style.height = Z + "px", a.scrollTop = I - ee + a.offsetTop;
      }
      r.style.margin = `${O}px 0`, r.style.minHeight = pe + "px", r.style.maxHeight = V + "px", i?.(), requestAnimationFrame(() => T.current = !0);
    }
  }, [
    E,
    d.trigger,
    d.valueNode,
    r,
    f,
    a,
    h,
    S,
    d.dir,
    i
  ]);
  Y(() => v(), [v]);
  const [F, A] = t.useState();
  Y(() => {
    f && A(window.getComputedStyle(f).zIndex);
  }, [f]);
  const oe = t.useCallback(
    (b) => {
      b && y.current === !0 && (v(), m?.(), y.current = !1);
    },
    [v, m]
  );
  return /* @__PURE__ */ p(
    Dt,
    {
      scope: e,
      contentWrapper: r,
      shouldExpandOnScrollRef: T,
      onScrollButtonChange: oe,
      children: /* @__PURE__ */ p(
        "div",
        {
          ref: c,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: F
          },
          children: /* @__PURE__ */ p(
            M.div,
            {
              ...l,
              ref: C,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...l.style
              }
            }
          )
        }
      )
    }
  );
});
Ue.displayName = At;
var Ot = "SelectPopperPosition", Se = t.forwardRef((o, s) => {
  const {
    __scopeSelect: e,
    align: i = "start",
    collisionPadding: l = O,
    ...d
  } = o, n = ue(e);
  return /* @__PURE__ */ p(
    ft,
    {
      ...n,
      ...d,
      ref: s,
      align: i,
      collisionPadding: l,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...d.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
Se.displayName = Ot;
var [Dt, Pe] = te(Q, {}), we = "SelectViewport", We = t.forwardRef(
  (o, s) => {
    const { __scopeSelect: e, nonce: i, ...l } = o, d = q(we, e), n = Pe(we, e), r = k(s, d.onViewportChange), c = t.useRef(0);
    return /* @__PURE__ */ se(Te, { children: [
      /* @__PURE__ */ p(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: i
        }
      ),
      /* @__PURE__ */ p(ae.Slot, { scope: e, children: /* @__PURE__ */ p(
        M.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...l,
          ref: r,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...l.style
          },
          onScroll: R(l.onScroll, (f) => {
            const g = f.currentTarget, { contentWrapper: C, shouldExpandOnScrollRef: E } = n;
            if (E?.current && C) {
              const T = Math.abs(c.current - g.scrollTop);
              if (T > 0) {
                const y = window.innerHeight - O * 2, a = parseFloat(C.style.minHeight), h = parseFloat(C.style.height), S = Math.max(a, h);
                if (S < y) {
                  const m = S + T, v = Math.min(y, m), F = m - v;
                  C.style.height = v + "px", C.style.bottom === "0px" && (g.scrollTop = F > 0 ? F : 0, C.style.justifyContent = "flex-end");
                }
              }
            }
            c.current = g.scrollTop;
          })
        }
      ) })
    ] });
  }
);
We.displayName = we;
var Fe = "SelectGroup", [Lt, kt] = te(Fe), Ke = t.forwardRef(
  (o, s) => {
    const { __scopeSelect: e, ...i } = o, l = Ie();
    return /* @__PURE__ */ p(Lt, { scope: e, id: l, children: /* @__PURE__ */ p(M.div, { role: "group", "aria-labelledby": l, ...i, ref: s }) });
  }
);
Ke.displayName = Fe;
var Ge = "SelectLabel", ze = t.forwardRef(
  (o, s) => {
    const { __scopeSelect: e, ...i } = o, l = kt(Ge, e);
    return /* @__PURE__ */ p(M.div, { id: l.id, ...i, ref: s });
  }
);
ze.displayName = Ge;
var ie = "SelectItem", [Bt, Ye] = te(ie), je = t.forwardRef(
  (o, s) => {
    const {
      __scopeSelect: e,
      value: i,
      disabled: l = !1,
      textValue: d,
      ...n
    } = o, r = j(ie, e), c = q(ie, e), f = r.value === i, [g, C] = t.useState(d ?? ""), [E, T] = t.useState(!1), y = k(
      s,
      (m) => c.itemRefCallback?.(m, i, l)
    ), a = Ie(), h = t.useRef("touch"), S = () => {
      l || (r.onValueChange(i), r.onOpenChange(!1));
    };
    if (i === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return /* @__PURE__ */ p(
      Bt,
      {
        scope: e,
        value: i,
        disabled: l,
        textId: a,
        isSelected: f,
        onItemTextChange: t.useCallback((m) => {
          C((v) => v || (m?.textContent ?? "").trim());
        }, []),
        children: /* @__PURE__ */ p(
          ae.ItemSlot,
          {
            scope: e,
            value: i,
            disabled: l,
            textValue: g,
            children: /* @__PURE__ */ p(
              M.div,
              {
                role: "option",
                "aria-labelledby": a,
                "data-highlighted": E ? "" : void 0,
                "aria-selected": f && E,
                "data-state": f ? "checked" : "unchecked",
                "aria-disabled": l || void 0,
                "data-disabled": l ? "" : void 0,
                tabIndex: l ? void 0 : -1,
                ...n,
                ref: y,
                onFocus: R(n.onFocus, () => T(!0)),
                onBlur: R(n.onBlur, () => T(!1)),
                onClick: R(n.onClick, () => {
                  h.current !== "mouse" && S();
                }),
                onPointerUp: R(n.onPointerUp, () => {
                  h.current === "mouse" && S();
                }),
                onPointerDown: R(n.onPointerDown, (m) => {
                  h.current = m.pointerType;
                }),
                onPointerMove: R(n.onPointerMove, (m) => {
                  h.current = m.pointerType, l ? c.onItemLeave?.() : h.current === "mouse" && m.currentTarget.focus({ preventScroll: !0 });
                }),
                onPointerLeave: R(n.onPointerLeave, (m) => {
                  m.currentTarget === document.activeElement && c.onItemLeave?.();
                }),
                onKeyDown: R(n.onKeyDown, (m) => {
                  c.searchRef?.current !== "" && m.key === " " || (It.includes(m.key) && S(), m.key === " " && m.preventDefault());
                })
              }
            )
          }
        )
      }
    );
  }
);
je.displayName = ie;
var re = "SelectItemText", qe = t.forwardRef(
  (o, s) => {
    const { __scopeSelect: e, className: i, style: l, ...d } = o, n = j(re, e), r = q(re, e), c = Ye(re, e), f = Et(re, e), [g, C] = t.useState(null), E = k(
      s,
      (S) => C(S),
      c.onItemTextChange,
      (S) => r.itemTextRefCallback?.(S, c.value, c.disabled)
    ), T = g?.textContent, y = t.useMemo(
      () => /* @__PURE__ */ p("option", { value: c.value, disabled: c.disabled, children: T }, c.value),
      [c.disabled, c.value, T]
    ), { onNativeOptionAdd: a, onNativeOptionRemove: h } = f;
    return Y(() => (a(y), () => h(y)), [a, h, y]), /* @__PURE__ */ se(Te, { children: [
      /* @__PURE__ */ p(M.span, { id: c.textId, ...d, ref: E }),
      c.isSelected && n.valueNode && !n.valueNodeHasChildren ? be.createPortal(d.children, n.valueNode) : null
    ] });
  }
);
qe.displayName = re;
var Xe = "SelectItemIndicator", Ze = t.forwardRef(
  (o, s) => {
    const { __scopeSelect: e, ...i } = o;
    return Ye(Xe, e).isSelected ? /* @__PURE__ */ p(M.span, { "aria-hidden": !0, ...i, ref: s }) : null;
  }
);
Ze.displayName = Xe;
var Ce = "SelectScrollUpButton", $e = t.forwardRef((o, s) => {
  const e = q(Ce, o.__scopeSelect), i = Pe(Ce, o.__scopeSelect), [l, d] = t.useState(!1), n = k(s, i.onScrollButtonChange);
  return Y(() => {
    if (e.viewport && e.isPositioned) {
      let r = function() {
        const f = c.scrollTop > 0;
        d(f);
      };
      const c = e.viewport;
      return r(), c.addEventListener("scroll", r), () => c.removeEventListener("scroll", r);
    }
  }, [e.viewport, e.isPositioned]), l ? /* @__PURE__ */ p(
    Qe,
    {
      ...o,
      ref: n,
      onAutoScroll: () => {
        const { viewport: r, selectedItem: c } = e;
        r && c && (r.scrollTop = r.scrollTop - c.offsetHeight);
      }
    }
  ) : null;
});
$e.displayName = Ce;
var xe = "SelectScrollDownButton", Je = t.forwardRef((o, s) => {
  const e = q(xe, o.__scopeSelect), i = Pe(xe, o.__scopeSelect), [l, d] = t.useState(!1), n = k(s, i.onScrollButtonChange);
  return Y(() => {
    if (e.viewport && e.isPositioned) {
      let r = function() {
        const f = c.scrollHeight - c.clientHeight, g = Math.ceil(c.scrollTop) < f;
        d(g);
      };
      const c = e.viewport;
      return r(), c.addEventListener("scroll", r), () => c.removeEventListener("scroll", r);
    }
  }, [e.viewport, e.isPositioned]), l ? /* @__PURE__ */ p(
    Qe,
    {
      ...o,
      ref: n,
      onAutoScroll: () => {
        const { viewport: r, selectedItem: c } = e;
        r && c && (r.scrollTop = r.scrollTop + c.offsetHeight);
      }
    }
  ) : null;
});
Je.displayName = xe;
var Qe = t.forwardRef((o, s) => {
  const { __scopeSelect: e, onAutoScroll: i, ...l } = o, d = q("SelectScrollButton", e), n = t.useRef(null), r = de(e), c = t.useCallback(() => {
    n.current !== null && (window.clearInterval(n.current), n.current = null);
  }, []);
  return t.useEffect(() => () => c(), [c]), Y(() => {
    r().find((g) => g.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" });
  }, [r]), /* @__PURE__ */ p(
    M.div,
    {
      "aria-hidden": !0,
      ...l,
      ref: s,
      style: { flexShrink: 0, ...l.style },
      onPointerDown: R(l.onPointerDown, () => {
        n.current === null && (n.current = window.setInterval(i, 50));
      }),
      onPointerMove: R(l.onPointerMove, () => {
        d.onItemLeave?.(), n.current === null && (n.current = window.setInterval(i, 50));
      }),
      onPointerLeave: R(l.onPointerLeave, () => {
        c();
      })
    }
  );
}), Vt = "SelectSeparator", et = t.forwardRef(
  (o, s) => {
    const { __scopeSelect: e, ...i } = o;
    return /* @__PURE__ */ p(M.div, { "aria-hidden": !0, ...i, ref: s });
  }
);
et.displayName = Vt;
var ye = "SelectArrow", Ht = t.forwardRef(
  (o, s) => {
    const { __scopeSelect: e, ...i } = o, l = ue(e), d = j(ye, e), n = q(ye, e);
    return d.open && n.position === "popper" ? /* @__PURE__ */ p(mt, { ...l, ...i, ref: s }) : null;
  }
);
Ht.displayName = ye;
var Ut = "SelectBubbleInput", tt = t.forwardRef(
  ({ __scopeSelect: o, value: s, ...e }, i) => {
    const l = t.useRef(null), d = k(i, l), n = St(s);
    return t.useEffect(() => {
      const r = l.current;
      if (!r) return;
      const c = window.HTMLSelectElement.prototype, g = Object.getOwnPropertyDescriptor(
        c,
        "value"
      ).set;
      if (n !== s && g) {
        const C = new Event("change", { bubbles: !0 });
        g.call(r, s), r.dispatchEvent(C);
      }
    }, [n, s]), /* @__PURE__ */ p(
      M.select,
      {
        ...e,
        style: { ...wt, ...e.style },
        ref: d,
        defaultValue: s
      }
    );
  }
);
tt.displayName = Ut;
function ot(o) {
  return o === "" || o === void 0;
}
function nt(o) {
  const s = gt(o), e = t.useRef(""), i = t.useRef(0), l = t.useCallback(
    (n) => {
      const r = e.current + n;
      s(r), function c(f) {
        e.current = f, window.clearTimeout(i.current), f !== "" && (i.current = window.setTimeout(() => c(""), 1e3));
      }(r);
    },
    [s]
  ), d = t.useCallback(() => {
    e.current = "", window.clearTimeout(i.current);
  }, []);
  return t.useEffect(() => () => window.clearTimeout(i.current), []), [e, l, d];
}
function rt(o, s, e) {
  const l = s.length > 1 && Array.from(s).every((f) => f === s[0]) ? s[0] : s, d = e ? o.indexOf(e) : -1;
  let n = Wt(o, Math.max(d, 0));
  l.length === 1 && (n = n.filter((f) => f !== e));
  const c = n.find(
    (f) => f.textValue.toLowerCase().startsWith(l.toLowerCase())
  );
  return c !== e ? c : void 0;
}
function Wt(o, s) {
  return o.map((e, i) => o[(s + i) % o.length]);
}
var po = Ne, fo = Ae, mo = De, ho = Le, vo = ke, go = Be, So = We, wo = Ke, Co = ze, xo = je, yo = qe, Io = Ze, To = $e, Po = Je, Ro = et;
export {
  go as Content,
  wo as Group,
  ho as Icon,
  xo as Item,
  Io as ItemIndicator,
  yo as ItemText,
  Co as Label,
  vo as Portal,
  po as Root,
  Po as ScrollDownButton,
  To as ScrollUpButton,
  Ne as Select,
  Ht as SelectArrow,
  Be as SelectContent,
  Ke as SelectGroup,
  Le as SelectIcon,
  je as SelectItem,
  Ze as SelectItemIndicator,
  qe as SelectItemText,
  ze as SelectLabel,
  ke as SelectPortal,
  Je as SelectScrollDownButton,
  $e as SelectScrollUpButton,
  et as SelectSeparator,
  Ae as SelectTrigger,
  De as SelectValue,
  We as SelectViewport,
  Ro as Separator,
  fo as Trigger,
  mo as Value,
  So as Viewport,
  uo as createSelectScope
};
//# sourceMappingURL=index.js.map
