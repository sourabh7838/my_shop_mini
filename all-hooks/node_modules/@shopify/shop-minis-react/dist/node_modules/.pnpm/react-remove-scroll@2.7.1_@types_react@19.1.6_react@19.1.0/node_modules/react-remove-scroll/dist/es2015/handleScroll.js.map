{"version":3,"file":"handleScroll.js","sources":["../../../../../../../../node_modules/.pnpm/react-remove-scroll@2.7.1_@types+react@19.1.6_react@19.1.0/node_modules/react-remove-scroll/dist/es2015/handleScroll.js"],"sourcesContent":["var alwaysContainsScroll = function (node) {\n    // textarea will always _contain_ scroll inside self. It only can be hidden\n    return node.tagName === 'TEXTAREA';\n};\nvar elementCanBeScrolled = function (node, overflow) {\n    if (!(node instanceof Element)) {\n        return false;\n    }\n    var styles = window.getComputedStyle(node);\n    return (\n    // not-not-scrollable\n    styles[overflow] !== 'hidden' &&\n        // contains scroll inside self\n        !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === 'visible'));\n};\nvar elementCouldBeVScrolled = function (node) { return elementCanBeScrolled(node, 'overflowY'); };\nvar elementCouldBeHScrolled = function (node) { return elementCanBeScrolled(node, 'overflowX'); };\nexport var locationCouldBeScrolled = function (axis, node) {\n    var ownerDocument = node.ownerDocument;\n    var current = node;\n    do {\n        // Skip over shadow root\n        if (typeof ShadowRoot !== 'undefined' && current instanceof ShadowRoot) {\n            current = current.host;\n        }\n        var isScrollable = elementCouldBeScrolled(axis, current);\n        if (isScrollable) {\n            var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];\n            if (scrollHeight > clientHeight) {\n                return true;\n            }\n        }\n        current = current.parentNode;\n    } while (current && current !== ownerDocument.body);\n    return false;\n};\nvar getVScrollVariables = function (_a) {\n    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;\n    return [\n        scrollTop,\n        scrollHeight,\n        clientHeight,\n    ];\n};\nvar getHScrollVariables = function (_a) {\n    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;\n    return [\n        scrollLeft,\n        scrollWidth,\n        clientWidth,\n    ];\n};\nvar elementCouldBeScrolled = function (axis, node) {\n    return axis === 'v' ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);\n};\nvar getScrollVariables = function (axis, node) {\n    return axis === 'v' ? getVScrollVariables(node) : getHScrollVariables(node);\n};\nvar getDirectionFactor = function (axis, direction) {\n    /**\n     * If the element's direction is rtl (right-to-left), then scrollLeft is 0 when the scrollbar is at its rightmost position,\n     * and then increasingly negative as you scroll towards the end of the content.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\n     */\n    return axis === 'h' && direction === 'rtl' ? -1 : 1;\n};\nexport var handleScroll = function (axis, endTarget, event, sourceDelta, noOverscroll) {\n    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);\n    var delta = directionFactor * sourceDelta;\n    // find scrollable target\n    var target = event.target;\n    var targetInLock = endTarget.contains(target);\n    var shouldCancelScroll = false;\n    var isDeltaPositive = delta > 0;\n    var availableScroll = 0;\n    var availableScrollTop = 0;\n    do {\n        if (!target) {\n            break;\n        }\n        var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];\n        var elementScroll = scroll_1 - capacity - directionFactor * position;\n        if (position || elementScroll) {\n            if (elementCouldBeScrolled(axis, target)) {\n                availableScroll += elementScroll;\n                availableScrollTop += position;\n            }\n        }\n        var parent_1 = target.parentNode;\n        // we will \"bubble\" from ShadowDom in case we are, or just to the parent in normal case\n        // this is the same logic used in focus-lock\n        target = (parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1);\n    } while (\n    // portaled content\n    (!targetInLock && target !== document.body) ||\n        // self content\n        (targetInLock && (endTarget.contains(target) || endTarget === target)));\n    // handle epsilon around 0 (non standard zoom levels)\n    if (isDeltaPositive &&\n        ((noOverscroll && Math.abs(availableScroll) < 1) || (!noOverscroll && delta > availableScroll))) {\n        shouldCancelScroll = true;\n    }\n    else if (!isDeltaPositive &&\n        ((noOverscroll && Math.abs(availableScrollTop) < 1) || (!noOverscroll && -delta > availableScrollTop))) {\n        shouldCancelScroll = true;\n    }\n    return shouldCancelScroll;\n};\n"],"names":["alwaysContainsScroll","node","elementCanBeScrolled","overflow","styles","elementCouldBeVScrolled","elementCouldBeHScrolled","locationCouldBeScrolled","axis","ownerDocument","current","isScrollable","elementCouldBeScrolled","_a","getScrollVariables","scrollHeight","clientHeight","getVScrollVariables","scrollTop","getHScrollVariables","scrollLeft","scrollWidth","clientWidth","getDirectionFactor","direction","handleScroll","endTarget","event","sourceDelta","noOverscroll","directionFactor","delta","target","targetInLock","shouldCancelScroll","isDeltaPositive","availableScroll","availableScrollTop","position","scroll_1","capacity","elementScroll","parent_1"],"mappings":"AAAA,IAAIA,IAAuB,SAAUC,GAAM;AAEvC,SAAOA,EAAK,YAAY;AAC5B,GACIC,IAAuB,SAAUD,GAAME,GAAU;AACjD,MAAI,EAAEF,aAAgB;AAClB,WAAO;AAEX,MAAIG,IAAS,OAAO,iBAAiBH,CAAI;AACzC;AAAA;AAAA,IAEAG,EAAOD,CAAQ,MAAM;AAAA,IAEjB,EAAEC,EAAO,cAAcA,EAAO,aAAa,CAACJ,EAAqBC,CAAI,KAAKG,EAAOD,CAAQ,MAAM;AAAA;AACvG,GACIE,IAA0B,SAAUJ,GAAM;AAAE,SAAOC,EAAqBD,GAAM,WAAW;AAAI,GAC7FK,IAA0B,SAAUL,GAAM;AAAE,SAAOC,EAAqBD,GAAM,WAAW;AAAI,GACtFM,IAA0B,SAAUC,GAAMP,GAAM;AACvD,MAAIQ,IAAgBR,EAAK,eACrBS,IAAUT;AACd,KAAG;AAEC,IAAI,OAAO,aAAe,OAAeS,aAAmB,eACxDA,IAAUA,EAAQ;AAEtB,QAAIC,IAAeC,EAAuBJ,GAAME,CAAO;AACvD,QAAIC,GAAc;AACd,UAAIE,IAAKC,EAAmBN,GAAME,CAAO,GAAGK,IAAeF,EAAG,CAAC,GAAGG,IAAeH,EAAG,CAAC;AACrF,UAAIE,IAAeC;AACf,eAAO;AAAA,IAEvB;AACQ,IAAAN,IAAUA,EAAQ;AAAA,EAC1B,SAAaA,KAAWA,MAAYD,EAAc;AAC9C,SAAO;AACX,GACIQ,IAAsB,SAAUJ,GAAI;AACpC,MAAIK,IAAYL,EAAG,WAAWE,IAAeF,EAAG,cAAcG,IAAeH,EAAG;AAChF,SAAO;AAAA,IACHK;AAAA,IACAH;AAAA,IACAC;AAAA,EACH;AACL,GACIG,IAAsB,SAAUN,GAAI;AACpC,MAAIO,IAAaP,EAAG,YAAYQ,IAAcR,EAAG,aAAaS,IAAcT,EAAG;AAC/E,SAAO;AAAA,IACHO;AAAA,IACAC;AAAA,IACAC;AAAA,EACH;AACL,GACIV,IAAyB,SAAUJ,GAAMP,GAAM;AAC/C,SAAOO,MAAS,MAAMH,EAAwBJ,CAAI,IAAIK,EAAwBL,CAAI;AACtF,GACIa,IAAqB,SAAUN,GAAMP,GAAM;AAC3C,SAAOO,MAAS,MAAMS,EAAoBhB,CAAI,IAAIkB,EAAoBlB,CAAI;AAC9E,GACIsB,IAAqB,SAAUf,GAAMgB,GAAW;AAMhD,SAAOhB,MAAS,OAAOgB,MAAc,QAAQ,KAAK;AACtD,GACWC,IAAe,SAAUjB,GAAMkB,GAAWC,GAAOC,GAAaC,GAAc;AACnF,MAAIC,IAAkBP,EAAmBf,GAAM,OAAO,iBAAiBkB,CAAS,EAAE,SAAS,GACvFK,IAAQD,IAAkBF,GAE1BI,IAASL,EAAM,QACfM,IAAeP,EAAU,SAASM,CAAM,GACxCE,IAAqB,IACrBC,IAAkBJ,IAAQ,GAC1BK,IAAkB,GAClBC,IAAqB;AACzB,KAAG;AACC,QAAI,CAACL;AACD;AAEJ,QAAInB,IAAKC,EAAmBN,GAAMwB,CAAM,GAAGM,IAAWzB,EAAG,CAAC,GAAG0B,IAAW1B,EAAG,CAAC,GAAG2B,IAAW3B,EAAG,CAAC,GAC1F4B,IAAgBF,IAAWC,IAAWV,IAAkBQ;AAC5D,KAAIA,KAAYG,MACR7B,EAAuBJ,GAAMwB,CAAM,MACnCI,KAAmBK,GACnBJ,KAAsBC;AAG9B,QAAII,IAAWV,EAAO;AAGtB,IAAAA,IAAUU,KAAYA,EAAS,aAAa,KAAK,yBAAyBA,EAAS,OAAOA;AAAA,EAC7F;AAAA;AAAA,IAEA,CAACT,KAAgBD,MAAW,SAAS;AAAA,IAEjCC,MAAiBP,EAAU,SAASM,CAAM,KAAKN,MAAcM;AAAA;AAElE,UAAIG,KACkB,KAAK,IAAIC,CAAe,IAAI,KAGzC,CAACD,KACY,KAAK,IAAIE,CAAkB,IAAI,OACjDH,IAAqB,KAElBA;AACX;","x_google_ignoreList":[0]}