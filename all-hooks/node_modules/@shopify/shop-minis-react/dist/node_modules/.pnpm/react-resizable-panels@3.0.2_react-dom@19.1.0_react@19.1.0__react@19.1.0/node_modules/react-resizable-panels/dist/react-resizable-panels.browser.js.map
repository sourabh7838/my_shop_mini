{"version":3,"file":"react-resizable-panels.browser.js","sources":["../../../../../../../node_modules/.pnpm/react-resizable-panels@3.0.2_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/react-resizable-panels/dist/react-resizable-panels.browser.js"],"sourcesContent":["import * as React from 'react';\nimport { createContext, useLayoutEffect, useRef, forwardRef, createElement, useContext, useImperativeHandle, useState, useCallback, useEffect, useMemo } from 'react';\n\n// The \"contextmenu\" event is not supported as a PointerEvent in all browsers yet, so MouseEvent still need to be handled\n\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\n\nconst DATA_ATTRIBUTES = {\n  group: \"data-panel-group\",\n  groupDirection: \"data-panel-group-direction\",\n  groupId: \"data-panel-group-id\",\n  panel: \"data-panel\",\n  panelCollapsible: \"data-panel-collapsible\",\n  panelId: \"data-panel-id\",\n  panelSize: \"data-panel-size\",\n  resizeHandle: \"data-resize-handle\",\n  resizeHandleActive: \"data-resize-handle-active\",\n  resizeHandleEnabled: \"data-panel-resize-handle-enabled\",\n  resizeHandleId: \"data-panel-resize-handle-id\",\n  resizeHandleState: \"data-resize-handle-state\"\n};\nconst PRECISION = 10;\n\nconst useIsomorphicLayoutEffect = useLayoutEffect ;\n\nconst useId = React[\"useId\".toString()];\nconst wrappedUseId = typeof useId === \"function\" ? useId : () => null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n  const idFromUseId = wrappedUseId();\n  const idRef = useRef(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n  return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;\n}\n\nfunction PanelWithForwardedRef({\n  children,\n  className: classNameFromProps = \"\",\n  collapsedSize,\n  collapsible,\n  defaultSize,\n  forwardedRef,\n  id: idFromProps,\n  maxSize,\n  minSize,\n  onCollapse,\n  onExpand,\n  onResize,\n  order,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`);\n  }\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    reevaluatePanelConstraints,\n    registerPanel,\n    resizePanel,\n    unregisterPanel\n  } = context;\n  const panelId = useUniqueId(idFromProps);\n  const panelDataRef = useRef({\n    callbacks: {\n      onCollapse,\n      onExpand,\n      onResize\n    },\n    constraints: {\n      collapsedSize,\n      collapsible,\n      defaultSize,\n      maxSize,\n      minSize\n    },\n    id: panelId,\n    idIsFromProps: idFromProps !== undefined,\n    order\n  });\n  useRef({\n    didLogMissingDefaultSizeWarning: false\n  });\n  useIsomorphicLayoutEffect(() => {\n    const {\n      callbacks,\n      constraints\n    } = panelDataRef.current;\n    const prevConstraints = {\n      ...constraints\n    };\n    panelDataRef.current.id = panelId;\n    panelDataRef.current.idIsFromProps = idFromProps !== undefined;\n    panelDataRef.current.order = order;\n    callbacks.onCollapse = onCollapse;\n    callbacks.onExpand = onExpand;\n    callbacks.onResize = onResize;\n    constraints.collapsedSize = collapsedSize;\n    constraints.collapsible = collapsible;\n    constraints.defaultSize = defaultSize;\n    constraints.maxSize = maxSize;\n    constraints.minSize = minSize;\n\n    // If constraints have changed, we should revisit panel sizes.\n    // This is uncommon but may happen if people are trying to implement pixel based constraints.\n    if (prevConstraints.collapsedSize !== constraints.collapsedSize || prevConstraints.collapsible !== constraints.collapsible || prevConstraints.maxSize !== constraints.maxSize || prevConstraints.minSize !== constraints.minSize) {\n      reevaluatePanelConstraints(panelDataRef.current, prevConstraints);\n    }\n  });\n  useIsomorphicLayoutEffect(() => {\n    const panelData = panelDataRef.current;\n    registerPanel(panelData);\n    return () => {\n      unregisterPanel(panelData);\n    };\n  }, [order, panelId, registerPanel, unregisterPanel]);\n  useImperativeHandle(forwardedRef, () => ({\n    collapse: () => {\n      collapsePanel(panelDataRef.current);\n    },\n    expand: minSize => {\n      expandPanel(panelDataRef.current, minSize);\n    },\n    getId() {\n      return panelId;\n    },\n    getSize() {\n      return getPanelSize(panelDataRef.current);\n    },\n    isCollapsed() {\n      return isPanelCollapsed(panelDataRef.current);\n    },\n    isExpanded() {\n      return !isPanelCollapsed(panelDataRef.current);\n    },\n    resize: size => {\n      resizePanel(panelDataRef.current, size);\n    }\n  }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel]);\n  const style = getPanelStyle(panelDataRef.current, defaultSize);\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: panelId,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    [DATA_ATTRIBUTES.groupId]: groupId,\n    [DATA_ATTRIBUTES.panel]: \"\",\n    [DATA_ATTRIBUTES.panelCollapsible]: collapsible || undefined,\n    [DATA_ATTRIBUTES.panelId]: panelId,\n    [DATA_ATTRIBUTES.panelSize]: parseFloat(\"\" + style.flexGrow).toFixed(1)\n  });\n}\nconst Panel = forwardRef((props, ref) => createElement(PanelWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n\nlet nonce;\nfunction getNonce() {\n  return nonce;\n}\nfunction setNonce(value) {\n  nonce = value;\n}\n\nlet currentCursorStyle = null;\nlet enabled = true;\nlet prevRuleIndex = -1;\nlet styleElement = null;\nfunction disableGlobalCursorStyles() {\n  enabled = false;\n}\nfunction enableGlobalCursorStyles() {\n  enabled = true;\n}\nfunction getCursorStyle(state, constraintFlags) {\n  if (constraintFlags) {\n    const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;\n    const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;\n    const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;\n    const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;\n    if (horizontalMin) {\n      if (verticalMin) {\n        return \"se-resize\";\n      } else if (verticalMax) {\n        return \"ne-resize\";\n      } else {\n        return \"e-resize\";\n      }\n    } else if (horizontalMax) {\n      if (verticalMin) {\n        return \"sw-resize\";\n      } else if (verticalMax) {\n        return \"nw-resize\";\n      } else {\n        return \"w-resize\";\n      }\n    } else if (verticalMin) {\n      return \"s-resize\";\n    } else if (verticalMax) {\n      return \"n-resize\";\n    }\n  }\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"intersection\":\n      return \"move\";\n    case \"vertical\":\n      return \"ns-resize\";\n  }\n}\nfunction resetGlobalCursorStyle() {\n  if (styleElement !== null) {\n    document.head.removeChild(styleElement);\n    currentCursorStyle = null;\n    styleElement = null;\n    prevRuleIndex = -1;\n  }\n}\nfunction setGlobalCursorStyle(state, constraintFlags) {\n  var _styleElement$sheet$i, _styleElement$sheet2;\n  if (!enabled) {\n    return;\n  }\n  const style = getCursorStyle(state, constraintFlags);\n  if (currentCursorStyle === style) {\n    return;\n  }\n  currentCursorStyle = style;\n  if (styleElement === null) {\n    styleElement = document.createElement(\"style\");\n    const nonce = getNonce();\n    if (nonce) {\n      styleElement.setAttribute(\"nonce\", nonce);\n    }\n    document.head.appendChild(styleElement);\n  }\n  if (prevRuleIndex >= 0) {\n    var _styleElement$sheet;\n    (_styleElement$sheet = styleElement.sheet) === null || _styleElement$sheet === void 0 ? void 0 : _styleElement$sheet.removeRule(prevRuleIndex);\n  }\n  prevRuleIndex = (_styleElement$sheet$i = (_styleElement$sheet2 = styleElement.sheet) === null || _styleElement$sheet2 === void 0 ? void 0 : _styleElement$sheet2.insertRule(`*{cursor: ${style} !important;}`)) !== null && _styleElement$sheet$i !== void 0 ? _styleElement$sheet$i : -1;\n}\n\nfunction isKeyDown(event) {\n  return event.type === \"keydown\";\n}\nfunction isPointerEvent(event) {\n  return event.type.startsWith(\"pointer\");\n}\nfunction isMouseEvent(event) {\n  return event.type.startsWith(\"mouse\");\n}\n\nfunction getResizeEventCoordinates(event) {\n  if (isPointerEvent(event)) {\n    if (event.isPrimary) {\n      return {\n        x: event.clientX,\n        y: event.clientY\n      };\n    }\n  } else if (isMouseEvent(event)) {\n    return {\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n  return {\n    x: Infinity,\n    y: Infinity\n  };\n}\n\nfunction getInputType() {\n  if (typeof matchMedia === \"function\") {\n    return matchMedia(\"(pointer:coarse)\").matches ? \"coarse\" : \"fine\";\n  }\n}\n\nfunction intersects(rectOne, rectTwo, strict) {\n  if (strict) {\n    return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;\n  } else {\n    return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;\n  }\n}\n\n// Forked from NPM stacking-order@2.0.0\n\n/**\n * Determine which of two nodes appears in front of the other —\n * if `a` is in front, returns 1, otherwise returns -1\n * @param {HTMLElement | SVGElement} a\n * @param {HTMLElement | SVGElement} b\n */\nfunction compare(a, b) {\n  if (a === b) throw new Error(\"Cannot compare node with itself\");\n  const ancestors = {\n    a: get_ancestors(a),\n    b: get_ancestors(b)\n  };\n  let common_ancestor;\n\n  // remove shared ancestors\n  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {\n    a = ancestors.a.pop();\n    b = ancestors.b.pop();\n    common_ancestor = a;\n  }\n  assert(common_ancestor, \"Stacking order can only be calculated for elements with a common ancestor\");\n  const z_indexes = {\n    a: get_z_index(find_stacking_context(ancestors.a)),\n    b: get_z_index(find_stacking_context(ancestors.b))\n  };\n  if (z_indexes.a === z_indexes.b) {\n    const children = common_ancestor.childNodes;\n    const furthest_ancestors = {\n      a: ancestors.a.at(-1),\n      b: ancestors.b.at(-1)\n    };\n    let i = children.length;\n    while (i--) {\n      const child = children[i];\n      if (child === furthest_ancestors.a) return 1;\n      if (child === furthest_ancestors.b) return -1;\n    }\n  }\n  return Math.sign(z_indexes.a - z_indexes.b);\n}\nconst props = /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/;\n\n/** @param {HTMLElement | SVGElement} node */\nfunction is_flex_item(node) {\n  var _get_parent;\n  // @ts-ignore\n  const display = getComputedStyle((_get_parent = get_parent(node)) !== null && _get_parent !== void 0 ? _get_parent : node).display;\n  return display === \"flex\" || display === \"inline-flex\";\n}\n\n/** @param {HTMLElement | SVGElement} node */\nfunction creates_stacking_context(node) {\n  const style = getComputedStyle(node);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n  if (style.position === \"fixed\") return true;\n  // Forked to fix upstream bug https://github.com/Rich-Harris/stacking-order/issues/3\n  // if (\n  //   (style.zIndex !== \"auto\" && style.position !== \"static\") ||\n  //   is_flex_item(node)\n  // )\n  if (style.zIndex !== \"auto\" && (style.position !== \"static\" || is_flex_item(node))) return true;\n  if (+style.opacity < 1) return true;\n  if (\"transform\" in style && style.transform !== \"none\") return true;\n  if (\"webkitTransform\" in style && style.webkitTransform !== \"none\") return true;\n  if (\"mixBlendMode\" in style && style.mixBlendMode !== \"normal\") return true;\n  if (\"filter\" in style && style.filter !== \"none\") return true;\n  if (\"webkitFilter\" in style && style.webkitFilter !== \"none\") return true;\n  if (\"isolation\" in style && style.isolation === \"isolate\") return true;\n  if (props.test(style.willChange)) return true;\n  // @ts-expect-error\n  if (style.webkitOverflowScrolling === \"touch\") return true;\n  return false;\n}\n\n/** @param {(HTMLElement| SVGElement)[]} nodes */\nfunction find_stacking_context(nodes) {\n  let i = nodes.length;\n  while (i--) {\n    const node = nodes[i];\n    assert(node, \"Missing node\");\n    if (creates_stacking_context(node)) return node;\n  }\n  return null;\n}\n\n/** @param {HTMLElement | SVGElement} node */\nfunction get_z_index(node) {\n  return node && Number(getComputedStyle(node).zIndex) || 0;\n}\n\n/** @param {HTMLElement} node */\nfunction get_ancestors(node) {\n  const ancestors = [];\n  while (node) {\n    ancestors.push(node);\n    // @ts-ignore\n    node = get_parent(node);\n  }\n  return ancestors; // [ node, ... <body>, <html>, document ]\n}\n\n/** @param {HTMLElement} node */\nfunction get_parent(node) {\n  const {\n    parentNode\n  } = node;\n  if (parentNode && parentNode instanceof ShadowRoot) {\n    return parentNode.host;\n  }\n  return parentNode;\n}\n\nconst EXCEEDED_HORIZONTAL_MIN = 0b0001;\nconst EXCEEDED_HORIZONTAL_MAX = 0b0010;\nconst EXCEEDED_VERTICAL_MIN = 0b0100;\nconst EXCEEDED_VERTICAL_MAX = 0b1000;\nconst isCoarsePointer = getInputType() === \"coarse\";\nlet intersectingHandles = [];\nlet isPointerDown = false;\nlet ownerDocumentCounts = new Map();\nlet panelConstraintFlags = new Map();\nconst registeredResizeHandlers = new Set();\nfunction registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {\n  var _ownerDocumentCounts$;\n  const {\n    ownerDocument\n  } = element;\n  const data = {\n    direction,\n    element,\n    hitAreaMargins,\n    setResizeHandlerState\n  };\n  const count = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;\n  ownerDocumentCounts.set(ownerDocument, count + 1);\n  registeredResizeHandlers.add(data);\n  updateListeners();\n  return function unregisterResizeHandle() {\n    var _ownerDocumentCounts$2;\n    panelConstraintFlags.delete(resizeHandleId);\n    registeredResizeHandlers.delete(data);\n    const count = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;\n    ownerDocumentCounts.set(ownerDocument, count - 1);\n    updateListeners();\n    if (count === 1) {\n      ownerDocumentCounts.delete(ownerDocument);\n    }\n\n    // If the resize handle that is currently unmounting is intersecting with the pointer,\n    // update the global pointer to account for the change\n    if (intersectingHandles.includes(data)) {\n      const index = intersectingHandles.indexOf(data);\n      if (index >= 0) {\n        intersectingHandles.splice(index, 1);\n      }\n      updateCursor();\n\n      // Also instruct the handle to stop dragging; this prevents the parent group from being left in an inconsistent state\n      // See github.com/bvaughn/react-resizable-panels/issues/402\n      setResizeHandlerState(\"up\", true, null);\n    }\n  };\n}\nfunction handlePointerDown(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  isPointerDown = true;\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateListeners();\n  if (intersectingHandles.length > 0) {\n    updateResizeHandlerStates(\"down\", event);\n    event.preventDefault();\n    if (!isWithinResizeHandle(target)) {\n      event.stopImmediatePropagation();\n    }\n  }\n}\nfunction handlePointerMove(event) {\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n\n  // Edge case (see #340)\n  // Detect when the pointer has been released outside an iframe on a different domain\n  if (isPointerDown && event.buttons === 0) {\n    isPointerDown = false;\n    updateResizeHandlerStates(\"up\", event);\n  }\n  if (!isPointerDown) {\n    const {\n      target\n    } = event;\n\n    // Recalculate intersecting handles whenever the pointer moves, except if it has already been pressed\n    // at that point, the handles may not move with the pointer (depending on constraints)\n    // but the same set of active handles should be locked until the pointer is released\n    recalculateIntersectingHandles({\n      target,\n      x,\n      y\n    });\n  }\n  updateResizeHandlerStates(\"move\", event);\n\n  // Update cursor based on return value(s) from active handles\n  updateCursor();\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n  }\n}\nfunction handlePointerUp(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  panelConstraintFlags.clear();\n  isPointerDown = false;\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n    if (!isWithinResizeHandle(target)) {\n      event.stopImmediatePropagation();\n    }\n  }\n  updateResizeHandlerStates(\"up\", event);\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateCursor();\n  updateListeners();\n}\nfunction isWithinResizeHandle(element) {\n  let currentElement = element;\n  while (currentElement) {\n    if (currentElement.hasAttribute(DATA_ATTRIBUTES.resizeHandle)) {\n      return true;\n    }\n    currentElement = currentElement.parentElement;\n  }\n  return false;\n}\nfunction recalculateIntersectingHandles({\n  target,\n  x,\n  y\n}) {\n  intersectingHandles.splice(0);\n  let targetElement = null;\n  if (target instanceof HTMLElement || target instanceof SVGElement) {\n    targetElement = target;\n  }\n  registeredResizeHandlers.forEach(data => {\n    const {\n      element: dragHandleElement,\n      hitAreaMargins\n    } = data;\n    const dragHandleRect = dragHandleElement.getBoundingClientRect();\n    const {\n      bottom,\n      left,\n      right,\n      top\n    } = dragHandleRect;\n    const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;\n    const eventIntersects = x >= left - margin && x <= right + margin && y >= top - margin && y <= bottom + margin;\n    if (eventIntersects) {\n      // TRICKY\n      // We listen for pointers events at the root in order to support hit area margins\n      // (determining when the pointer is close enough to an element to be considered a \"hit\")\n      // Clicking on an element \"above\" a handle (e.g. a modal) should prevent a hit though\n      // so at this point we need to compare stacking order of a potentially intersecting drag handle,\n      // and the element that was actually clicked/touched\n      if (targetElement !== null && document.contains(targetElement) && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) &&\n      // Calculating stacking order has a cost, so we should avoid it if possible\n      // That is why we only check potentially intersecting handles,\n      // and why we skip if the event target is within the handle's DOM\n      compare(targetElement, dragHandleElement) > 0) {\n        // If the target is above the drag handle, then we also need to confirm they overlap\n        // If they are beside each other (e.g. a panel and its drag handle) then the handle is still interactive\n        //\n        // It's not enough to compare only the target\n        // The target might be a small element inside of a larger container\n        // (For example, a SPAN or a DIV inside of a larger modal dialog)\n        let currentElement = targetElement;\n        let didIntersect = false;\n        while (currentElement) {\n          if (currentElement.contains(dragHandleElement)) {\n            break;\n          } else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {\n            didIntersect = true;\n            break;\n          }\n          currentElement = currentElement.parentElement;\n        }\n        if (didIntersect) {\n          return;\n        }\n      }\n      intersectingHandles.push(data);\n    }\n  });\n}\nfunction reportConstraintsViolation(resizeHandleId, flag) {\n  panelConstraintFlags.set(resizeHandleId, flag);\n}\nfunction updateCursor() {\n  let intersectsHorizontal = false;\n  let intersectsVertical = false;\n  intersectingHandles.forEach(data => {\n    const {\n      direction\n    } = data;\n    if (direction === \"horizontal\") {\n      intersectsHorizontal = true;\n    } else {\n      intersectsVertical = true;\n    }\n  });\n  let constraintFlags = 0;\n  panelConstraintFlags.forEach(flag => {\n    constraintFlags |= flag;\n  });\n  if (intersectsHorizontal && intersectsVertical) {\n    setGlobalCursorStyle(\"intersection\", constraintFlags);\n  } else if (intersectsHorizontal) {\n    setGlobalCursorStyle(\"horizontal\", constraintFlags);\n  } else if (intersectsVertical) {\n    setGlobalCursorStyle(\"vertical\", constraintFlags);\n  } else {\n    resetGlobalCursorStyle();\n  }\n}\nlet listenersAbortController = new AbortController();\nfunction updateListeners() {\n  listenersAbortController.abort();\n  listenersAbortController = new AbortController();\n  const options = {\n    capture: true,\n    signal: listenersAbortController.signal\n  };\n  if (!registeredResizeHandlers.size) {\n    return;\n  }\n  if (isPointerDown) {\n    if (intersectingHandles.length > 0) {\n      ownerDocumentCounts.forEach((count, ownerDocument) => {\n        const {\n          body\n        } = ownerDocument;\n        if (count > 0) {\n          body.addEventListener(\"contextmenu\", handlePointerUp, options);\n          body.addEventListener(\"pointerleave\", handlePointerMove, options);\n          body.addEventListener(\"pointermove\", handlePointerMove, options);\n        }\n      });\n    }\n    ownerDocumentCounts.forEach((_, ownerDocument) => {\n      const {\n        body\n      } = ownerDocument;\n      body.addEventListener(\"pointerup\", handlePointerUp, options);\n      body.addEventListener(\"pointercancel\", handlePointerUp, options);\n    });\n  } else {\n    ownerDocumentCounts.forEach((count, ownerDocument) => {\n      const {\n        body\n      } = ownerDocument;\n      if (count > 0) {\n        body.addEventListener(\"pointerdown\", handlePointerDown, options);\n        body.addEventListener(\"pointermove\", handlePointerMove, options);\n      }\n    });\n  }\n}\nfunction updateResizeHandlerStates(action, event) {\n  registeredResizeHandlers.forEach(data => {\n    const {\n      setResizeHandlerState\n    } = data;\n    const isActive = intersectingHandles.includes(data);\n    setResizeHandlerState(action, isActive, event);\n  });\n}\n\nfunction useForceUpdate() {\n  const [_, setCount] = useState(0);\n  return useCallback(() => setCount(prevCount => prevCount + 1), []);\n}\n\nfunction assert(expectedCondition, message) {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\n\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\nfunction fuzzyNumbersEqual$1(actual, expected, fractionDigits = PRECISION) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n\nfunction fuzzyLayoutsEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Panel size must be in percentages; pixel values should be pre-converted\nfunction resizePanel({\n  panelConstraints: panelConstraintsArray,\n  panelIndex,\n  size\n}) {\n  const panelConstraints = panelConstraintsArray[panelIndex];\n  assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);\n  let {\n    collapsedSize = 0,\n    collapsible,\n    maxSize = 100,\n    minSize = 0\n  } = panelConstraints;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction adjustLayoutByDelta({\n  delta,\n  initialLayout,\n  panelConstraints: panelConstraintsArray,\n  pivotIndices,\n  prevLayout,\n  trigger\n}) {\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialLayout;\n  }\n  const nextLayout = [...initialLayout];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  assert(firstPivotIndex != null, \"Invalid first pivot index\");\n  assert(secondPivotIndex != null, \"Invalid second pivot index\");\n  let deltaApplied = 0;\n\n  // const DEBUG = [];\n  // DEBUG.push(`adjustLayoutByDelta()`);\n  // DEBUG.push(`  initialLayout: ${initialLayout.join(\", \")}`);\n  // DEBUG.push(`  prevLayout: ${prevLayout.join(\", \")}`);\n  // DEBUG.push(`  delta: ${delta}`);\n  // DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n  // DEBUG.push(`  trigger: ${trigger}`);\n  // DEBUG.push(\"\");\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel(s) immediately after the resize handle should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel(s) immediately before the resize handle should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resize handle.\n\n  {\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n    // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n    if (trigger === \"keyboard\") {\n      {\n        // Check if we should expand a collapsed panel\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `Panel constraints not found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 1: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, collapsedSize)) {\n            const localDelta = minSize - prevSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n\n      {\n        // Check if we should collapse a panel at its minimum size\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `No panel constraints found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 2: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, minSize)) {\n            const localDelta = prevSize - collapsedSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n    }\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Pre-calculate max available delta in the opposite direction of our pivot.\n    // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n    // If this amount is less than the requested delta, adjust the requested delta.\n    // If this amount is greater than the requested delta, that's useful information too–\n    // as an expanding panel might change from collapsed to min size.\n\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n\n    // DEBUG.push(\"pre calc...\");\n    while (true) {\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const maxSafeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: 100\n      });\n      const delta = maxSafeSize - prevSize;\n      // DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n\n      maxAvailableDelta += delta;\n      index += increment;\n      if (index < 0 || index >= panelConstraintsArray.length) {\n        break;\n      }\n    }\n\n    // DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    // DEBUG.push(`  -> adjusted delta: ${delta}`);\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panelConstraintsArray.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const unsafeSize = prevSize - deltaRemaining;\n      const safeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n        deltaApplied += prevSize - safeSize;\n        nextLayout[index] = safeSize;\n        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  // DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n  if (fuzzyLayoutsEqual(prevLayout, nextLayout)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n  {\n    // Now distribute the applied delta to the panels in the other direction\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize = initialLayout[pivotIndex];\n    assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);\n    const unsafeSize = prevSize + deltaApplied;\n    const safeSize = resizePanel({\n      panelConstraints: panelConstraintsArray,\n      panelIndex: pivotIndex,\n      size: unsafeSize\n    });\n\n    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n    nextLayout[pivotIndex] = safeSize;\n\n    // Edge case where expanding or contracting one panel caused another one to change collapsed state\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex;\n      while (index >= 0 && index < panelConstraintsArray.length) {\n        const prevSize = nextLayout[index];\n        assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n        const unsafeSize = prevSize + deltaRemaining;\n        const safeSize = resizePanel({\n          panelConstraints: panelConstraintsArray,\n          panelIndex: index,\n          size: unsafeSize\n        });\n        if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n          deltaRemaining -= safeSize - prevSize;\n          nextLayout[index] = safeSize;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  // DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n  // DEBUG.push(`total size: ${totalSize}`);\n\n  // If our new layout doesn't add up to 100%, that means the requested delta can't be applied\n  // In that case, fall back to our most recent valid layout\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n\n  // console.log(DEBUG.join(\"\\n\"));\n  return nextLayout;\n}\n\nfunction calculateAriaValues({\n  layout,\n  panelsArray,\n  pivotIndices\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n  const firstIndex = pivotIndices[0];\n  assert(firstIndex != null, \"No pivot index found\");\n\n  // A panel's effective min/max sizes also need to account for other panel's sizes.\n  panelsArray.forEach((panelData, index) => {\n    const {\n      constraints\n    } = panelData;\n    const {\n      maxSize = 100,\n      minSize = 0\n    } = constraints;\n    if (index === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = layout[firstIndex];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\n\nfunction getResizeHandleElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[${DATA_ATTRIBUTES.resizeHandleId}][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getResizeHandleElementIndex(groupId, id, scope = document) {\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handles.findIndex(handle => handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId) === id);\n  return index !== null && index !== void 0 ? index : null;\n}\n\nfunction determinePivotIndices(groupId, dragHandleId, panelGroupElement) {\n  const index = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);\n  return index != null ? [index, index + 1] : [-1, -1];\n}\n\nfunction isHTMLElement(target) {\n  if (target instanceof HTMLElement) {\n    return true;\n  }\n\n  // Fallback to duck typing to handle edge case of portals within a popup window\n  return typeof target === \"object\" && target !== null && \"tagName\" in target && \"getAttribute\" in target;\n}\n\nfunction getPanelGroupElement(id, rootElement = document) {\n  // If the root element is the PanelGroup\n  if (isHTMLElement(rootElement) && rootElement.dataset.panelGroupId == id) {\n    return rootElement;\n  }\n\n  // Else query children\n  const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandleElement(id, scope = document) {\n  const element = scope.querySelector(`[${DATA_ATTRIBUTES.resizeHandleId}=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {\n  var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;\n  const handle = getResizeHandleElement(handleId, scope);\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handle ? handles.indexOf(handle) : -1;\n  const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;\n  const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;\n  return [idBefore, idAfter];\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  eagerValuesRef,\n  groupId,\n  layout,\n  panelDataArray,\n  panelGroupElement,\n  setLayout\n}) {\n  useRef({\n    didWarnAboutMissingResizeHandle: false\n  });\n  useIsomorphicLayoutEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const resizeHandleElements = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    for (let index = 0; index < panelDataArray.length - 1; index++) {\n      const {\n        valueMax,\n        valueMin,\n        valueNow\n      } = calculateAriaValues({\n        layout,\n        panelsArray: panelDataArray,\n        pivotIndices: [index, index + 1]\n      });\n      const resizeHandleElement = resizeHandleElements[index];\n      if (resizeHandleElement == null) ; else {\n        const panelData = panelDataArray[index];\n        assert(panelData, `No panel data found for index \"${index}\"`);\n        resizeHandleElement.setAttribute(\"aria-controls\", panelData.id);\n        resizeHandleElement.setAttribute(\"aria-valuemax\", \"\" + Math.round(valueMax));\n        resizeHandleElement.setAttribute(\"aria-valuemin\", \"\" + Math.round(valueMin));\n        resizeHandleElement.setAttribute(\"aria-valuenow\", valueNow != null ? \"\" + Math.round(valueNow) : \"\");\n      }\n    }\n    return () => {\n      resizeHandleElements.forEach((resizeHandleElement, index) => {\n        resizeHandleElement.removeAttribute(\"aria-controls\");\n        resizeHandleElement.removeAttribute(\"aria-valuemax\");\n        resizeHandleElement.removeAttribute(\"aria-valuemin\");\n        resizeHandleElement.removeAttribute(\"aria-valuenow\");\n      });\n    };\n  }, [groupId, layout, panelDataArray, panelGroupElement]);\n  useEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const eagerValues = eagerValuesRef.current;\n    assert(eagerValues, `Eager values not found`);\n    const {\n      panelDataArray\n    } = eagerValues;\n    const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\n    const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    assert(handles, `No resize handles found for group id \"${groupId}\"`);\n    const cleanupFunctions = handles.map(handle => {\n      const handleId = handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId);\n      assert(handleId, `Resize handle element has no handle id attribute`);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray, panelGroupElement);\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n      const onKeyDown = event => {\n        if (event.defaultPrevented) {\n          return;\n        }\n        switch (event.key) {\n          case \"Enter\":\n            {\n              event.preventDefault();\n              const index = panelDataArray.findIndex(panelData => panelData.id === idBefore);\n              if (index >= 0) {\n                const panelData = panelDataArray[index];\n                assert(panelData, `No panel data found for index ${index}`);\n                const size = layout[index];\n                const {\n                  collapsedSize = 0,\n                  collapsible,\n                  minSize = 0\n                } = panelData.constraints;\n                if (size != null && collapsible) {\n                  const nextLayout = adjustLayoutByDelta({\n                    delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n                    initialLayout: layout,\n                    panelConstraints: panelDataArray.map(panelData => panelData.constraints),\n                    pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),\n                    prevLayout: layout,\n                    trigger: \"keyboard\"\n                  });\n                  if (layout !== nextLayout) {\n                    setLayout(nextLayout);\n                  }\n                }\n              }\n              break;\n            }\n        }\n      };\n      handle.addEventListener(\"keydown\", onKeyDown);\n      return () => {\n        handle.removeEventListener(\"keydown\", onKeyDown);\n      };\n    });\n    return () => {\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction());\n    };\n  }, [panelGroupElement, committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, setLayout]);\n}\n\nfunction areEqual(arrayA, arrayB) {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getResizeEventCursorPosition(direction, event) {\n  const isHorizontal = direction === \"horizontal\";\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  return isHorizontal ? x : y;\n}\n\nfunction calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {\n  const isHorizontal = direction === \"horizontal\";\n  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);\n  assert(handleElement, `No resize handle element found for id \"${dragHandleId}\"`);\n  const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);\n  assert(groupId, `Resize handle element has no group id attribute`);\n  let {\n    initialCursorPosition\n  } = initialDragState;\n  const cursorPosition = getResizeEventCursorPosition(direction, event);\n  const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n  assert(groupElement, `No group element found for id \"${groupId}\"`);\n  const groupRect = groupElement.getBoundingClientRect();\n  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n  const offsetPixels = cursorPosition - initialCursorPosition;\n  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n  return offsetPercentage;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n    let delta = 0;\n    if (event.shiftKey) {\n      delta = 100;\n    } else if (keyboardResizeBy != null) {\n      delta = keyboardResizeBy;\n    } else {\n      delta = 10;\n    }\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = 100;\n        break;\n      case \"Home\":\n        movement = -100;\n        break;\n    }\n    return movement;\n  } else {\n    if (initialDragState == null) {\n      return 0;\n    }\n    return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);\n  }\n}\n\nfunction calculateUnsafeDefaultLayout({\n  panelDataArray\n}) {\n  const layout = Array(panelDataArray.length);\n  const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n\n  // Distribute default sizes first\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index];\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\n    const {\n      defaultSize\n    } = panelConstraints;\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      layout[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n\n  // Remaining size should be distributed evenly between panels without default sizes\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index];\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\n    const {\n      defaultSize\n    } = panelConstraints;\n    if (defaultSize != null) {\n      continue;\n    }\n    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    layout[index] = size;\n    remainingSize -= size;\n  }\n  return layout;\n}\n\n// Layout should be pre-converted into percentages\nfunction callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {\n  layout.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    assert(panelData, `Panel data not found for index ${index}`);\n    const {\n      callbacks,\n      constraints,\n      id: panelId\n    } = panelData;\n    const {\n      collapsedSize = 0,\n      collapsible\n    } = constraints;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap[panelId] = size;\n      const {\n        onCollapse,\n        onExpand,\n        onResize\n      } = callbacks;\n      if (onResize) {\n        onResize(size, lastNotifiedSize);\n      }\n      if (collapsible && (onCollapse || onExpand)) {\n        if (onExpand && (lastNotifiedSize == null || fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual$1(size, collapsedSize)) {\n          onExpand();\n        }\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual$1(size, collapsedSize)) {\n          onCollapse();\n        }\n      }\n    }\n  });\n}\n\nfunction compareLayouts(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  } else {\n    for (let index = 0; index < a.length; index++) {\n      if (a[index] != b[index]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// This method returns a number between 1 and 100 representing\n\n// the % of the group's overall space this panel should occupy.\nfunction computePanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  layout,\n  panelData,\n  panelIndex,\n  precision = 3\n}) {\n  const size = layout[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    // Initial render (before panels have registered themselves)\n    // In order to support server rendering, fall back to default size if provided\n    flexGrow = defaultSize != undefined ? defaultSize.toPrecision(precision) : \"1\";\n  } else if (panelData.length === 1) {\n    // Special case: Single panel group should always fill full width/height\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : undefined\n  };\n}\n\nfunction debounce(callback, durationMs = 10) {\n  let timeoutId = null;\n  let callable = (...args) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n  return callable;\n}\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = name => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name, value) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\n\nfunction getPanelGroupKey(autoSaveId) {\n  return `react-resizable-panels:${autoSaveId}`;\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using the min/max size attributes should work well enough as a backup.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getPanelKey(panels) {\n  return panels.map(panel => {\n    const {\n      constraints,\n      id,\n      idIsFromProps,\n      order\n    } = panel;\n    if (idIsFromProps) {\n      return id;\n    } else {\n      return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);\n    }\n  }).sort((a, b) => a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n  try {\n    const panelGroupKey = getPanelGroupKey(autoSaveId);\n    const serialized = storage.getItem(panelGroupKey);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n  return null;\n}\nfunction loadPanelGroupState(autoSaveId, panels, storage) {\n  var _loadSerializedPanelG, _state$panelKey;\n  const state = (_loadSerializedPanelG = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG !== void 0 ? _loadSerializedPanelG : {};\n  const panelKey = getPanelKey(panels);\n  return (_state$panelKey = state[panelKey]) !== null && _state$panelKey !== void 0 ? _state$panelKey : null;\n}\nfunction savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {\n  var _loadSerializedPanelG2;\n  const panelGroupKey = getPanelGroupKey(autoSaveId);\n  const panelKey = getPanelKey(panels);\n  const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};\n  state[panelKey] = {\n    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),\n    layout: sizes\n  };\n  try {\n    storage.setItem(panelGroupKey, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction validatePanelGroupLayout({\n  layout: prevLayout,\n  panelConstraints\n}) {\n  const nextLayout = [...prevLayout];\n  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);\n\n  // Validate layout expectations\n  if (nextLayout.length !== panelConstraints.length) {\n    throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map(size => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100) && nextLayout.length > 0) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const unsafeSize = nextLayout[index];\n      assert(unsafeSize != null, `No layout data found for index ${index}`);\n      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n\n  // First pass: Validate the proposed layout given each panel's constraints\n  for (let index = 0; index < panelConstraints.length; index++) {\n    const unsafeSize = nextLayout[index];\n    assert(unsafeSize != null, `No layout data found for index ${index}`);\n    const safeSize = resizePanel({\n      panelConstraints,\n      panelIndex: index,\n      size: unsafeSize\n    });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const prevSize = nextLayout[index];\n      assert(prevSize != null, `No layout data found for index ${index}`);\n      const unsafeSize = prevSize + remainingSize;\n      const safeSize = resizePanel({\n        panelConstraints,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (prevSize !== safeSize) {\n        remainingSize -= safeSize - prevSize;\n        nextLayout[index] = safeSize;\n\n        // Once we've used up the remainder, bail\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextLayout;\n}\n\nconst LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nconst defaultStorage = {\n  getItem: name => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name, value) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  }\n};\nconst debounceMap = {};\nfunction PanelGroupWithForwardedRef({\n  autoSaveId = null,\n  children,\n  className: classNameFromProps = \"\",\n  direction,\n  forwardedRef,\n  id: idFromProps = null,\n  onLayout = null,\n  keyboardResizeBy = null,\n  storage = defaultStorage,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const groupId = useUniqueId(idFromProps);\n  const panelGroupElementRef = useRef(null);\n  const [dragState, setDragState] = useState(null);\n  const [layout, setLayout] = useState([]);\n  const forceUpdate = useForceUpdate();\n  const panelIdToLastNotifiedSizeMapRef = useRef({});\n  const panelSizeBeforeCollapseRef = useRef(new Map());\n  const prevDeltaRef = useRef(0);\n  const committedValuesRef = useRef({\n    autoSaveId,\n    direction,\n    dragState,\n    id: groupId,\n    keyboardResizeBy,\n    onLayout,\n    storage\n  });\n  const eagerValuesRef = useRef({\n    layout,\n    panelDataArray: [],\n    panelDataArrayChanged: false\n  });\n  useRef({\n    didLogIdAndOrderWarning: false,\n    didLogPanelConstraintsWarning: false,\n    prevPanelIds: []\n  });\n  useImperativeHandle(forwardedRef, () => ({\n    getId: () => committedValuesRef.current.id,\n    getLayout: () => {\n      const {\n        layout\n      } = eagerValuesRef.current;\n      return layout;\n    },\n    setLayout: unsafeLayout => {\n      const {\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const safeLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, safeLayout)) {\n        setLayout(safeLayout);\n        eagerValuesRef.current.layout = safeLayout;\n        if (onLayout) {\n          onLayout(safeLayout);\n        }\n        callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  }), []);\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.autoSaveId = autoSaveId;\n    committedValuesRef.current.direction = direction;\n    committedValuesRef.current.dragState = dragState;\n    committedValuesRef.current.id = groupId;\n    committedValuesRef.current.onLayout = onLayout;\n    committedValuesRef.current.storage = storage;\n  });\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    eagerValuesRef,\n    groupId,\n    layout,\n    panelDataArray: eagerValuesRef.current.panelDataArray,\n    setLayout,\n    panelGroupElement: panelGroupElementRef.current\n  });\n  useEffect(() => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (layout.length === 0 || layout.length !== panelDataArray.length) {\n        return;\n      }\n      let debouncedSave = debounceMap[autoSaveId];\n\n      // Limit the frequency of localStorage updates.\n      if (debouncedSave == null) {\n        debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n        debounceMap[autoSaveId] = debouncedSave;\n      }\n\n      // Clone mutable data before passing to the debounced function,\n      // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n      const clonedPanelDataArray = [...panelDataArray];\n      const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);\n      debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);\n    }\n  }, [autoSaveId, layout, storage]);\n\n  // DEV warnings\n  useEffect(() => {\n  });\n\n  // External APIs are safe to memoize via committed values ref\n  const collapsePanel = useCallback(panelData => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n      if (!fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n        // Store size before collapse;\n        // This is the size that gets restored if the expand() API is used.\n        panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const expandPanel = useCallback((panelData, minSizeOverride) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize = 0,\n        minSize: minSizeFromProps = 0,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      const minSize = minSizeOverride !== null && minSizeOverride !== void 0 ? minSizeOverride : minSizeFromProps;\n      if (fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n        // Restore this panel to the size it was before it was collapsed, if possible.\n        const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);\n        const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const getPanelSize = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return panelSize;\n  }, []);\n\n  // This API should never read from committedValuesRef\n  const getPanelStyle = useCallback((panelData, defaultSize) => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n    return computePanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      layout,\n      panelData: panelDataArray,\n      panelIndex\n    });\n  }, [dragState, layout]);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelCollapsed = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return collapsible === true && fuzzyNumbersEqual$1(panelSize, collapsedSize);\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelExpanded = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n  }, []);\n  const registerPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    panelDataArray.push(panelData);\n    panelDataArray.sort((panelA, panelB) => {\n      const orderA = panelA.order;\n      const orderB = panelB.order;\n      if (orderA == null && orderB == null) {\n        return 0;\n      } else if (orderA == null) {\n        return -1;\n      } else if (orderB == null) {\n        return 1;\n      } else {\n        return orderA - orderB;\n      }\n    });\n    eagerValuesRef.current.panelDataArrayChanged = true;\n    forceUpdate();\n  }, [forceUpdate]);\n\n  // (Re)calculate group layout whenever panels are registered or unregistered.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useIsomorphicLayoutEffect(() => {\n    if (eagerValuesRef.current.panelDataArrayChanged) {\n      eagerValuesRef.current.panelDataArrayChanged = false;\n      const {\n        autoSaveId,\n        onLayout,\n        storage\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n\n      // If this panel has been configured to persist sizing information,\n      // default size should be restored from local storage if possible.\n      let unsafeLayout = null;\n      if (autoSaveId) {\n        const state = loadPanelGroupState(autoSaveId, panelDataArray, storage);\n        if (state) {\n          panelSizeBeforeCollapseRef.current = new Map(Object.entries(state.expandToSizes));\n          unsafeLayout = state.layout;\n        }\n      }\n      if (unsafeLayout == null) {\n        unsafeLayout = calculateUnsafeDefaultLayout({\n          panelDataArray\n        });\n      }\n\n      // Validate even saved layouts in case something has changed since last render\n      // e.g. for pixel groups, this could be the size of the window\n      const nextLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, nextLayout)) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  });\n\n  // Reset the cached layout if hidden by the Activity/Offscreen API\n  useIsomorphicLayoutEffect(() => {\n    const eagerValues = eagerValuesRef.current;\n    return () => {\n      eagerValues.layout = [];\n    };\n  }, []);\n  const registerResizeHandle = useCallback(dragHandleId => {\n    let isRTL = false;\n    const panelGroupElement = panelGroupElementRef.current;\n    if (panelGroupElement) {\n      const style = window.getComputedStyle(panelGroupElement, null);\n      if (style.getPropertyValue(\"direction\") === \"rtl\") {\n        isRTL = true;\n      }\n    }\n    return function resizeHandler(event) {\n      event.preventDefault();\n      const panelGroupElement = panelGroupElementRef.current;\n      if (!panelGroupElement) {\n        return () => null;\n      }\n      const {\n        direction,\n        dragState,\n        id: groupId,\n        keyboardResizeBy,\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const {\n        initialLayout\n      } = dragState !== null && dragState !== void 0 ? dragState : {};\n      const pivotIndices = determinePivotIndices(groupId, dragHandleId, panelGroupElement);\n      let delta = calculateDeltaPercentage(event, dragHandleId, direction, dragState, keyboardResizeBy, panelGroupElement);\n      const isHorizontal = direction === \"horizontal\";\n      if (isHorizontal && isRTL) {\n        delta = -delta;\n      }\n      const panelConstraints = panelDataArray.map(panelData => panelData.constraints);\n      const nextLayout = adjustLayoutByDelta({\n        delta,\n        initialLayout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,\n        panelConstraints,\n        pivotIndices,\n        prevLayout,\n        trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\"\n      });\n      const layoutChanged = !compareLayouts(prevLayout, nextLayout);\n\n      // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n      // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n      if (isPointerEvent(event) || isMouseEvent(event)) {\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n        // In this case, Panel sizes might not change–\n        // but updating cursor in this scenario would cause a flicker.\n        if (prevDeltaRef.current != delta) {\n          prevDeltaRef.current = delta;\n          if (!layoutChanged && delta !== 0) {\n            // If the pointer has moved too far to resize the panel any further, note this so we can update the cursor.\n            // This mimics VS Code behavior.\n            if (isHorizontal) {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);\n            } else {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);\n            }\n          } else {\n            reportConstraintsViolation(dragHandleId, 0);\n          }\n        }\n      }\n      if (layoutChanged) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    };\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const resizePanel = useCallback((panelData, unsafePanelSize) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n    const {\n      panelSize,\n      pivotIndices\n    } = panelDataHelper(panelDataArray, panelData, prevLayout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n    const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n    const nextLayout = adjustLayoutByDelta({\n      delta,\n      initialLayout: prevLayout,\n      panelConstraints: panelConstraintsArray,\n      pivotIndices,\n      prevLayout,\n      trigger: \"imperative-api\"\n    });\n    if (!compareLayouts(prevLayout, nextLayout)) {\n      setLayout(nextLayout);\n      eagerValuesRef.current.layout = nextLayout;\n      if (onLayout) {\n        onLayout(nextLayout);\n      }\n      callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n    }\n  }, []);\n  const reevaluatePanelConstraints = useCallback((panelData, prevConstraints) => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize: prevCollapsedSize = 0,\n      collapsible: prevCollapsible\n    } = prevConstraints;\n    const {\n      collapsedSize: nextCollapsedSize = 0,\n      collapsible: nextCollapsible,\n      maxSize: nextMaxSize = 100,\n      minSize: nextMinSize = 0\n    } = panelData.constraints;\n    const {\n      panelSize: prevPanelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    if (prevPanelSize == null) {\n      // It's possible that the panels in this group have changed since the last render\n      return;\n    }\n    if (prevCollapsible && nextCollapsible && fuzzyNumbersEqual$1(prevPanelSize, prevCollapsedSize)) {\n      if (!fuzzyNumbersEqual$1(prevCollapsedSize, nextCollapsedSize)) {\n        resizePanel(panelData, nextCollapsedSize);\n      }\n    } else if (prevPanelSize < nextMinSize) {\n      resizePanel(panelData, nextMinSize);\n    } else if (prevPanelSize > nextMaxSize) {\n      resizePanel(panelData, nextMaxSize);\n    }\n  }, [resizePanel]);\n\n  // TODO Multiple drag handles can be active at the same time so this API is a bit awkward now\n  const startDragging = useCallback((dragHandleId, event) => {\n    const {\n      direction\n    } = committedValuesRef.current;\n    const {\n      layout\n    } = eagerValuesRef.current;\n    if (!panelGroupElementRef.current) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);\n    assert(handleElement, `Drag handle element not found for id \"${dragHandleId}\"`);\n    const initialCursorPosition = getResizeEventCursorPosition(direction, event);\n    setDragState({\n      dragHandleId,\n      dragHandleRect: handleElement.getBoundingClientRect(),\n      initialCursorPosition,\n      initialLayout: layout\n    });\n  }, []);\n  const stopDragging = useCallback(() => {\n    setDragState(null);\n  }, []);\n  const unregisterPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const index = findPanelDataIndex(panelDataArray, panelData);\n    if (index >= 0) {\n      panelDataArray.splice(index, 1);\n\n      // TRICKY\n      // When a panel is removed from the group, we should delete the most recent prev-size entry for it.\n      // If we don't do this, then a conditionally rendered panel might not call onResize when it's re-mounted.\n      // Strict effects mode makes this tricky though because all panels will be registered, unregistered, then re-registered on mount.\n      delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];\n      eagerValuesRef.current.panelDataArrayChanged = true;\n      forceUpdate();\n    }\n  }, [forceUpdate]);\n  const context = useMemo(() => ({\n    collapsePanel,\n    direction,\n    dragState,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    isPanelExpanded,\n    reevaluatePanelConstraints,\n    registerPanel,\n    registerResizeHandle,\n    resizePanel,\n    startDragging,\n    stopDragging,\n    unregisterPanel,\n    panelGroupElement: panelGroupElementRef.current\n  }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, reevaluatePanelConstraints, registerPanel, registerResizeHandle, resizePanel, startDragging, stopDragging, unregisterPanel]);\n  const style = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\"\n  };\n  return createElement(PanelGroupContext.Provider, {\n    value: context\n  }, createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    ref: panelGroupElementRef,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    [DATA_ATTRIBUTES.group]: \"\",\n    [DATA_ATTRIBUTES.groupDirection]: direction,\n    [DATA_ATTRIBUTES.groupId]: groupId\n  }));\n}\nconst PanelGroup = forwardRef((props, ref) => createElement(PanelGroupWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\nfunction findPanelDataIndex(panelDataArray, panelData) {\n  return panelDataArray.findIndex(prevPanelData => prevPanelData === panelData || prevPanelData.id === panelData.id);\n}\nfunction panelDataHelper(panelDataArray, panelData, layout) {\n  const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n  const isLastPanel = panelIndex === panelDataArray.length - 1;\n  const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];\n  const panelSize = layout[panelIndex];\n  return {\n    ...panelData.constraints,\n    panelSize,\n    pivotIndices\n  };\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler,\n  panelGroupElement\n}) {\n  useEffect(() => {\n    if (disabled || resizeHandler == null || panelGroupElement == null) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(handleId, panelGroupElement);\n    if (handleElement == null) {\n      return;\n    }\n    const onKeyDown = event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\":\n          {\n            event.preventDefault();\n            resizeHandler(event);\n            break;\n          }\n        case \"F6\":\n          {\n            event.preventDefault();\n            const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);\n            assert(groupId, `No group element found for id \"${groupId}\"`);\n            const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n            const index = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);\n            assert(index !== null, `No resize element found for id \"${handleId}\"`);\n            const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n            const nextHandle = handles[nextIndex];\n            nextHandle.focus();\n            break;\n          }\n      }\n    };\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [panelGroupElement, disabled, handleId, resizeHandler]);\n}\n\nfunction PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  disabled = false,\n  hitAreaMargins,\n  id: idFromProps,\n  onBlur,\n  onClick,\n  onDragging,\n  onFocus,\n  onPointerDown,\n  onPointerUp,\n  style: styleFromProps = {},\n  tabIndex = 0,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  var _hitAreaMargins$coars, _hitAreaMargins$fine;\n  const elementRef = useRef(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onClick,\n    onDragging,\n    onPointerDown,\n    onPointerUp\n  });\n  useEffect(() => {\n    callbacksRef.current.onClick = onClick;\n    callbacksRef.current.onDragging = onDragging;\n    callbacksRef.current.onPointerDown = onPointerDown;\n    callbacksRef.current.onPointerUp = onPointerUp;\n  });\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n  }\n  const {\n    direction,\n    groupId,\n    registerResizeHandle: registerResizeHandleWithParentGroup,\n    startDragging,\n    stopDragging,\n    panelGroupElement\n  } = panelGroupContext;\n  const resizeHandleId = useUniqueId(idFromProps);\n  const [state, setState] = useState(\"inactive\");\n  const [isFocused, setIsFocused] = useState(false);\n  const [resizeHandler, setResizeHandler] = useState(null);\n  const committedValuesRef = useRef({\n    state\n  });\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.state = state;\n  });\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandleWithParentGroup(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandleWithParentGroup]);\n\n  // Extract hit area margins before passing them to the effect's dependency array\n  // so that inline object values won't trigger re-renders\n  const coarseHitAreaMargins = (_hitAreaMargins$coars = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15;\n  const fineHitAreaMargins = (_hitAreaMargins$fine = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5;\n  useEffect(() => {\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n    const element = elementRef.current;\n    assert(element, \"Element ref not attached\");\n    let didMove = false;\n    const setResizeHandlerState = (action, isActive, event) => {\n      if (!isActive) {\n        setState(\"inactive\");\n        return;\n      }\n      switch (action) {\n        case \"down\":\n          {\n            setState(\"drag\");\n            didMove = false;\n            assert(event, 'Expected event to be defined for \"down\" action');\n            startDragging(resizeHandleId, event);\n            const {\n              onDragging,\n              onPointerDown\n            } = callbacksRef.current;\n            onDragging === null || onDragging === void 0 ? void 0 : onDragging(true);\n            onPointerDown === null || onPointerDown === void 0 ? void 0 : onPointerDown();\n            break;\n          }\n        case \"move\":\n          {\n            const {\n              state\n            } = committedValuesRef.current;\n            didMove = true;\n            if (state !== \"drag\") {\n              setState(\"hover\");\n            }\n            assert(event, 'Expected event to be defined for \"move\" action');\n            resizeHandler(event);\n            break;\n          }\n        case \"up\":\n          {\n            setState(\"hover\");\n            stopDragging();\n            const {\n              onClick,\n              onDragging,\n              onPointerUp\n            } = callbacksRef.current;\n            onDragging === null || onDragging === void 0 ? void 0 : onDragging(false);\n            onPointerUp === null || onPointerUp === void 0 ? void 0 : onPointerUp();\n            if (!didMove) {\n              onClick === null || onClick === void 0 ? void 0 : onClick();\n            }\n            break;\n          }\n      }\n    };\n    return registerResizeHandle(resizeHandleId, element, direction, {\n      coarse: coarseHitAreaMargins,\n      fine: fineHitAreaMargins\n    }, setResizeHandlerState);\n  }, [coarseHitAreaMargins, direction, disabled, fineHitAreaMargins, registerResizeHandleWithParentGroup, resizeHandleId, resizeHandler, startDragging, stopDragging]);\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler,\n    panelGroupElement\n  });\n  const style = {\n    touchAction: \"none\",\n    userSelect: \"none\"\n  };\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    onBlur: () => {\n      setIsFocused(false);\n      onBlur === null || onBlur === void 0 ? void 0 : onBlur();\n    },\n    onFocus: () => {\n      setIsFocused(true);\n      onFocus === null || onFocus === void 0 ? void 0 : onFocus();\n    },\n    ref: elementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    tabIndex,\n    // CSS selectors\n    [DATA_ATTRIBUTES.groupDirection]: direction,\n    [DATA_ATTRIBUTES.groupId]: groupId,\n    [DATA_ATTRIBUTES.resizeHandle]: \"\",\n    [DATA_ATTRIBUTES.resizeHandleActive]: state === \"drag\" ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n    [DATA_ATTRIBUTES.resizeHandleEnabled]: !disabled,\n    [DATA_ATTRIBUTES.resizeHandleId]: resizeHandleId,\n    [DATA_ATTRIBUTES.resizeHandleState]: state\n  });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n\nfunction usePanelGroupContext() {\n  const context = useContext(PanelGroupContext);\n  return {\n    direction: context === null || context === void 0 ? void 0 : context.direction,\n    groupId: context === null || context === void 0 ? void 0 : context.groupId\n  };\n}\n\nfunction getPanelElement(id, scope = document) {\n  const element = scope.querySelector(`[data-panel-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getPanelElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[data-panel][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getIntersectingRectangle(rectOne, rectTwo, strict) {\n  if (!intersects(rectOne, rectTwo, strict)) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  }\n  return {\n    x: Math.max(rectOne.x, rectTwo.x),\n    y: Math.max(rectOne.y, rectTwo.y),\n    width: Math.min(rectOne.x + rectOne.width, rectTwo.x + rectTwo.width) - Math.max(rectOne.x, rectTwo.x),\n    height: Math.min(rectOne.y + rectOne.height, rectTwo.y + rectTwo.height) - Math.max(rectOne.y, rectTwo.y)\n  };\n}\n\nexport { DATA_ATTRIBUTES, Panel, PanelGroup, PanelResizeHandle, assert, disableGlobalCursorStyles, enableGlobalCursorStyles, getIntersectingRectangle, getPanelElement, getPanelElementsForGroup, getPanelGroupElement, getResizeHandleElement, getResizeHandleElementIndex, getResizeHandleElementsForGroup, getResizeHandlePanelIds, intersects, setNonce, usePanelGroupContext };\n"],"names":["PanelGroupContext","createContext","DATA_ATTRIBUTES","PRECISION","useIsomorphicLayoutEffect","useLayoutEffect","useId","React","wrappedUseId","counter","useUniqueId","idFromParams","idFromUseId","idRef","useRef","PanelWithForwardedRef","children","classNameFromProps","collapsedSize","collapsible","defaultSize","forwardedRef","idFromProps","maxSize","minSize","onCollapse","onExpand","onResize","order","styleFromProps","Type","rest","context","useContext","collapsePanel","expandPanel","getPanelSize","getPanelStyle","groupId","isPanelCollapsed","reevaluatePanelConstraints","registerPanel","resizePanel","unregisterPanel","panelId","panelDataRef","callbacks","constraints","prevConstraints","panelData","useImperativeHandle","size","style","createElement","Panel","forwardRef","props","ref","currentCursorStyle","prevRuleIndex","styleElement","getCursorStyle","state","constraintFlags","horizontalMin","EXCEEDED_HORIZONTAL_MIN","horizontalMax","EXCEEDED_HORIZONTAL_MAX","verticalMin","EXCEEDED_VERTICAL_MIN","verticalMax","EXCEEDED_VERTICAL_MAX","resetGlobalCursorStyle","setGlobalCursorStyle","_styleElement$sheet$i","_styleElement$sheet2","_styleElement$sheet","isKeyDown","event","isPointerEvent","isMouseEvent","getResizeEventCoordinates","getInputType","intersects","rectOne","rectTwo","strict","compare","a","b","ancestors","get_ancestors","common_ancestor","assert","z_indexes","get_z_index","find_stacking_context","furthest_ancestors","i","child","is_flex_item","node","_get_parent","display","get_parent","creates_stacking_context","nodes","parentNode","isCoarsePointer","intersectingHandles","isPointerDown","ownerDocumentCounts","panelConstraintFlags","registeredResizeHandlers","registerResizeHandle","resizeHandleId","element","direction","hitAreaMargins","setResizeHandlerState","_ownerDocumentCounts$","ownerDocument","data","count","updateListeners","_ownerDocumentCounts$2","index","updateCursor","handlePointerDown","target","x","y","recalculateIntersectingHandles","updateResizeHandlerStates","isWithinResizeHandle","handlePointerMove","handlePointerUp","currentElement","targetElement","dragHandleElement","dragHandleRect","bottom","left","right","top","margin","didIntersect","reportConstraintsViolation","flag","intersectsHorizontal","intersectsVertical","listenersAbortController","options","body","_","action","isActive","useForceUpdate","setCount","useState","useCallback","prevCount","expectedCondition","message","fuzzyCompareNumbers","actual","expected","fractionDigits","fuzzyNumbersEqual$1","fuzzyNumbersEqual","fuzzyLayoutsEqual","actualSize","expectedSize","panelConstraintsArray","panelIndex","panelConstraints","halfwayPoint","adjustLayoutByDelta","delta","initialLayout","pivotIndices","prevLayout","trigger","nextLayout","firstPivotIndex","secondPivotIndex","deltaApplied","prevSize","localDelta","increment","maxAvailableDelta","minAbsDelta","deltaRemaining","unsafeSize","safeSize","pivotIndex","totalSize","total","calculateAriaValues","layout","panelsArray","currentMinSize","currentMaxSize","totalMinSize","totalMaxSize","firstIndex","valueMax","valueMin","valueNow","getResizeHandleElementsForGroup","scope","getResizeHandleElementIndex","id","handle","determinePivotIndices","dragHandleId","panelGroupElement","isHTMLElement","getPanelGroupElement","rootElement","getResizeHandleElement","getResizeHandlePanelIds","handleId","_panelsArray$index$id","_panelsArray$index","_panelsArray$id","_panelsArray","handles","idBefore","idAfter","useWindowSplitterPanelGroupBehavior","committedValuesRef","eagerValuesRef","panelDataArray","setLayout","resizeHandleElements","resizeHandleElement","useEffect","eagerValues","groupElement","cleanupFunctions","onKeyDown","cleanupFunction","areEqual","arrayA","arrayB","getResizeEventCursorPosition","isHorizontal","calculateDragOffsetPercentage","initialDragState","handleElement","initialCursorPosition","cursorPosition","groupRect","groupSizeInPixels","calculateDeltaPercentage","keyboardResizeBy","movement","calculateUnsafeDefaultLayout","numPanelsWithSizes","remainingSize","numRemainingPanels","callPanelCallbacks","panelIdToLastNotifiedSizeMap","lastNotifiedSize","compareLayouts","computePanelFlexBoxStyle","dragState","precision","flexGrow","debounce","callback","durationMs","timeoutId","args","initializeDefaultStorage","storageObject","name","value","error","getPanelGroupKey","autoSaveId","getPanelKey","panels","panel","idIsFromProps","loadSerializedPanelGroupState","storage","panelGroupKey","serialized","parsed","loadPanelGroupState","_loadSerializedPanelG","_state$panelKey","panelKey","savePanelGroupState","panelSizesBeforeCollapse","sizes","_loadSerializedPanelG2","validatePanelGroupLayout","nextLayoutTotalSize","accumulated","current","LOCAL_STORAGE_DEBOUNCE_INTERVAL","defaultStorage","debounceMap","PanelGroupWithForwardedRef","onLayout","panelGroupElementRef","setDragState","forceUpdate","panelIdToLastNotifiedSizeMapRef","panelSizeBeforeCollapseRef","prevDeltaRef","unsafeLayout","safeLayout","debouncedSave","clonedPanelDataArray","clonedPanelSizesBeforeCollapse","panelSize","panelDataHelper","findPanelDataIndex","minSizeOverride","minSizeFromProps","prevPanelSize","baseSize","isPanelExpanded","panelA","panelB","orderA","orderB","isRTL","layoutChanged","unsafePanelSize","prevCollapsedSize","prevCollapsible","nextCollapsedSize","nextCollapsible","nextMaxSize","nextMinSize","startDragging","stopDragging","useMemo","PanelGroup","prevPanelData","useWindowSplitterResizeHandlerBehavior","disabled","resizeHandler","nextIndex","PanelResizeHandle","onBlur","onClick","onDragging","onFocus","onPointerDown","onPointerUp","tabIndex","_hitAreaMargins$coars","_hitAreaMargins$fine","elementRef","callbacksRef","panelGroupContext","registerResizeHandleWithParentGroup","setState","isFocused","setIsFocused","setResizeHandler","coarseHitAreaMargins","fineHitAreaMargins","didMove"],"mappings":"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","x_google_ignoreList":[0]}