import * as Pn from "react";
import { forwardRef as Qe, createElement as de, useRef as F, useEffect as te, useContext as en, createContext as wn, useState as ue, useLayoutEffect as En, useImperativeHandle as nn, useCallback as B, useMemo as In } from "react";
const Ce = wn(null);
Ce.displayName = "PanelGroupContext";
const A = {
  group: "data-panel-group",
  groupDirection: "data-panel-group-direction",
  groupId: "data-panel-group-id",
  panel: "data-panel",
  panelCollapsible: "data-panel-collapsible",
  panelId: "data-panel-id",
  panelSize: "data-panel-size",
  resizeHandle: "data-resize-handle",
  resizeHandleActive: "data-resize-handle-active",
  resizeHandleEnabled: "data-panel-resize-handle-enabled",
  resizeHandleId: "data-panel-resize-handle-id",
  resizeHandleState: "data-resize-handle-state"
}, Te = 10, re = En, Ve = Pn.useId, Cn = typeof Ve == "function" ? Ve : () => null;
let Rn = 0;
function Be(e = null) {
  const n = Cn(), t = F(e || n || null);
  return t.current === null && (t.current = "" + Rn++), e ?? t.current;
}
function tn({
  children: e,
  className: n = "",
  collapsedSize: t,
  collapsible: r,
  defaultSize: i,
  forwardedRef: o,
  id: l,
  maxSize: s,
  minSize: a,
  onCollapse: m,
  onExpand: P,
  onResize: f,
  order: u,
  style: x,
  tagName: h = "div",
  ...E
}) {
  const w = en(Ce);
  if (w === null)
    throw Error("Panel components must be rendered within a PanelGroup container");
  const {
    collapsePanel: S,
    expandPanel: R,
    getPanelSize: D,
    getPanelStyle: $,
    groupId: q,
    isPanelCollapsed: C,
    reevaluatePanelConstraints: b,
    registerPanel: U,
    resizePanel: J,
    unregisterPanel: W
  } = w, _ = Be(l), M = F({
    callbacks: {
      onCollapse: m,
      onExpand: P,
      onResize: f
    },
    constraints: {
      collapsedSize: t,
      collapsible: r,
      defaultSize: i,
      maxSize: s,
      minSize: a
    },
    id: _,
    idIsFromProps: l !== void 0,
    order: u
  });
  F({
    didLogMissingDefaultSizeWarning: !1
  }), re(() => {
    const {
      callbacks: k,
      constraints: N
    } = M.current, G = {
      ...N
    };
    M.current.id = _, M.current.idIsFromProps = l !== void 0, M.current.order = u, k.onCollapse = m, k.onExpand = P, k.onResize = f, N.collapsedSize = t, N.collapsible = r, N.defaultSize = i, N.maxSize = s, N.minSize = a, (G.collapsedSize !== N.collapsedSize || G.collapsible !== N.collapsible || G.maxSize !== N.maxSize || G.minSize !== N.minSize) && b(M.current, G);
  }), re(() => {
    const k = M.current;
    return U(k), () => {
      W(k);
    };
  }, [u, _, U, W]), nn(o, () => ({
    collapse: () => {
      S(M.current);
    },
    expand: (k) => {
      R(M.current, k);
    },
    getId() {
      return _;
    },
    getSize() {
      return D(M.current);
    },
    isCollapsed() {
      return C(M.current);
    },
    isExpanded() {
      return !C(M.current);
    },
    resize: (k) => {
      J(M.current, k);
    }
  }), [S, R, D, C, _, J]);
  const ee = $(M.current, i);
  return de(h, {
    ...E,
    children: e,
    className: n,
    id: _,
    style: {
      ...ee,
      ...x
    },
    // CSS selectors
    [A.groupId]: q,
    [A.panel]: "",
    [A.panelCollapsible]: r || void 0,
    [A.panelId]: _,
    [A.panelSize]: parseFloat("" + ee.flexGrow).toFixed(1)
  });
}
const Ln = Qe((e, n) => de(tn, {
  ...e,
  forwardedRef: n
}));
tn.displayName = "Panel";
Ln.displayName = "forwardRef(Panel)";
let Ge = null, we = -1, Z = null;
function An(e, n) {
  if (n) {
    const t = (n & an) !== 0, r = (n & un) !== 0, i = (n & cn) !== 0, o = (n & dn) !== 0;
    if (t)
      return i ? "se-resize" : o ? "ne-resize" : "e-resize";
    if (r)
      return i ? "sw-resize" : o ? "nw-resize" : "w-resize";
    if (i)
      return "s-resize";
    if (o)
      return "n-resize";
  }
  switch (e) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function Mn() {
  Z !== null && (document.head.removeChild(Z), Ge = null, Z = null, we = -1);
}
function He(e, n) {
  var t, r;
  const i = An(e, n);
  if (Ge !== i) {
    if (Ge = i, Z === null && (Z = document.createElement("style"), document.head.appendChild(Z)), we >= 0) {
      var o;
      (o = Z.sheet) === null || o === void 0 || o.removeRule(we);
    }
    we = (t = (r = Z.sheet) === null || r === void 0 ? void 0 : r.insertRule(`*{cursor: ${i} !important;}`)) !== null && t !== void 0 ? t : -1;
  }
}
function rn(e) {
  return e.type === "keydown";
}
function on(e) {
  return e.type.startsWith("pointer");
}
function ln(e) {
  return e.type.startsWith("mouse");
}
function Re(e) {
  if (on(e)) {
    if (e.isPrimary)
      return {
        x: e.clientX,
        y: e.clientY
      };
  } else if (ln(e))
    return {
      x: e.clientX,
      y: e.clientY
    };
  return {
    x: 1 / 0,
    y: 1 / 0
  };
}
function Dn() {
  if (typeof matchMedia == "function")
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
function Hn(e, n, t) {
  return e.x < n.x + n.width && e.x + e.width > n.x && e.y < n.y + n.height && e.y + e.height > n.y;
}
function $n(e, n) {
  if (e === n) throw new Error("Cannot compare node with itself");
  const t = {
    a: Xe(e),
    b: Xe(n)
  };
  let r;
  for (; t.a.at(-1) === t.b.at(-1); )
    e = t.a.pop(), n = t.b.pop(), r = e;
  y(r, "Stacking order can only be calculated for elements with a common ancestor");
  const i = {
    a: qe(Oe(t.a)),
    b: qe(Oe(t.b))
  };
  if (i.a === i.b) {
    const o = r.childNodes, l = {
      a: t.a.at(-1),
      b: t.b.at(-1)
    };
    let s = o.length;
    for (; s--; ) {
      const a = o[s];
      if (a === l.a) return 1;
      if (a === l.b) return -1;
    }
  }
  return Math.sign(i.a - i.b);
}
const Nn = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function kn(e) {
  var n;
  const t = getComputedStyle((n = sn(e)) !== null && n !== void 0 ? n : e).display;
  return t === "flex" || t === "inline-flex";
}
function _n(e) {
  const n = getComputedStyle(e);
  return !!(n.position === "fixed" || n.zIndex !== "auto" && (n.position !== "static" || kn(e)) || +n.opacity < 1 || "transform" in n && n.transform !== "none" || "webkitTransform" in n && n.webkitTransform !== "none" || "mixBlendMode" in n && n.mixBlendMode !== "normal" || "filter" in n && n.filter !== "none" || "webkitFilter" in n && n.webkitFilter !== "none" || "isolation" in n && n.isolation === "isolate" || Nn.test(n.willChange) || n.webkitOverflowScrolling === "touch");
}
function Oe(e) {
  let n = e.length;
  for (; n--; ) {
    const t = e[n];
    if (y(t, "Missing node"), _n(t)) return t;
  }
  return null;
}
function qe(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function Xe(e) {
  const n = [];
  for (; e; )
    n.push(e), e = sn(e);
  return n;
}
function sn(e) {
  const {
    parentNode: n
  } = e;
  return n && n instanceof ShadowRoot ? n.host : n;
}
const an = 1, un = 2, cn = 4, dn = 8, Gn = Dn() === "coarse";
let O = [], ce = !1, Q = /* @__PURE__ */ new Map(), Le = /* @__PURE__ */ new Map();
const ve = /* @__PURE__ */ new Set();
function Tn(e, n, t, r, i) {
  var o;
  const {
    ownerDocument: l
  } = n, s = {
    direction: t,
    element: n,
    hitAreaMargins: r,
    setResizeHandlerState: i
  }, a = (o = Q.get(l)) !== null && o !== void 0 ? o : 0;
  return Q.set(l, a + 1), ve.add(s), Ee(), function() {
    var P;
    Le.delete(e), ve.delete(s);
    const f = (P = Q.get(l)) !== null && P !== void 0 ? P : 1;
    if (Q.set(l, f - 1), Ee(), f === 1 && Q.delete(l), O.includes(s)) {
      const u = O.indexOf(s);
      u >= 0 && O.splice(u, 1), We(), i("up", !0, null);
    }
  };
}
function Bn(e) {
  const {
    target: n
  } = e, {
    x: t,
    y: r
  } = Re(e);
  ce = !0, Fe({
    target: n,
    x: t,
    y: r
  }), Ee(), O.length > 0 && (Ie("down", e), e.preventDefault(), fn(n) || e.stopImmediatePropagation());
}
function $e(e) {
  const {
    x: n,
    y: t
  } = Re(e);
  if (ce && e.buttons === 0 && (ce = !1, Ie("up", e)), !ce) {
    const {
      target: r
    } = e;
    Fe({
      target: r,
      x: n,
      y: t
    });
  }
  Ie("move", e), We(), O.length > 0 && e.preventDefault();
}
function Ne(e) {
  const {
    target: n
  } = e, {
    x: t,
    y: r
  } = Re(e);
  Le.clear(), ce = !1, O.length > 0 && (e.preventDefault(), fn(n) || e.stopImmediatePropagation()), Ie("up", e), Fe({
    target: n,
    x: t,
    y: r
  }), We(), Ee();
}
function fn(e) {
  let n = e;
  for (; n; ) {
    if (n.hasAttribute(A.resizeHandle))
      return !0;
    n = n.parentElement;
  }
  return !1;
}
function Fe({
  target: e,
  x: n,
  y: t
}) {
  O.splice(0);
  let r = null;
  (e instanceof HTMLElement || e instanceof SVGElement) && (r = e), ve.forEach((i) => {
    const {
      element: o,
      hitAreaMargins: l
    } = i, s = o.getBoundingClientRect(), {
      bottom: a,
      left: m,
      right: P,
      top: f
    } = s, u = Gn ? l.coarse : l.fine;
    if (n >= m - u && n <= P + u && t >= f - u && t <= a + u) {
      if (r !== null && document.contains(r) && o !== r && !o.contains(r) && !r.contains(o) && // Calculating stacking order has a cost, so we should avoid it if possible
      // That is why we only check potentially intersecting handles,
      // and why we skip if the event target is within the handle's DOM
      $n(r, o) > 0) {
        let h = r, E = !1;
        for (; h && !h.contains(o); ) {
          if (Hn(h.getBoundingClientRect(), s)) {
            E = !0;
            break;
          }
          h = h.parentElement;
        }
        if (E)
          return;
      }
      O.push(i);
    }
  });
}
function ke(e, n) {
  Le.set(e, n);
}
function We() {
  let e = !1, n = !1;
  O.forEach((r) => {
    const {
      direction: i
    } = r;
    i === "horizontal" ? e = !0 : n = !0;
  });
  let t = 0;
  Le.forEach((r) => {
    t |= r;
  }), e && n ? He("intersection", t) : e ? He("horizontal", t) : n ? He("vertical", t) : Mn();
}
let _e = new AbortController();
function Ee() {
  _e.abort(), _e = new AbortController();
  const e = {
    capture: !0,
    signal: _e.signal
  };
  ve.size && (ce ? (O.length > 0 && Q.forEach((n, t) => {
    const {
      body: r
    } = t;
    n > 0 && (r.addEventListener("contextmenu", Ne, e), r.addEventListener("pointerleave", $e, e), r.addEventListener("pointermove", $e, e));
  }), Q.forEach((n, t) => {
    const {
      body: r
    } = t;
    r.addEventListener("pointerup", Ne, e), r.addEventListener("pointercancel", Ne, e);
  })) : Q.forEach((n, t) => {
    const {
      body: r
    } = t;
    n > 0 && (r.addEventListener("pointerdown", Bn, e), r.addEventListener("pointermove", $e, e));
  }));
}
function Ie(e, n) {
  ve.forEach((t) => {
    const {
      setResizeHandlerState: r
    } = t, i = O.includes(t);
    r(e, i, n);
  });
}
function Fn() {
  const [e, n] = ue(0);
  return B(() => n((t) => t + 1), []);
}
function y(e, n) {
  if (!e)
    throw console.error(n), Error(n);
}
function oe(e, n, t = Te) {
  return e.toFixed(t) === n.toFixed(t) ? 0 : e > n ? 1 : -1;
}
function Y(e, n, t = Te) {
  return oe(e, n, t) === 0;
}
function K(e, n, t) {
  return oe(e, n, t) === 0;
}
function Wn(e, n, t) {
  if (e.length !== n.length)
    return !1;
  for (let r = 0; r < e.length; r++) {
    const i = e[r], o = n[r];
    if (!K(i, o, t))
      return !1;
  }
  return !0;
}
function ae({
  panelConstraints: e,
  panelIndex: n,
  size: t
}) {
  const r = e[n];
  y(r != null, `Panel constraints not found for index ${n}`);
  let {
    collapsedSize: i = 0,
    collapsible: o,
    maxSize: l = 100,
    minSize: s = 0
  } = r;
  if (oe(t, s) < 0)
    if (o) {
      const a = (i + s) / 2;
      oe(t, a) < 0 ? t = i : t = s;
    } else
      t = s;
  return t = Math.min(l, t), t = parseFloat(t.toFixed(Te)), t;
}
function ye({
  delta: e,
  initialLayout: n,
  panelConstraints: t,
  pivotIndices: r,
  prevLayout: i,
  trigger: o
}) {
  if (K(e, 0))
    return n;
  const l = [...n], [s, a] = r;
  y(s != null, "Invalid first pivot index"), y(a != null, "Invalid second pivot index");
  let m = 0;
  if (o === "keyboard") {
    {
      const f = e < 0 ? a : s, u = t[f];
      y(u, `Panel constraints not found for index ${f}`);
      const {
        collapsedSize: x = 0,
        collapsible: h,
        minSize: E = 0
      } = u;
      if (h) {
        const w = n[f];
        if (y(w != null, `Previous layout not found for panel index ${f}`), K(w, x)) {
          const S = E - w;
          oe(S, Math.abs(e)) > 0 && (e = e < 0 ? 0 - S : S);
        }
      }
    }
    {
      const f = e < 0 ? s : a, u = t[f];
      y(u, `No panel constraints found for index ${f}`);
      const {
        collapsedSize: x = 0,
        collapsible: h,
        minSize: E = 0
      } = u;
      if (h) {
        const w = n[f];
        if (y(w != null, `Previous layout not found for panel index ${f}`), K(w, E)) {
          const S = w - x;
          oe(S, Math.abs(e)) > 0 && (e = e < 0 ? 0 - S : S);
        }
      }
    }
  }
  {
    const f = e < 0 ? 1 : -1;
    let u = e < 0 ? a : s, x = 0;
    for (; ; ) {
      const E = n[u];
      y(E != null, `Previous layout not found for panel index ${u}`);
      const S = ae({
        panelConstraints: t,
        panelIndex: u,
        size: 100
      }) - E;
      if (x += S, u += f, u < 0 || u >= t.length)
        break;
    }
    const h = Math.min(Math.abs(e), Math.abs(x));
    e = e < 0 ? 0 - h : h;
  }
  {
    let u = e < 0 ? s : a;
    for (; u >= 0 && u < t.length; ) {
      const x = Math.abs(e) - Math.abs(m), h = n[u];
      y(h != null, `Previous layout not found for panel index ${u}`);
      const E = h - x, w = ae({
        panelConstraints: t,
        panelIndex: u,
        size: E
      });
      if (!K(h, w) && (m += h - w, l[u] = w, m.toPrecision(3).localeCompare(Math.abs(e).toPrecision(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      e < 0 ? u-- : u++;
    }
  }
  if (Wn(i, l))
    return i;
  {
    const f = e < 0 ? a : s, u = n[f];
    y(u != null, `Previous layout not found for panel index ${f}`);
    const x = u + m, h = ae({
      panelConstraints: t,
      panelIndex: f,
      size: x
    });
    if (l[f] = h, !K(h, x)) {
      let E = x - h, S = e < 0 ? a : s;
      for (; S >= 0 && S < t.length; ) {
        const R = l[S];
        y(R != null, `Previous layout not found for panel index ${S}`);
        const D = R + E, $ = ae({
          panelConstraints: t,
          panelIndex: S,
          size: D
        });
        if (K(R, $) || (E -= $ - R, l[S] = $), K(E, 0))
          break;
        e > 0 ? S-- : S++;
      }
    }
  }
  const P = l.reduce((f, u) => u + f, 0);
  return K(P, 100) ? l : i;
}
function Kn({
  layout: e,
  panelsArray: n,
  pivotIndices: t
}) {
  let r = 0, i = 100, o = 0, l = 0;
  const s = t[0];
  y(s != null, "No pivot index found"), n.forEach((f, u) => {
    const {
      constraints: x
    } = f, {
      maxSize: h = 100,
      minSize: E = 0
    } = x;
    u === s ? (r = E, i = h) : (o += E, l += h);
  });
  const a = Math.min(i, 100 - o), m = Math.max(r, 100 - l), P = e[s];
  return {
    valueMax: a,
    valueMin: m,
    valueNow: P
  };
}
function Se(e, n = document) {
  return Array.from(n.querySelectorAll(`[${A.resizeHandleId}][data-panel-group-id="${e}"]`));
}
function pn(e, n, t = document) {
  const i = Se(e, t).findIndex((o) => o.getAttribute(A.resizeHandleId) === n);
  return i ?? null;
}
function gn(e, n, t) {
  const r = pn(e, n, t);
  return r != null ? [r, r + 1] : [-1, -1];
}
function Un(e) {
  return e instanceof HTMLElement ? !0 : typeof e == "object" && e !== null && "tagName" in e && "getAttribute" in e;
}
function mn(e, n = document) {
  if (Un(n) && n.dataset.panelGroupId == e)
    return n;
  const t = n.querySelector(`[data-panel-group][data-panel-group-id="${e}"]`);
  return t || null;
}
function Ae(e, n = document) {
  const t = n.querySelector(`[${A.resizeHandleId}="${e}"]`);
  return t || null;
}
function Vn(e, n, t, r = document) {
  var i, o, l, s;
  const a = Ae(n, r), m = Se(e, r), P = a ? m.indexOf(a) : -1, f = (i = (o = t[P]) === null || o === void 0 ? void 0 : o.id) !== null && i !== void 0 ? i : null, u = (l = (s = t[P + 1]) === null || s === void 0 ? void 0 : s.id) !== null && l !== void 0 ? l : null;
  return [f, u];
}
function On({
  committedValuesRef: e,
  eagerValuesRef: n,
  groupId: t,
  layout: r,
  panelDataArray: i,
  panelGroupElement: o,
  setLayout: l
}) {
  F({
    didWarnAboutMissingResizeHandle: !1
  }), re(() => {
    if (!o)
      return;
    const s = Se(t, o);
    for (let a = 0; a < i.length - 1; a++) {
      const {
        valueMax: m,
        valueMin: P,
        valueNow: f
      } = Kn({
        layout: r,
        panelsArray: i,
        pivotIndices: [a, a + 1]
      }), u = s[a];
      if (u != null) {
        const x = i[a];
        y(x, `No panel data found for index "${a}"`), u.setAttribute("aria-controls", x.id), u.setAttribute("aria-valuemax", "" + Math.round(m)), u.setAttribute("aria-valuemin", "" + Math.round(P)), u.setAttribute("aria-valuenow", f != null ? "" + Math.round(f) : "");
      }
    }
    return () => {
      s.forEach((a, m) => {
        a.removeAttribute("aria-controls"), a.removeAttribute("aria-valuemax"), a.removeAttribute("aria-valuemin"), a.removeAttribute("aria-valuenow");
      });
    };
  }, [t, r, i, o]), te(() => {
    if (!o)
      return;
    const s = n.current;
    y(s, "Eager values not found");
    const {
      panelDataArray: a
    } = s, m = mn(t, o);
    y(m != null, `No group found for id "${t}"`);
    const P = Se(t, o);
    y(P, `No resize handles found for group id "${t}"`);
    const f = P.map((u) => {
      const x = u.getAttribute(A.resizeHandleId);
      y(x, "Resize handle element has no handle id attribute");
      const [h, E] = Vn(t, x, a, o);
      if (h == null || E == null)
        return () => {
        };
      const w = (S) => {
        if (!S.defaultPrevented)
          switch (S.key) {
            case "Enter": {
              S.preventDefault();
              const R = a.findIndex((D) => D.id === h);
              if (R >= 0) {
                const D = a[R];
                y(D, `No panel data found for index ${R}`);
                const $ = r[R], {
                  collapsedSize: q = 0,
                  collapsible: C,
                  minSize: b = 0
                } = D.constraints;
                if ($ != null && C) {
                  const U = ye({
                    delta: K($, q) ? b - q : q - $,
                    initialLayout: r,
                    panelConstraints: a.map((J) => J.constraints),
                    pivotIndices: gn(t, x, o),
                    prevLayout: r,
                    trigger: "keyboard"
                  });
                  r !== U && l(U);
                }
              }
              break;
            }
          }
      };
      return u.addEventListener("keydown", w), () => {
        u.removeEventListener("keydown", w);
      };
    });
    return () => {
      f.forEach((u) => u());
    };
  }, [o, e, n, t, r, i, l]);
}
function je(e, n) {
  if (e.length !== n.length)
    return !1;
  for (let t = 0; t < e.length; t++)
    if (e[t] !== n[t])
      return !1;
  return !0;
}
function hn(e, n) {
  const t = e === "horizontal", {
    x: r,
    y: i
  } = Re(n);
  return t ? r : i;
}
function qn(e, n, t, r, i) {
  const o = t === "horizontal", l = Ae(n, i);
  y(l, `No resize handle element found for id "${n}"`);
  const s = l.getAttribute(A.groupId);
  y(s, "Resize handle element has no group id attribute");
  let {
    initialCursorPosition: a
  } = r;
  const m = hn(t, e), P = mn(s, i);
  y(P, `No group element found for id "${s}"`);
  const f = P.getBoundingClientRect(), u = o ? f.width : f.height;
  return (m - a) / u * 100;
}
function Xn(e, n, t, r, i, o) {
  if (rn(e)) {
    const l = t === "horizontal";
    let s = 0;
    e.shiftKey ? s = 100 : i != null ? s = i : s = 10;
    let a = 0;
    switch (e.key) {
      case "ArrowDown":
        a = l ? 0 : s;
        break;
      case "ArrowLeft":
        a = l ? -s : 0;
        break;
      case "ArrowRight":
        a = l ? s : 0;
        break;
      case "ArrowUp":
        a = l ? 0 : -s;
        break;
      case "End":
        a = 100;
        break;
      case "Home":
        a = -100;
        break;
    }
    return a;
  } else
    return r == null ? 0 : qn(e, n, t, r, o);
}
function jn({
  panelDataArray: e
}) {
  const n = Array(e.length), t = e.map((o) => o.constraints);
  let r = 0, i = 100;
  for (let o = 0; o < e.length; o++) {
    const l = t[o];
    y(l, `Panel constraints not found for index ${o}`);
    const {
      defaultSize: s
    } = l;
    s != null && (r++, n[o] = s, i -= s);
  }
  for (let o = 0; o < e.length; o++) {
    const l = t[o];
    y(l, `Panel constraints not found for index ${o}`);
    const {
      defaultSize: s
    } = l;
    if (s != null)
      continue;
    const a = e.length - r, m = i / a;
    r++, n[o] = m, i -= m;
  }
  return n;
}
function le(e, n, t) {
  n.forEach((r, i) => {
    const o = e[i];
    y(o, `Panel data not found for index ${i}`);
    const {
      callbacks: l,
      constraints: s,
      id: a
    } = o, {
      collapsedSize: m = 0,
      collapsible: P
    } = s, f = t[a];
    if (f == null || r !== f) {
      t[a] = r;
      const {
        onCollapse: u,
        onExpand: x,
        onResize: h
      } = l;
      h && h(r, f), P && (u || x) && (x && (f == null || Y(f, m)) && !Y(r, m) && x(), u && (f == null || !Y(f, m)) && Y(r, m) && u());
    }
  });
}
function Pe(e, n) {
  if (e.length !== n.length)
    return !1;
  for (let t = 0; t < e.length; t++)
    if (e[t] != n[t])
      return !1;
  return !0;
}
function Jn({
  defaultSize: e,
  dragState: n,
  layout: t,
  panelData: r,
  panelIndex: i,
  precision: o = 3
}) {
  const l = t[i];
  let s;
  return l == null ? s = e != null ? e.toPrecision(o) : "1" : r.length === 1 ? s = "1" : s = l.toPrecision(o), {
    flexBasis: 0,
    flexGrow: s,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: n !== null ? "none" : void 0
  };
}
function Yn(e, n = 10) {
  let t = null;
  return (...i) => {
    t !== null && clearTimeout(t), t = setTimeout(() => {
      e(...i);
    }, n);
  };
}
function Je(e) {
  try {
    if (typeof localStorage < "u")
      e.getItem = (n) => localStorage.getItem(n), e.setItem = (n, t) => {
        localStorage.setItem(n, t);
      };
    else
      throw new Error("localStorage not supported in this environment");
  } catch (n) {
    console.error(n), e.getItem = () => null, e.setItem = () => {
    };
  }
}
function zn(e) {
  return `react-resizable-panels:${e}`;
}
function yn(e) {
  return e.map((n) => {
    const {
      constraints: t,
      id: r,
      idIsFromProps: i,
      order: o
    } = n;
    return i ? r : o ? `${o}:${JSON.stringify(t)}` : JSON.stringify(t);
  }).sort((n, t) => n.localeCompare(t)).join(",");
}
function xn(e, n) {
  try {
    const t = zn(e), r = n.getItem(t);
    if (r) {
      const i = JSON.parse(r);
      if (typeof i == "object" && i != null)
        return i;
    }
  } catch {
  }
  return null;
}
function Zn(e, n, t) {
  var r, i;
  const o = (r = xn(e, t)) !== null && r !== void 0 ? r : {}, l = yn(n);
  return (i = o[l]) !== null && i !== void 0 ? i : null;
}
function Qn(e, n, t, r, i) {
  var o;
  const l = zn(e), s = yn(n), a = (o = xn(e, i)) !== null && o !== void 0 ? o : {};
  a[s] = {
    expandToSizes: Object.fromEntries(t.entries()),
    layout: r
  };
  try {
    i.setItem(l, JSON.stringify(a));
  } catch (m) {
    console.error(m);
  }
}
function Ye({
  layout: e,
  panelConstraints: n
}) {
  const t = [...e], r = t.reduce((o, l) => o + l, 0);
  if (t.length !== n.length)
    throw Error(`Invalid ${n.length} panel layout: ${t.map((o) => `${o}%`).join(", ")}`);
  if (!K(r, 100) && t.length > 0)
    for (let o = 0; o < n.length; o++) {
      const l = t[o];
      y(l != null, `No layout data found for index ${o}`);
      const s = 100 / r * l;
      t[o] = s;
    }
  let i = 0;
  for (let o = 0; o < n.length; o++) {
    const l = t[o];
    y(l != null, `No layout data found for index ${o}`);
    const s = ae({
      panelConstraints: n,
      panelIndex: o,
      size: l
    });
    l != s && (i += l - s, t[o] = s);
  }
  if (!K(i, 0))
    for (let o = 0; o < n.length; o++) {
      const l = t[o];
      y(l != null, `No layout data found for index ${o}`);
      const s = l + i, a = ae({
        panelConstraints: n,
        panelIndex: o,
        size: s
      });
      if (l !== a && (i -= a - l, t[o] = a, K(i, 0)))
        break;
    }
  return t;
}
const et = 100, xe = {
  getItem: (e) => (Je(xe), xe.getItem(e)),
  setItem: (e, n) => {
    Je(xe), xe.setItem(e, n);
  }
}, Ze = {};
function vn({
  autoSaveId: e = null,
  children: n,
  className: t = "",
  direction: r,
  forwardedRef: i,
  id: o = null,
  onLayout: l = null,
  keyboardResizeBy: s = null,
  storage: a = xe,
  style: m,
  tagName: P = "div",
  ...f
}) {
  const u = Be(o), x = F(null), [h, E] = ue(null), [w, S] = ue([]), R = Fn(), D = F({}), $ = F(/* @__PURE__ */ new Map()), q = F(0), C = F({
    autoSaveId: e,
    direction: r,
    dragState: h,
    id: u,
    keyboardResizeBy: s,
    onLayout: l,
    storage: a
  }), b = F({
    layout: w,
    panelDataArray: [],
    panelDataArrayChanged: !1
  });
  F({
    didLogIdAndOrderWarning: !1,
    didLogPanelConstraintsWarning: !1,
    prevPanelIds: []
  }), nn(i, () => ({
    getId: () => C.current.id,
    getLayout: () => {
      const {
        layout: c
      } = b.current;
      return c;
    },
    setLayout: (c) => {
      const {
        onLayout: g
      } = C.current, {
        layout: v,
        panelDataArray: p
      } = b.current, d = Ye({
        layout: c,
        panelConstraints: p.map((z) => z.constraints)
      });
      je(v, d) || (S(d), b.current.layout = d, g && g(d), le(p, d, D.current));
    }
  }), []), re(() => {
    C.current.autoSaveId = e, C.current.direction = r, C.current.dragState = h, C.current.id = u, C.current.onLayout = l, C.current.storage = a;
  }), On({
    committedValuesRef: C,
    eagerValuesRef: b,
    groupId: u,
    layout: w,
    panelDataArray: b.current.panelDataArray,
    setLayout: S,
    panelGroupElement: x.current
  }), te(() => {
    const {
      panelDataArray: c
    } = b.current;
    if (e) {
      if (w.length === 0 || w.length !== c.length)
        return;
      let g = Ze[e];
      g == null && (g = Yn(Qn, et), Ze[e] = g);
      const v = [...c], p = new Map($.current);
      g(e, v, p, w, a);
    }
  }, [e, w, a]), te(() => {
  });
  const U = B((c) => {
    const {
      onLayout: g
    } = C.current, {
      layout: v,
      panelDataArray: p
    } = b.current;
    if (c.constraints.collapsible) {
      const d = p.map((X) => X.constraints), {
        collapsedSize: z = 0,
        panelSize: I,
        pivotIndices: H
      } = ne(p, c, v);
      if (y(I != null, `Panel size not found for panel "${c.id}"`), !Y(I, z)) {
        $.current.set(c.id, I);
        const j = se(p, c) === p.length - 1 ? I - z : z - I, L = ye({
          delta: j,
          initialLayout: v,
          panelConstraints: d,
          pivotIndices: H,
          prevLayout: v,
          trigger: "imperative-api"
        });
        Pe(v, L) || (S(L), b.current.layout = L, g && g(L), le(p, L, D.current));
      }
    }
  }, []), J = B((c, g) => {
    const {
      onLayout: v
    } = C.current, {
      layout: p,
      panelDataArray: d
    } = b.current;
    if (c.constraints.collapsible) {
      const z = d.map((V) => V.constraints), {
        collapsedSize: I = 0,
        panelSize: H = 0,
        minSize: X = 0,
        pivotIndices: j
      } = ne(d, c, p), L = g ?? X;
      if (Y(H, I)) {
        const V = $.current.get(c.id), he = V != null && V >= L ? V : L, De = se(d, c) === d.length - 1 ? H - he : he - H, T = ye({
          delta: De,
          initialLayout: p,
          panelConstraints: z,
          pivotIndices: j,
          prevLayout: p,
          trigger: "imperative-api"
        });
        Pe(p, T) || (S(T), b.current.layout = T, v && v(T), le(d, T, D.current));
      }
    }
  }, []), W = B((c) => {
    const {
      layout: g,
      panelDataArray: v
    } = b.current, {
      panelSize: p
    } = ne(v, c, g);
    return y(p != null, `Panel size not found for panel "${c.id}"`), p;
  }, []), _ = B((c, g) => {
    const {
      panelDataArray: v
    } = b.current, p = se(v, c);
    return Jn({
      defaultSize: g,
      dragState: h,
      layout: w,
      panelData: v,
      panelIndex: p
    });
  }, [h, w]), M = B((c) => {
    const {
      layout: g,
      panelDataArray: v
    } = b.current, {
      collapsedSize: p = 0,
      collapsible: d,
      panelSize: z
    } = ne(v, c, g);
    return y(z != null, `Panel size not found for panel "${c.id}"`), d === !0 && Y(z, p);
  }, []), ee = B((c) => {
    const {
      layout: g,
      panelDataArray: v
    } = b.current, {
      collapsedSize: p = 0,
      collapsible: d,
      panelSize: z
    } = ne(v, c, g);
    return y(z != null, `Panel size not found for panel "${c.id}"`), !d || oe(z, p) > 0;
  }, []), k = B((c) => {
    const {
      panelDataArray: g
    } = b.current;
    g.push(c), g.sort((v, p) => {
      const d = v.order, z = p.order;
      return d == null && z == null ? 0 : d == null ? -1 : z == null ? 1 : d - z;
    }), b.current.panelDataArrayChanged = !0, R();
  }, [R]);
  re(() => {
    if (b.current.panelDataArrayChanged) {
      b.current.panelDataArrayChanged = !1;
      const {
        autoSaveId: c,
        onLayout: g,
        storage: v
      } = C.current, {
        layout: p,
        panelDataArray: d
      } = b.current;
      let z = null;
      if (c) {
        const H = Zn(c, d, v);
        H && ($.current = new Map(Object.entries(H.expandToSizes)), z = H.layout);
      }
      z == null && (z = jn({
        panelDataArray: d
      }));
      const I = Ye({
        layout: z,
        panelConstraints: d.map((H) => H.constraints)
      });
      je(p, I) || (S(I), b.current.layout = I, g && g(I), le(d, I, D.current));
    }
  }), re(() => {
    const c = b.current;
    return () => {
      c.layout = [];
    };
  }, []);
  const N = B((c) => {
    let g = !1;
    const v = x.current;
    return v && window.getComputedStyle(v, null).getPropertyValue("direction") === "rtl" && (g = !0), function(d) {
      d.preventDefault();
      const z = x.current;
      if (!z)
        return () => null;
      const {
        direction: I,
        dragState: H,
        id: X,
        keyboardResizeBy: j,
        onLayout: L
      } = C.current, {
        layout: V,
        panelDataArray: he
      } = b.current, {
        initialLayout: be
      } = H ?? {}, De = gn(X, c, z);
      let T = Xn(d, c, I, H, j, z);
      const Ke = I === "horizontal";
      Ke && g && (T = -T);
      const Sn = he.map((bn) => bn.constraints), ze = ye({
        delta: T,
        initialLayout: be ?? V,
        panelConstraints: Sn,
        pivotIndices: De,
        prevLayout: V,
        trigger: rn(d) ? "keyboard" : "mouse-or-touch"
      }), Ue = !Pe(V, ze);
      (on(d) || ln(d)) && q.current != T && (q.current = T, !Ue && T !== 0 ? Ke ? ke(c, T < 0 ? an : un) : ke(c, T < 0 ? cn : dn) : ke(c, 0)), Ue && (S(ze), b.current.layout = ze, L && L(ze), le(he, ze, D.current));
    };
  }, []), G = B((c, g) => {
    const {
      onLayout: v
    } = C.current, {
      layout: p,
      panelDataArray: d
    } = b.current, z = d.map((V) => V.constraints), {
      panelSize: I,
      pivotIndices: H
    } = ne(d, c, p);
    y(I != null, `Panel size not found for panel "${c.id}"`);
    const j = se(d, c) === d.length - 1 ? I - g : g - I, L = ye({
      delta: j,
      initialLayout: p,
      panelConstraints: z,
      pivotIndices: H,
      prevLayout: p,
      trigger: "imperative-api"
    });
    Pe(p, L) || (S(L), b.current.layout = L, v && v(L), le(d, L, D.current));
  }, []), fe = B((c, g) => {
    const {
      layout: v,
      panelDataArray: p
    } = b.current, {
      collapsedSize: d = 0,
      collapsible: z
    } = g, {
      collapsedSize: I = 0,
      collapsible: H,
      maxSize: X = 100,
      minSize: j = 0
    } = c.constraints, {
      panelSize: L
    } = ne(p, c, v);
    L != null && (z && H && Y(L, d) ? Y(d, I) || G(c, I) : L < j ? G(c, j) : L > X && G(c, X));
  }, [G]), pe = B((c, g) => {
    const {
      direction: v
    } = C.current, {
      layout: p
    } = b.current;
    if (!x.current)
      return;
    const d = Ae(c, x.current);
    y(d, `Drag handle element not found for id "${c}"`);
    const z = hn(v, g);
    E({
      dragHandleId: c,
      dragHandleRect: d.getBoundingClientRect(),
      initialCursorPosition: z,
      initialLayout: p
    });
  }, []), ge = B(() => {
    E(null);
  }, []), Me = B((c) => {
    const {
      panelDataArray: g
    } = b.current, v = se(g, c);
    v >= 0 && (g.splice(v, 1), delete D.current[c.id], b.current.panelDataArrayChanged = !0, R());
  }, [R]), ie = In(() => ({
    collapsePanel: U,
    direction: r,
    dragState: h,
    expandPanel: J,
    getPanelSize: W,
    getPanelStyle: _,
    groupId: u,
    isPanelCollapsed: M,
    isPanelExpanded: ee,
    reevaluatePanelConstraints: fe,
    registerPanel: k,
    registerResizeHandle: N,
    resizePanel: G,
    startDragging: pe,
    stopDragging: ge,
    unregisterPanel: Me,
    panelGroupElement: x.current
  }), [U, h, r, J, W, _, u, M, ee, fe, k, N, G, pe, ge, Me]), me = {
    display: "flex",
    flexDirection: r === "horizontal" ? "row" : "column",
    height: "100%",
    overflow: "hidden",
    width: "100%"
  };
  return de(Ce.Provider, {
    value: ie
  }, de(P, {
    ...f,
    children: n,
    className: t,
    id: o,
    ref: x,
    style: {
      ...me,
      ...m
    },
    // CSS selectors
    [A.group]: "",
    [A.groupDirection]: r,
    [A.groupId]: u
  }));
}
const nt = Qe((e, n) => de(vn, {
  ...e,
  forwardedRef: n
}));
vn.displayName = "PanelGroup";
nt.displayName = "forwardRef(PanelGroup)";
function se(e, n) {
  return e.findIndex((t) => t === n || t.id === n.id);
}
function ne(e, n, t) {
  const r = se(e, n), o = r === e.length - 1 ? [r - 1, r] : [r, r + 1], l = t[r];
  return {
    ...n.constraints,
    panelSize: l,
    pivotIndices: o
  };
}
function tt({
  disabled: e,
  handleId: n,
  resizeHandler: t,
  panelGroupElement: r
}) {
  te(() => {
    if (e || t == null || r == null)
      return;
    const i = Ae(n, r);
    if (i == null)
      return;
    const o = (l) => {
      if (!l.defaultPrevented)
        switch (l.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            l.preventDefault(), t(l);
            break;
          }
          case "F6": {
            l.preventDefault();
            const s = i.getAttribute(A.groupId);
            y(s, `No group element found for id "${s}"`);
            const a = Se(s, r), m = pn(s, n, r);
            y(m !== null, `No resize element found for id "${n}"`);
            const P = l.shiftKey ? m > 0 ? m - 1 : a.length - 1 : m + 1 < a.length ? m + 1 : 0;
            a[P].focus();
            break;
          }
        }
    };
    return i.addEventListener("keydown", o), () => {
      i.removeEventListener("keydown", o);
    };
  }, [r, e, n, t]);
}
function rt({
  children: e = null,
  className: n = "",
  disabled: t = !1,
  hitAreaMargins: r,
  id: i,
  onBlur: o,
  onClick: l,
  onDragging: s,
  onFocus: a,
  onPointerDown: m,
  onPointerUp: P,
  style: f = {},
  tabIndex: u = 0,
  tagName: x = "div",
  ...h
}) {
  var E, w;
  const S = F(null), R = F({
    onClick: l,
    onDragging: s,
    onPointerDown: m,
    onPointerUp: P
  });
  te(() => {
    R.current.onClick = l, R.current.onDragging = s, R.current.onPointerDown = m, R.current.onPointerUp = P;
  });
  const D = en(Ce);
  if (D === null)
    throw Error("PanelResizeHandle components must be rendered within a PanelGroup container");
  const {
    direction: $,
    groupId: q,
    registerResizeHandle: C,
    startDragging: b,
    stopDragging: U,
    panelGroupElement: J
  } = D, W = Be(i), [_, M] = ue("inactive"), [ee, k] = ue(!1), [N, G] = ue(null), fe = F({
    state: _
  });
  re(() => {
    fe.current.state = _;
  }), te(() => {
    if (t)
      G(null);
    else {
      const ie = C(W);
      G(() => ie);
    }
  }, [t, W, C]);
  const pe = (E = r?.coarse) !== null && E !== void 0 ? E : 15, ge = (w = r?.fine) !== null && w !== void 0 ? w : 5;
  return te(() => {
    if (t || N == null)
      return;
    const ie = S.current;
    y(ie, "Element ref not attached");
    let me = !1;
    return Tn(W, ie, $, {
      coarse: pe,
      fine: ge
    }, (g, v, p) => {
      if (!v) {
        M("inactive");
        return;
      }
      switch (g) {
        case "down": {
          M("drag"), me = !1, y(p, 'Expected event to be defined for "down" action'), b(W, p);
          const {
            onDragging: d,
            onPointerDown: z
          } = R.current;
          d?.(!0), z?.();
          break;
        }
        case "move": {
          const {
            state: d
          } = fe.current;
          me = !0, d !== "drag" && M("hover"), y(p, 'Expected event to be defined for "move" action'), N(p);
          break;
        }
        case "up": {
          M("hover"), U();
          const {
            onClick: d,
            onDragging: z,
            onPointerUp: I
          } = R.current;
          z?.(!1), I?.(), me || d?.();
          break;
        }
      }
    });
  }, [pe, $, t, ge, C, W, N, b, U]), tt({
    disabled: t,
    handleId: W,
    resizeHandler: N,
    panelGroupElement: J
  }), de(x, {
    ...h,
    children: e,
    className: n,
    id: i,
    onBlur: () => {
      k(!1), o?.();
    },
    onFocus: () => {
      k(!0), a?.();
    },
    ref: S,
    role: "separator",
    style: {
      ...{
        touchAction: "none",
        userSelect: "none"
      },
      ...f
    },
    tabIndex: u,
    // CSS selectors
    [A.groupDirection]: $,
    [A.groupId]: q,
    [A.resizeHandle]: "",
    [A.resizeHandleActive]: _ === "drag" ? "pointer" : ee ? "keyboard" : void 0,
    [A.resizeHandleEnabled]: !t,
    [A.resizeHandleId]: W,
    [A.resizeHandleState]: _
  });
}
rt.displayName = "PanelResizeHandle";
export {
  A as DATA_ATTRIBUTES,
  Ln as Panel,
  nt as PanelGroup,
  rt as PanelResizeHandle,
  y as assert,
  mn as getPanelGroupElement,
  Ae as getResizeHandleElement,
  pn as getResizeHandleElementIndex,
  Se as getResizeHandleElementsForGroup,
  Vn as getResizeHandlePanelIds,
  Hn as intersects
};
//# sourceMappingURL=react-resizable-panels.browser.js.map
