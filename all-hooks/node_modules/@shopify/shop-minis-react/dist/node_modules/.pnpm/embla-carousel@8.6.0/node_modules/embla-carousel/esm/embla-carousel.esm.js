function Tt(t) {
  return typeof t == "number";
}
function Lt(t) {
  return typeof t == "string";
}
function gt(t) {
  return typeof t == "boolean";
}
function Vt(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function P(t) {
  return Math.abs(t);
}
function It(t) {
  return Math.sign(t);
}
function ft(t, n) {
  return P(t - n);
}
function Jt(t, n) {
  if (t === 0 || n === 0 || P(t) <= P(n)) return 0;
  const s = ft(P(t), P(n));
  return P(s / t);
}
function Zt(t) {
  return Math.round(t * 100) / 100;
}
function at(t) {
  return lt(t).map(Number);
}
function k(t) {
  return t[pt(t)];
}
function pt(t) {
  return Math.max(0, t.length - 1);
}
function vt(t, n) {
  return n === pt(t);
}
function zt(t, n = 0) {
  return Array.from(Array(t), (s, r) => n + r);
}
function lt(t) {
  return Object.keys(t);
}
function Bt(t, n) {
  return [t, n].reduce((s, r) => (lt(r).forEach((c) => {
    const o = s[c], e = r[c], f = Vt(o) && Vt(e);
    s[c] = f ? Bt(o, e) : e;
  }), s), {});
}
function Et(t, n) {
  return typeof n.MouseEvent < "u" && t instanceof n.MouseEvent;
}
function Wt(t, n) {
  const s = {
    start: r,
    center: c,
    end: o
  };
  function r() {
    return 0;
  }
  function c(i) {
    return o(i) / 2;
  }
  function o(i) {
    return n - i;
  }
  function e(i, u) {
    return Lt(t) ? s[t](i) : t(n, i, u);
  }
  return {
    measure: e
  };
}
function dt() {
  let t = [];
  function n(c, o, e, f = {
    passive: !0
  }) {
    let i;
    if ("addEventListener" in c)
      c.addEventListener(o, e, f), i = () => c.removeEventListener(o, e, f);
    else {
      const u = c;
      u.addListener(e), i = () => u.removeListener(e);
    }
    return t.push(i), r;
  }
  function s() {
    t = t.filter((c) => c());
  }
  const r = {
    add: n,
    clear: s
  };
  return r;
}
function tn(t, n, s, r) {
  const c = dt(), o = 1e3 / 60;
  let e = null, f = 0, i = 0;
  function u() {
    c.add(t, "visibilitychange", () => {
      t.hidden && l();
    });
  }
  function h() {
    b(), c.clear();
  }
  function d(g) {
    if (!i) return;
    e || (e = g, s(), s());
    const a = g - e;
    for (e = g, f += a; f >= o; )
      s(), f -= o;
    const S = f / o;
    r(S), i && (i = n.requestAnimationFrame(d));
  }
  function p() {
    i || (i = n.requestAnimationFrame(d));
  }
  function b() {
    n.cancelAnimationFrame(i), e = null, f = 0, i = 0;
  }
  function l() {
    e = null, f = 0;
  }
  return {
    init: u,
    destroy: h,
    start: p,
    stop: b,
    update: s,
    render: r
  };
}
function nn(t, n) {
  const s = n === "rtl", r = t === "y", c = r ? "y" : "x", o = r ? "x" : "y", e = !r && s ? -1 : 1, f = h(), i = d();
  function u(l) {
    const {
      height: m,
      width: g
    } = l;
    return r ? m : g;
  }
  function h() {
    return r ? "top" : s ? "right" : "left";
  }
  function d() {
    return r ? "bottom" : s ? "left" : "right";
  }
  function p(l) {
    return l * e;
  }
  return {
    scroll: c,
    cross: o,
    startEdge: f,
    endEdge: i,
    measureSize: u,
    direction: p
  };
}
function tt(t = 0, n = 0) {
  const s = P(t - n);
  function r(u) {
    return u < t;
  }
  function c(u) {
    return u > n;
  }
  function o(u) {
    return r(u) || c(u);
  }
  function e(u) {
    return o(u) ? r(u) ? t : n : u;
  }
  function f(u) {
    return s ? u - s * Math.ceil((u - n) / s) : u;
  }
  return {
    length: s,
    max: n,
    min: t,
    constrain: e,
    reachedAny: o,
    reachedMax: c,
    reachedMin: r,
    removeOffset: f
  };
}
function kt(t, n, s) {
  const {
    constrain: r
  } = tt(0, t), c = t + 1;
  let o = e(n);
  function e(p) {
    return s ? P((c + p) % c) : r(p);
  }
  function f() {
    return o;
  }
  function i(p) {
    return o = e(p), d;
  }
  function u(p) {
    return h().set(f() + p);
  }
  function h() {
    return kt(t, f(), s);
  }
  const d = {
    get: f,
    set: i,
    add: u,
    clone: h
  };
  return d;
}
function en(t, n, s, r, c, o, e, f, i, u, h, d, p, b, l, m, g, a, S) {
  const {
    cross: x,
    direction: T
  } = t, M = ["INPUT", "SELECT", "TEXTAREA"], I = {
    passive: !1
  }, L = dt(), E = dt(), v = tt(50, 225).constrain(b.measure(20)), C = {
    mouse: 300,
    touch: 400
  }, D = {
    mouse: 500,
    touch: 600
  }, V = l ? 43 : 25;
  let G = !1, H = 0, j = 0, J = !1, Y = !1, U = !1, $ = !1;
  function st(y) {
    if (!S) return;
    function A(N) {
      (gt(S) || S(y, N)) && it(N);
    }
    const O = n;
    L.add(O, "dragstart", (N) => N.preventDefault(), I).add(O, "touchmove", () => {
    }, I).add(O, "touchend", () => {
    }).add(O, "touchstart", A).add(O, "mousedown", A).add(O, "touchcancel", w).add(O, "contextmenu", w).add(O, "click", K, !0);
  }
  function R() {
    L.clear(), E.clear();
  }
  function nt() {
    const y = $ ? s : n;
    E.add(y, "touchmove", z, I).add(y, "touchend", w).add(y, "mousemove", z, I).add(y, "mouseup", w);
  }
  function et(y) {
    const A = y.nodeName || "";
    return M.includes(A);
  }
  function Q() {
    return (l ? D : C)[$ ? "mouse" : "touch"];
  }
  function rt(y, A) {
    const O = d.add(It(y) * -1), N = h.byDistance(y, !l).distance;
    return l || P(y) < v ? N : g && A ? N * 0.5 : h.byIndex(O.get(), 0).distance;
  }
  function it(y) {
    const A = Et(y, r);
    $ = A, U = l && A && !y.buttons && G, G = ft(c.get(), e.get()) >= 2, !(A && y.button !== 0) && (et(y.target) || (J = !0, o.pointerDown(y), u.useFriction(0).useDuration(0), c.set(e), nt(), H = o.readPoint(y), j = o.readPoint(y, x), p.emit("pointerDown")));
  }
  function z(y) {
    if (!Et(y, r) && y.touches.length >= 2) return w(y);
    const O = o.readPoint(y), N = o.readPoint(y, x), q = ft(O, H), X = ft(N, j);
    if (!Y && !$ && (!y.cancelable || (Y = q > X, !Y)))
      return w(y);
    const Z = o.pointerMove(y);
    q > m && (U = !0), u.useFriction(0.3).useDuration(0.75), f.start(), c.add(T(Z)), y.preventDefault();
  }
  function w(y) {
    const O = h.byDistance(0, !1).index !== d.get(), N = o.pointerUp(y) * Q(), q = rt(T(N), O), X = Jt(N, q), Z = V - 10 * X, _ = a + X / 50;
    Y = !1, J = !1, E.clear(), u.useDuration(Z).useFriction(_), i.distance(q, !l), $ = !1, p.emit("pointerUp");
  }
  function K(y) {
    U && (y.stopPropagation(), y.preventDefault(), U = !1);
  }
  function B() {
    return J;
  }
  return {
    init: st,
    destroy: R,
    pointerDown: B
  };
}
function on(t, n) {
  let r, c;
  function o(d) {
    return d.timeStamp;
  }
  function e(d, p) {
    const l = `client${(p || t.scroll) === "x" ? "X" : "Y"}`;
    return (Et(d, n) ? d : d.touches[0])[l];
  }
  function f(d) {
    return r = d, c = d, e(d);
  }
  function i(d) {
    const p = e(d) - e(c), b = o(d) - o(r) > 170;
    return c = d, b && (r = d), p;
  }
  function u(d) {
    if (!r || !c) return 0;
    const p = e(c) - e(r), b = o(d) - o(r), l = o(d) - o(c) > 170, m = p / b;
    return b && !l && P(m) > 0.1 ? m : 0;
  }
  return {
    pointerDown: f,
    pointerMove: i,
    pointerUp: u,
    readPoint: e
  };
}
function sn() {
  function t(s) {
    const {
      offsetTop: r,
      offsetLeft: c,
      offsetWidth: o,
      offsetHeight: e
    } = s;
    return {
      top: r,
      right: c + o,
      bottom: r + e,
      left: c,
      width: o,
      height: e
    };
  }
  return {
    measure: t
  };
}
function rn(t) {
  function n(r) {
    return t * (r / 100);
  }
  return {
    measure: n
  };
}
function cn(t, n, s, r, c, o, e) {
  const f = [t].concat(r);
  let i, u, h = [], d = !1;
  function p(g) {
    return c.measureSize(e.measure(g));
  }
  function b(g) {
    if (!o) return;
    u = p(t), h = r.map(p);
    function a(S) {
      for (const x of S) {
        if (d) return;
        const T = x.target === t, M = r.indexOf(x.target), I = T ? u : h[M], L = p(T ? t : r[M]);
        if (P(L - I) >= 0.5) {
          g.reInit(), n.emit("resize");
          break;
        }
      }
    }
    i = new ResizeObserver((S) => {
      (gt(o) || o(g, S)) && a(S);
    }), s.requestAnimationFrame(() => {
      f.forEach((S) => i.observe(S));
    });
  }
  function l() {
    d = !0, i && i.disconnect();
  }
  return {
    init: b,
    destroy: l
  };
}
function un(t, n, s, r, c, o) {
  let e = 0, f = 0, i = c, u = o, h = t.get(), d = 0;
  function p() {
    const I = r.get() - t.get(), L = !i;
    let E = 0;
    return L ? (e = 0, s.set(r), t.set(r), E = I) : (s.set(t), e += I / i, e *= u, h += e, t.add(e), E = h - d), f = It(E), d = h, M;
  }
  function b() {
    const I = r.get() - n.get();
    return P(I) < 1e-3;
  }
  function l() {
    return i;
  }
  function m() {
    return f;
  }
  function g() {
    return e;
  }
  function a() {
    return x(c);
  }
  function S() {
    return T(o);
  }
  function x(I) {
    return i = I, M;
  }
  function T(I) {
    return u = I, M;
  }
  const M = {
    direction: m,
    duration: l,
    velocity: g,
    seek: p,
    settled: b,
    useBaseFriction: S,
    useBaseDuration: a,
    useFriction: T,
    useDuration: x
  };
  return M;
}
function fn(t, n, s, r, c) {
  const o = c.measure(10), e = c.measure(50), f = tt(0.1, 0.99);
  let i = !1;
  function u() {
    return !(i || !t.reachedAny(s.get()) || !t.reachedAny(n.get()));
  }
  function h(b) {
    if (!u()) return;
    const l = t.reachedMin(n.get()) ? "min" : "max", m = P(t[l] - n.get()), g = s.get() - n.get(), a = f.constrain(m / e);
    s.subtract(g * a), !b && P(g) < o && (s.set(t.constrain(s.get())), r.useDuration(25).useBaseFriction());
  }
  function d(b) {
    i = !b;
  }
  return {
    shouldConstrain: u,
    constrain: h,
    toggleActive: d
  };
}
function an(t, n, s, r, c) {
  const o = tt(-n + t, 0), e = d(), f = h(), i = p();
  function u(l, m) {
    return ft(l, m) <= 1;
  }
  function h() {
    const l = e[0], m = k(e), g = e.lastIndexOf(l), a = e.indexOf(m) + 1;
    return tt(g, a);
  }
  function d() {
    return s.map((l, m) => {
      const {
        min: g,
        max: a
      } = o, S = o.constrain(l), x = !m, T = vt(s, m);
      return x ? a : T || u(g, S) ? g : u(a, S) ? a : S;
    }).map((l) => parseFloat(l.toFixed(3)));
  }
  function p() {
    if (n <= t + c) return [o.max];
    if (r === "keepSnaps") return e;
    const {
      min: l,
      max: m
    } = f;
    return e.slice(l, m);
  }
  return {
    snapsContained: i,
    scrollContainLimit: f
  };
}
function ln(t, n, s) {
  const r = n[0], c = s ? r - t : k(n);
  return {
    limit: tt(c, r)
  };
}
function dn(t, n, s, r) {
  const o = n.min + 0.1, e = n.max + 0.1, {
    reachedMin: f,
    reachedMax: i
  } = tt(o, e);
  function u(p) {
    return p === 1 ? i(s.get()) : p === -1 ? f(s.get()) : !1;
  }
  function h(p) {
    if (!u(p)) return;
    const b = t * (p * -1);
    r.forEach((l) => l.add(b));
  }
  return {
    loop: h
  };
}
function pn(t) {
  const {
    max: n,
    length: s
  } = t;
  function r(o) {
    const e = o - n;
    return s ? e / -s : 0;
  }
  return {
    get: r
  };
}
function mn(t, n, s, r, c) {
  const {
    startEdge: o,
    endEdge: e
  } = t, {
    groupSlides: f
  } = c, i = d().map(n.measure), u = p(), h = b();
  function d() {
    return f(r).map((m) => k(m)[e] - m[0][o]).map(P);
  }
  function p() {
    return r.map((m) => s[o] - m[o]).map((m) => -P(m));
  }
  function b() {
    return f(u).map((m) => m[0]).map((m, g) => m + i[g]);
  }
  return {
    snaps: u,
    snapsAligned: h
  };
}
function gn(t, n, s, r, c, o) {
  const {
    groupSlides: e
  } = c, {
    min: f,
    max: i
  } = r, u = h();
  function h() {
    const p = e(o), b = !t || n === "keepSnaps";
    return s.length === 1 ? [o] : b ? p : p.slice(f, i).map((l, m, g) => {
      const a = !m, S = vt(g, m);
      if (a) {
        const x = k(g[0]) + 1;
        return zt(x);
      }
      if (S) {
        const x = pt(o) - k(g)[0] + 1;
        return zt(x, k(g)[0]);
      }
      return l;
    });
  }
  return {
    slideRegistry: u
  };
}
function hn(t, n, s, r, c) {
  const {
    reachedAny: o,
    removeOffset: e,
    constrain: f
  } = r;
  function i(l) {
    return l.concat().sort((m, g) => P(m) - P(g))[0];
  }
  function u(l) {
    const m = t ? e(l) : f(l), g = n.map((S, x) => ({
      diff: h(S - m, 0),
      index: x
    })).sort((S, x) => P(S.diff) - P(x.diff)), {
      index: a
    } = g[0];
    return {
      index: a,
      distance: m
    };
  }
  function h(l, m) {
    const g = [l, l + s, l - s];
    if (!t) return l;
    if (!m) return i(g);
    const a = g.filter((S) => It(S) === m);
    return a.length ? i(a) : k(g) - s;
  }
  function d(l, m) {
    const g = n[l] - c.get(), a = h(g, m);
    return {
      index: l,
      distance: a
    };
  }
  function p(l, m) {
    const g = c.get() + l, {
      index: a,
      distance: S
    } = u(g), x = !t && o(g);
    if (!m || x) return {
      index: a,
      distance: l
    };
    const T = n[a] - S, M = l + h(T, 0);
    return {
      index: a,
      distance: M
    };
  }
  return {
    byDistance: p,
    byIndex: d,
    shortcut: h
  };
}
function Sn(t, n, s, r, c, o, e) {
  function f(d) {
    const p = d.distance, b = d.index !== n.get();
    o.add(p), p && (r.duration() ? t.start() : (t.update(), t.render(1), t.update())), b && (s.set(n.get()), n.set(d.index), e.emit("select"));
  }
  function i(d, p) {
    const b = c.byDistance(d, p);
    f(b);
  }
  function u(d, p) {
    const b = n.clone().set(d), l = c.byIndex(b.get(), p);
    f(l);
  }
  return {
    distance: i,
    index: u
  };
}
function yn(t, n, s, r, c, o, e, f) {
  const i = {
    passive: !0,
    capture: !0
  };
  let u = 0;
  function h(b) {
    if (!f) return;
    function l(m) {
      if ((/* @__PURE__ */ new Date()).getTime() - u > 10) return;
      e.emit("slideFocusStart"), t.scrollLeft = 0;
      const S = s.findIndex((x) => x.includes(m));
      Tt(S) && (c.useDuration(0), r.index(S, 0), e.emit("slideFocus"));
    }
    o.add(document, "keydown", d, !1), n.forEach((m, g) => {
      o.add(m, "focus", (a) => {
        (gt(f) || f(b, a)) && l(g);
      }, i);
    });
  }
  function d(b) {
    b.code === "Tab" && (u = (/* @__PURE__ */ new Date()).getTime());
  }
  return {
    init: h
  };
}
function ut(t) {
  let n = t;
  function s() {
    return n;
  }
  function r(i) {
    n = e(i);
  }
  function c(i) {
    n += e(i);
  }
  function o(i) {
    n -= e(i);
  }
  function e(i) {
    return Tt(i) ? i : i.get();
  }
  return {
    get: s,
    set: r,
    add: c,
    subtract: o
  };
}
function Gt(t, n) {
  const s = t.scroll === "x" ? e : f, r = n.style;
  let c = null, o = !1;
  function e(p) {
    return `translate3d(${p}px,0px,0px)`;
  }
  function f(p) {
    return `translate3d(0px,${p}px,0px)`;
  }
  function i(p) {
    if (o) return;
    const b = Zt(t.direction(p));
    b !== c && (r.transform = s(b), c = b);
  }
  function u(p) {
    o = !p;
  }
  function h() {
    o || (r.transform = "", n.getAttribute("style") || n.removeAttribute("style"));
  }
  return {
    clear: h,
    to: i,
    toggleActive: u
  };
}
function bn(t, n, s, r, c, o, e, f, i) {
  const h = at(c), d = at(c).reverse(), p = a().concat(S());
  function b(L, E) {
    return L.reduce((v, C) => v - c[C], E);
  }
  function l(L, E) {
    return L.reduce((v, C) => b(v, E) > 0 ? v.concat([C]) : v, []);
  }
  function m(L) {
    return o.map((E, v) => ({
      start: E - r[v] + 0.5 + L,
      end: E + n - 0.5 + L
    }));
  }
  function g(L, E, v) {
    const C = m(E);
    return L.map((D) => {
      const V = v ? 0 : -s, G = v ? s : 0, H = v ? "end" : "start", j = C[D][H];
      return {
        index: D,
        loopPoint: j,
        slideLocation: ut(-1),
        translate: Gt(t, i[D]),
        target: () => f.get() > j ? V : G
      };
    });
  }
  function a() {
    const L = e[0], E = l(d, L);
    return g(E, s, !1);
  }
  function S() {
    const L = n - e[0] - 1, E = l(h, L);
    return g(E, -s, !0);
  }
  function x() {
    return p.every(({
      index: L
    }) => {
      const E = h.filter((v) => v !== L);
      return b(E, n) <= 0.1;
    });
  }
  function T() {
    p.forEach((L) => {
      const {
        target: E,
        translate: v,
        slideLocation: C
      } = L, D = E();
      D !== C.get() && (v.to(D), C.set(D));
    });
  }
  function M() {
    p.forEach((L) => L.translate.clear());
  }
  return {
    canLoop: x,
    clear: M,
    loop: T,
    loopPoints: p
  };
}
function xn(t, n, s) {
  let r, c = !1;
  function o(i) {
    if (!s) return;
    function u(h) {
      for (const d of h)
        if (d.type === "childList") {
          i.reInit(), n.emit("slidesChanged");
          break;
        }
    }
    r = new MutationObserver((h) => {
      c || (gt(s) || s(i, h)) && u(h);
    }), r.observe(t, {
      childList: !0
    });
  }
  function e() {
    r && r.disconnect(), c = !0;
  }
  return {
    init: o,
    destroy: e
  };
}
function Ln(t, n, s, r) {
  const c = {};
  let o = null, e = null, f, i = !1;
  function u() {
    f = new IntersectionObserver((l) => {
      i || (l.forEach((m) => {
        const g = n.indexOf(m.target);
        c[g] = m;
      }), o = null, e = null, s.emit("slidesInView"));
    }, {
      root: t.parentElement,
      threshold: r
    }), n.forEach((l) => f.observe(l));
  }
  function h() {
    f && f.disconnect(), i = !0;
  }
  function d(l) {
    return lt(c).reduce((m, g) => {
      const a = parseInt(g), {
        isIntersecting: S
      } = c[a];
      return (l && S || !l && !S) && m.push(a), m;
    }, []);
  }
  function p(l = !0) {
    if (l && o) return o;
    if (!l && e) return e;
    const m = d(l);
    return l && (o = m), l || (e = m), m;
  }
  return {
    init: u,
    destroy: h,
    get: p
  };
}
function En(t, n, s, r, c, o) {
  const {
    measureSize: e,
    startEdge: f,
    endEdge: i
  } = t, u = s[0] && c, h = l(), d = m(), p = s.map(e), b = g();
  function l() {
    if (!u) return 0;
    const S = s[0];
    return P(n[f] - S[f]);
  }
  function m() {
    if (!u) return 0;
    const S = o.getComputedStyle(k(r));
    return parseFloat(S.getPropertyValue(`margin-${i}`));
  }
  function g() {
    return s.map((S, x, T) => {
      const M = !x, I = vt(T, x);
      return M ? p[x] + h : I ? p[x] + d : T[x + 1][f] - S[f];
    }).map(P);
  }
  return {
    slideSizes: p,
    slideSizesWithGaps: b,
    startGap: h,
    endGap: d
  };
}
function Tn(t, n, s, r, c, o, e, f, i) {
  const {
    startEdge: u,
    endEdge: h,
    direction: d
  } = t, p = Tt(s);
  function b(a, S) {
    return at(a).filter((x) => x % S === 0).map((x) => a.slice(x, x + S));
  }
  function l(a) {
    return a.length ? at(a).reduce((S, x, T) => {
      const M = k(S) || 0, I = M === 0, L = x === pt(a), E = c[u] - o[M][u], v = c[u] - o[x][h], C = !r && I ? d(e) : 0, D = !r && L ? d(f) : 0, V = P(v - D - (E + C));
      return T && V > n + i && S.push(x), L && S.push(a.length), S;
    }, []).map((S, x, T) => {
      const M = Math.max(T[x - 1] || 0);
      return a.slice(M, S);
    }) : [];
  }
  function m(a) {
    return p ? b(a, s) : l(a);
  }
  return {
    groupSlides: m
  };
}
function In(t, n, s, r, c, o, e) {
  const {
    align: f,
    axis: i,
    direction: u,
    startIndex: h,
    loop: d,
    duration: p,
    dragFree: b,
    dragThreshold: l,
    inViewThreshold: m,
    slidesToScroll: g,
    skipSnaps: a,
    containScroll: S,
    watchResize: x,
    watchSlides: T,
    watchDrag: M,
    watchFocus: I
  } = o, L = 2, E = sn(), v = E.measure(n), C = s.map(E.measure), D = nn(i, u), V = D.measureSize(v), G = rn(V), H = Wt(f, V), j = !d && !!S, J = d || !!S, {
    slideSizes: Y,
    slideSizesWithGaps: U,
    startGap: $,
    endGap: st
  } = En(D, v, C, s, J, c), R = Tn(D, V, g, d, v, C, $, st, L), {
    snaps: nt,
    snapsAligned: et
  } = mn(D, H, v, C, R), Q = -k(nt) + k(U), {
    snapsContained: rt,
    scrollContainLimit: it
  } = an(V, Q, et, S, L), z = j ? rt : et, {
    limit: w
  } = ln(Q, z, d), K = kt(pt(z), h, d), B = K.clone(), F = at(s), y = ({
    dragHandler: ot,
    scrollBody: bt,
    scrollBounds: xt,
    options: {
      loop: mt
    }
  }) => {
    mt || xt.constrain(ot.pointerDown()), bt.seek();
  }, A = ({
    scrollBody: ot,
    translate: bt,
    location: xt,
    offsetLocation: mt,
    previousLocation: qt,
    scrollLooper: Ut,
    slideLooper: $t,
    dragHandler: Qt,
    animation: Kt,
    eventHandler: Ft,
    scrollBounds: Xt,
    options: {
      loop: Pt
    }
  }, Ct) => {
    const Ot = ot.settled(), Yt = !Xt.shouldConstrain(), wt = Pt ? Ot : Ot && Yt, Nt = wt && !Qt.pointerDown();
    Nt && Kt.stop();
    const _t = xt.get() * Ct + qt.get() * (1 - Ct);
    mt.set(_t), Pt && (Ut.loop(ot.direction()), $t.loop()), bt.to(mt.get()), Nt && Ft.emit("settle"), wt || Ft.emit("scroll");
  }, O = tn(r, c, () => y(yt), (ot) => A(yt, ot)), N = 0.68, q = z[K.get()], X = ut(q), Z = ut(q), _ = ut(q), W = ut(q), ct = un(X, _, Z, W, p, N), ht = hn(d, z, Q, w, W), St = Sn(O, K, B, ct, ht, W, e), Dt = pn(w), At = dt(), jt = Ln(n, s, e, m), {
    slideRegistry: Mt
  } = gn(j, S, z, it, R, F), Rt = yn(t, s, Mt, St, ct, At, e, I), yt = {
    ownerDocument: r,
    ownerWindow: c,
    eventHandler: e,
    containerRect: v,
    slideRects: C,
    animation: O,
    axis: D,
    dragHandler: en(D, t, r, c, W, on(D, c), X, O, St, ct, ht, K, e, G, b, l, a, N, M),
    eventStore: At,
    percentOfView: G,
    index: K,
    indexPrevious: B,
    limit: w,
    location: X,
    offsetLocation: _,
    previousLocation: Z,
    options: o,
    resizeHandler: cn(n, e, c, s, D, x, E),
    scrollBody: ct,
    scrollBounds: fn(w, _, W, ct, G),
    scrollLooper: dn(Q, w, _, [X, _, Z, W]),
    scrollProgress: Dt,
    scrollSnapList: z.map(Dt.get),
    scrollSnaps: z,
    scrollTarget: ht,
    scrollTo: St,
    slideLooper: bn(D, V, Q, Y, U, nt, z, _, s),
    slideFocus: Rt,
    slidesHandler: xn(n, e, T),
    slidesInView: jt,
    slideIndexes: F,
    slideRegistry: Mt,
    slidesToScroll: R,
    target: W,
    translate: Gt(D, n)
  };
  return yt;
}
function vn() {
  let t = {}, n;
  function s(u) {
    n = u;
  }
  function r(u) {
    return t[u] || [];
  }
  function c(u) {
    return r(u).forEach((h) => h(n, u)), i;
  }
  function o(u, h) {
    return t[u] = r(u).concat([h]), i;
  }
  function e(u, h) {
    return t[u] = r(u).filter((d) => d !== h), i;
  }
  function f() {
    t = {};
  }
  const i = {
    init: s,
    emit: c,
    off: e,
    on: o,
    clear: f
  };
  return i;
}
const Dn = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  inViewThreshold: 0,
  breakpoints: {},
  dragFree: !1,
  dragThreshold: 10,
  loop: !1,
  skipSnaps: !1,
  duration: 25,
  startIndex: 0,
  active: !0,
  watchDrag: !0,
  watchResize: !0,
  watchSlides: !0,
  watchFocus: !0
};
function An(t) {
  function n(o, e) {
    return Bt(o, e || {});
  }
  function s(o) {
    const e = o.breakpoints || {}, f = lt(e).filter((i) => t.matchMedia(i).matches).map((i) => e[i]).reduce((i, u) => n(i, u), {});
    return n(o, f);
  }
  function r(o) {
    return o.map((e) => lt(e.breakpoints || {})).reduce((e, f) => e.concat(f), []).map(t.matchMedia);
  }
  return {
    mergeOptions: n,
    optionsAtMedia: s,
    optionsMediaQueries: r
  };
}
function Mn(t) {
  let n = [];
  function s(o, e) {
    return n = e.filter(({
      options: f
    }) => t.optionsAtMedia(f).active !== !1), n.forEach((f) => f.init(o, t)), e.reduce((f, i) => Object.assign(f, {
      [i.name]: i
    }), {});
  }
  function r() {
    n = n.filter((o) => o.destroy());
  }
  return {
    init: s,
    destroy: r
  };
}
function Ht(t, n, s) {
  const r = t.ownerDocument, c = r.defaultView, o = An(c), e = Mn(o), f = dt(), i = vn(), {
    mergeOptions: u,
    optionsAtMedia: h,
    optionsMediaQueries: d
  } = o, {
    on: p,
    off: b,
    emit: l
  } = i, m = D;
  let g = !1, a, S = u(Dn, Ht.globalOptions), x = u(S), T = [], M, I, L;
  function E() {
    const {
      container: F,
      slides: y
    } = x;
    I = (Lt(F) ? t.querySelector(F) : F) || t.children[0];
    const O = Lt(y) ? I.querySelectorAll(y) : y;
    L = [].slice.call(O || I.children);
  }
  function v(F) {
    const y = In(t, I, L, r, c, F, i);
    if (F.loop && !y.slideLooper.canLoop()) {
      const A = Object.assign({}, F, {
        loop: !1
      });
      return v(A);
    }
    return y;
  }
  function C(F, y) {
    g || (S = u(S, F), x = h(S), T = y || T, E(), a = v(x), d([S, ...T.map(({
      options: A
    }) => A)]).forEach((A) => f.add(A, "change", D)), x.active && (a.translate.to(a.location.get()), a.animation.init(), a.slidesInView.init(), a.slideFocus.init(B), a.eventHandler.init(B), a.resizeHandler.init(B), a.slidesHandler.init(B), a.options.loop && a.slideLooper.loop(), I.offsetParent && L.length && a.dragHandler.init(B), M = e.init(B, T)));
  }
  function D(F, y) {
    const A = R();
    V(), C(u({
      startIndex: A
    }, F), y), i.emit("reInit");
  }
  function V() {
    a.dragHandler.destroy(), a.eventStore.clear(), a.translate.clear(), a.slideLooper.clear(), a.resizeHandler.destroy(), a.slidesHandler.destroy(), a.slidesInView.destroy(), a.animation.destroy(), e.destroy(), f.clear();
  }
  function G() {
    g || (g = !0, f.clear(), V(), i.emit("destroy"), i.clear());
  }
  function H(F, y, A) {
    !x.active || g || (a.scrollBody.useBaseFriction().useDuration(y === !0 ? 0 : x.duration), a.scrollTo.index(F, A || 0));
  }
  function j(F) {
    const y = a.index.add(1).get();
    H(y, F, -1);
  }
  function J(F) {
    const y = a.index.add(-1).get();
    H(y, F, 1);
  }
  function Y() {
    return a.index.add(1).get() !== R();
  }
  function U() {
    return a.index.add(-1).get() !== R();
  }
  function $() {
    return a.scrollSnapList;
  }
  function st() {
    return a.scrollProgress.get(a.offsetLocation.get());
  }
  function R() {
    return a.index.get();
  }
  function nt() {
    return a.indexPrevious.get();
  }
  function et() {
    return a.slidesInView.get();
  }
  function Q() {
    return a.slidesInView.get(!1);
  }
  function rt() {
    return M;
  }
  function it() {
    return a;
  }
  function z() {
    return t;
  }
  function w() {
    return I;
  }
  function K() {
    return L;
  }
  const B = {
    canScrollNext: Y,
    canScrollPrev: U,
    containerNode: w,
    internalEngine: it,
    destroy: G,
    off: b,
    on: p,
    emit: l,
    plugins: rt,
    previousScrollSnap: nt,
    reInit: m,
    rootNode: z,
    scrollNext: j,
    scrollPrev: J,
    scrollProgress: st,
    scrollSnapList: $,
    scrollTo: H,
    selectedScrollSnap: R,
    slideNodes: K,
    slidesInView: et,
    slidesNotInView: Q
  };
  return C(n, s), setTimeout(() => i.emit("init"), 0), B;
}
Ht.globalOptions = void 0;
export {
  Ht as default
};
//# sourceMappingURL=embla-carousel.esm.js.map
