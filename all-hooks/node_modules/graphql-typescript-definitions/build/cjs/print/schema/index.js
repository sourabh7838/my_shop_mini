'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var t = require('@babel/types');
var babelGenerator = require('@babel/generator');
var changeCase = require('change-case');
var graphql = require('graphql');
var utilities = require('../utilities.js');
var types = require('../../types.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var t__namespace = /*#__PURE__*/_interopNamespace(t);
var babelGenerator__default = /*#__PURE__*/_interopDefaultLegacy(babelGenerator);

var _default;

// The version of @babel/generator we depend on has a strange build process
// that doesnâ€™t work consistently in ESM and non-ESM consumers. This hacky bit of
// code makes sure we get the actual `generate()` function in both runtimes.
const generate = (_default = babelGenerator__default["default"].default) !== null && _default !== void 0 ? _default : babelGenerator__default["default"];
function generateSchemaTypes(schema, options = {}) {
  const importFileBody = [];
  const exportFileBody = [];
  const definitions = new Map();
  for (const type of Object.values(schema.getTypeMap())) {
    if (!graphql.isInputType(type) || type.name.startsWith('__')) {
      continue;
    }
    if (graphql.isScalarType(type) && Object.prototype.hasOwnProperty.call(utilities.scalarTypeMap, type.name)) {
      continue;
    }
    if (graphql.isEnumType(type)) {
      const enumType = tsEnumForType(type, options);
      definitions.set(`${enumType.id.name}.ts`, generate(t__namespace.file(t__namespace.program([t__namespace.exportNamedDeclaration(enumType, [])]), [], [])).code);
      importFileBody.unshift(t__namespace.importDeclaration([t__namespace.importSpecifier(enumType.id, enumType.id)], t__namespace.stringLiteral(`./${enumType.id.name}`)));
      exportFileBody.unshift(t__namespace.exportNamedDeclaration(null, [t__namespace.exportSpecifier(enumType.id, enumType.id)]));
    } else if (graphql.isScalarType(type)) {
      const {
        customScalars = {}
      } = options;
      const customScalarDefinition = customScalars[type.name];
      const scalarType = tsScalarForType(type, customScalarDefinition);
      if (customScalarDefinition && customScalarDefinition.package) {
        importFileBody.unshift(t__namespace.importDeclaration([t__namespace.importSpecifier(t__namespace.identifier(makeCustomScalarImportNameSafe(customScalarDefinition.name, type.name)), t__namespace.identifier(customScalarDefinition.name))], t__namespace.stringLiteral(customScalarDefinition.package)));
        exportFileBody.unshift(t__namespace.exportNamedDeclaration(scalarType, []));
      } else {
        exportFileBody.push(t__namespace.exportNamedDeclaration(scalarType, []));
      }
    } else {
      exportFileBody.push(t__namespace.exportNamedDeclaration(tsInputObjectForType(type), []));
    }
  }

  // A blank file is ambiguous - its not clear if it is a script or a module.
  // If the file would be blank then give it an empty `export {}` to make in
  // unambiguously an es module file.
  // This ensures the generated files passes TypeScript type checking in
  // "isolatedModules" mode.
  if (exportFileBody.length === 0) {
    exportFileBody.push(t__namespace.exportNamedDeclaration(null, []));
  }
  return definitions.set('index.ts', generate(t__namespace.file(t__namespace.program(importFileBody.concat(exportFileBody)), [], [])).code);
}
function tsTypeForInputType(type) {
  const unwrappedType = graphql.isNonNullType(type) ? type.ofType : type;
  let tsType;
  if (graphql.isListType(unwrappedType)) {
    const tsTypeOfContainedType = tsTypeForInputType(unwrappedType.ofType);
    tsType = t__namespace.tsArrayType(t__namespace.isTSUnionType(tsTypeOfContainedType) ? t__namespace.tsParenthesizedType(tsTypeOfContainedType) : tsTypeOfContainedType);
  } else if (graphql.isScalarType(unwrappedType)) {
    tsType = utilities.scalarTypeMap[unwrappedType.name] || t__namespace.tsTypeReference(t__namespace.identifier(unwrappedType.name));
  } else {
    tsType = t__namespace.tsTypeReference(t__namespace.identifier(unwrappedType.name));
  }
  return graphql.isNonNullType(type) ? tsType : t__namespace.tsUnionType([tsType, t__namespace.tsNullKeyword()]);
}
function tsInputObjectForType(type) {
  const fields = Object.entries(type.getFields()).map(([name, field]) => {
    const property = t__namespace.tsPropertySignature(t__namespace.identifier(name), t__namespace.tsTypeAnnotation(tsTypeForInputType(field.type)));
    property.optional = !graphql.isNonNullType(field.type);
    return property;
  });
  return t__namespace.tsInterfaceDeclaration(t__namespace.identifier(type.name), null, null, t__namespace.tsInterfaceBody(fields));
}
function tsScalarForType(type, customScalarDefinition) {
  let alias;
  if (customScalarDefinition && customScalarDefinition.package) {
    alias = t__namespace.tsTypeReference(t__namespace.identifier(makeCustomScalarImportNameSafe(customScalarDefinition.name, type.name)));
  } else if (customScalarDefinition) {
    alias = t__namespace.tsTypeReference(t__namespace.identifier(customScalarDefinition.name));
  } else {
    alias = t__namespace.tsStringKeyword();
  }
  return t__namespace.tsTypeAliasDeclaration(t__namespace.identifier(type.name), null, alias);
}
function makeCustomScalarImportNameSafe(importName, typeName) {
  return `__${typeName}__${importName}`;
}
function tsEnumForType(type, {
  enumFormat
}) {
  return t__namespace.tsEnumDeclaration(t__namespace.identifier(type.name), type.getValues().map(value => t__namespace.tsEnumMember(t__namespace.identifier(enumMemberName(value.name, enumFormat)), t__namespace.stringLiteral(value.name))));
}
function enumMemberName(name, format) {
  switch (format) {
    case types.EnumFormat.CamelCase:
      return changeCase.camelCase(name);
    case types.EnumFormat.PascalCase:
      return changeCase.pascalCase(name);
    case types.EnumFormat.SnakeCase:
      return changeCase.snakeCase(name);
    case types.EnumFormat.ScreamingSnakeCase:
      return changeCase.snakeCase(name).toUpperCase();
    default:
      return name;
  }
}

exports.generateSchemaTypes = generateSchemaTypes;
