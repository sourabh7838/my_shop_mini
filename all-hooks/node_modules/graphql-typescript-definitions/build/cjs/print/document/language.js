'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var t = require('@babel/types');
var graphql = require('graphql');
var graphqlToolUtilities = require('graphql-tool-utilities');
var utilities = require('../utilities.js');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var t__namespace = /*#__PURE__*/_interopNamespace(t);

function tsInterfaceBodyForObjectField({
  fields = []
}, graphQLType, stack, context, requiresTypename = false) {
  const {
    schema
  } = context.ast;
  const isRootType = !Array.isArray(graphQLType) && (graphQLType === schema.getQueryType() || graphQLType === schema.getMutationType() || graphQLType === schema.getSubscriptionType());
  const uniqueFields = fields.filter(field => {
    if (stack.hasSeenField(field)) {
      return false;
    }
    stack.sawField(field);
    return true;
  });
  const typenameField = {
    fieldName: '__typename',
    responseName: '__typename',
    type: new graphql.GraphQLNonNull(graphql.GraphQLString),
    isConditional: false
  };
  const typename = (context.options.addTypename && !isRootType || requiresTypename) && !stack.hasSeenField(typenameField) ? tsPropertyForField(typenameField, graphQLType, stack, context, requiresTypename) : null;
  const body = uniqueFields.map(field => tsPropertyForField(field, graphQLType, stack, context, requiresTypename));
  return t__namespace.tsInterfaceBody(typename ? [typename, ...body] : body);
}
function tsTypeForInlineFragment(inlineFragment, _graphQLType, stack, context, requiresTypename = false) {
  const {
    typeCondition
  } = inlineFragment;
  const interfaceDeclaration = t__namespace.tsInterfaceDeclaration(t__namespace.identifier(stack.name), null, null, tsInterfaceBodyForObjectField(inlineFragment, typeCondition, stack, context, requiresTypename));
  return context.export(interfaceDeclaration);
}
function tsTypeForObjectField(field, graphQLType, stack, context) {
  const {
    inlineFragments = []
  } = field;
  const possibleTypes = graphql.isInterfaceType(graphQLType) || graphql.isUnionType(graphQLType) ? context.ast.schema.getPossibleTypes(graphQLType) : [];
  if (inlineFragments.length) {
    const fragmentTypes = [...inlineFragments].map(inlineFragment => tsTypeForInlineFragment(inlineFragment, graphQLType, stack.fragment(inlineFragment.typeCondition), context, context.options.partial));
    const typesCoveredByInlineFragments = new Set([...inlineFragments].reduce((types, inlineFragment) => [...types, ...inlineFragment.possibleTypes], []));
    const missingPossibleTypes = possibleTypes.filter(possibleType => {
      return !typesCoveredByInlineFragments.has(possibleType);
    });
    const otherStack = stack.fragment();
    const otherTypeInterface = t__namespace.tsInterfaceDeclaration(t__namespace.identifier(otherStack.name), null, null, tsInterfaceBodyForObjectField(field, missingPossibleTypes, otherStack, context, context.options.partial));
    const otherType = context.export(otherTypeInterface);
    return t__namespace.tsUnionType([...fragmentTypes, otherType]);
  } else if (possibleTypes.length === 1) {
    // When we have an interface or union type, but no inline fragments, it
    // means that there is only one conforming type for the union/ interface.
    // Here, we construct a "nothing" type that stands in for future additions
    // to the membership of the union/ interface.
    const otherStack = stack.fragment();
    const otherTypeInterface = t__namespace.tsInterfaceDeclaration(t__namespace.identifier(otherStack.name), null, null, tsInterfaceBodyForObjectField({
      fields: []
    }, [], otherStack, context, context.options.partial));
    const interfaceStack = stack.fragment(possibleTypes[0]);
    const interfaceDeclaration = t__namespace.tsInterfaceDeclaration(t__namespace.identifier(interfaceStack.name), null, null, tsInterfaceBodyForObjectField(field, graphQLType, interfaceStack, context));
    return t__namespace.tsUnionType([context.export(interfaceDeclaration), context.export(otherTypeInterface)]);
  }
  const interfaceDeclaration = t__namespace.tsInterfaceDeclaration(t__namespace.identifier(stack.name), null, null, tsInterfaceBodyForObjectField(field, graphQLType, stack, context));
  return context.export(interfaceDeclaration);
}
function tsTypenameForGraphQLType(type) {
  return t__namespace.tsLiteralType(t__namespace.stringLiteral(type.name));
}
function tsPropertyForField(field, parentType, stack, context, isRequiredTypename = false) {
  if (field.fieldName === '__typename' && parentType) {
    const optional = !isRequiredTypename && (context.options.partial || field.isConditional || !graphql.isNonNullType(field.type));
    const parentTypes = Array.isArray(parentType) ? parentType : [parentType];
    const allPossibleTypes = parentTypes.reduce((all, type) => [...all, ...(graphql.isAbstractType(type) ? context.ast.schema.getPossibleTypes(type) : [type])], []);
    let typename;
    if (allPossibleTypes.length === 0) {
      typename = t__namespace.tsLiteralType(t__namespace.stringLiteral(''));
    } else if (allPossibleTypes.length > 1) {
      typename = t__namespace.tsUnionType(allPossibleTypes.map(tsTypenameForGraphQLType));
    } else {
      typename = tsTypenameForGraphQLType(allPossibleTypes[0]);
    }
    const typenameProperty = t__namespace.tsPropertySignature(t__namespace.identifier(field.responseName), optional ? t__namespace.tsTypeAnnotation(t__namespace.tsUnionType([typename, t__namespace.tsNullKeyword()])) : t__namespace.tsTypeAnnotation(typename));
    typenameProperty.optional = optional;
    return typenameProperty;
  }
  const property = t__namespace.tsPropertySignature(t__namespace.identifier(field.responseName), t__namespace.tsTypeAnnotation(tsTypeForGraphQLType(field.type, field, stack, context)));
  property.optional = context.options.partial || field.isConditional || !graphql.isNonNullType(field.type);
  return property;
}
function tsTypeForGraphQLType(graphQLType, field, stack, context) {
  let type;
  const forceNullable = context.options.partial || field.isConditional && graphQLType === field.type;
  const isNonNull = !forceNullable && graphql.isNonNullType(graphQLType);
  const unwrappedGraphQLType = graphql.isNonNullType(graphQLType) ? graphQLType.ofType : graphQLType;
  if (graphql.isScalarType(unwrappedGraphQLType)) {
    if (Object.prototype.hasOwnProperty.call(utilities.scalarTypeMap, unwrappedGraphQLType.name)) {
      type = utilities.scalarTypeMap[unwrappedGraphQLType.name];
    } else {
      context.file.import(unwrappedGraphQLType.name);
      type = t__namespace.tsTypeReference(t__namespace.identifier(unwrappedGraphQLType.name));
    }
  } else if (graphql.isEnumType(unwrappedGraphQLType)) {
    context.file.import(unwrappedGraphQLType.name);
    type = t__namespace.tsTypeReference(t__namespace.identifier(unwrappedGraphQLType.name));
  } else if (graphql.isListType(unwrappedGraphQLType)) {
    const {
      ofType
    } = unwrappedGraphQLType;
    const arrayType = tsTypeForGraphQLType(ofType, field, stack, context);
    type = t__namespace.tsArrayType(t__namespace.isTSUnionType(arrayType) ? t__namespace.tsParenthesizedType(arrayType) : arrayType);
  } else if (graphql.isObjectType(unwrappedGraphQLType) || graphql.isInterfaceType(unwrappedGraphQLType) || graphql.isUnionType(unwrappedGraphQLType)) {
    type = tsTypeForObjectField(field, unwrappedGraphQLType, stack.nested(field, unwrappedGraphQLType), context);
  } else {
    type = t__namespace.tsAnyKeyword();
  }
  return isNonNull ? type : t__namespace.tsUnionType([type, t__namespace.tsNullKeyword()]);
}
function variablesInterface(variables, context) {
  return t__namespace.tsInterfaceDeclaration(t__namespace.identifier('Variables'), null, null, t__namespace.tsInterfaceBody(variables.filter(graphqlToolUtilities.isTypedVariable).map(variable => tsPropertyForVariable(variable, context))));
}
function tsPropertyForVariable({
  name,
  type
}, context) {
  const property = t__namespace.tsPropertySignature(t__namespace.identifier(name), t__namespace.tsTypeAnnotation(tsTypeForGraphQLInputType(type, context)));
  property.optional = !graphql.isNonNullType(type);
  return property;
}
function tsTypeForGraphQLInputType(graphQLType, context) {
  let type;
  const unwrappedGraphQLType = graphql.isNonNullType(graphQLType) ? graphQLType.ofType : graphQLType;
  if (graphql.isScalarType(unwrappedGraphQLType)) {
    if (Object.prototype.hasOwnProperty.call(utilities.scalarTypeMap, unwrappedGraphQLType.name)) {
      type = utilities.scalarTypeMap[unwrappedGraphQLType.name];
    } else {
      context.file.import(unwrappedGraphQLType.name);
      type = t__namespace.tsTypeReference(t__namespace.identifier(unwrappedGraphQLType.name));
    }
  } else if (graphql.isEnumType(unwrappedGraphQLType) || graphql.isInputObjectType(unwrappedGraphQLType)) {
    context.file.import(unwrappedGraphQLType.name);
    type = t__namespace.tsTypeReference(t__namespace.identifier(unwrappedGraphQLType.name));
  } else {
    const {
      ofType
    } = unwrappedGraphQLType;
    const arrayType = tsTypeForGraphQLInputType(ofType, context);
    type = t__namespace.tsArrayType(graphql.isNonNullType(ofType) ? arrayType : t__namespace.tsParenthesizedType(arrayType));
  }
  return graphql.isNonNullType(graphQLType) ? type : t__namespace.tsUnionType([type, t__namespace.tsNullKeyword()]);
}

exports.tsInterfaceBodyForObjectField = tsInterfaceBodyForObjectField;
exports.variablesInterface = variablesInterface;
