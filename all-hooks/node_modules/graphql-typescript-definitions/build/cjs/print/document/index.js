'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var t = require('@babel/types');
var graphqlToolUtilities = require('graphql-tool-utilities');
var babelGenerator = require('@babel/generator');
var types = require('../../types.js');
var context = require('./context.js');
var utilities = require('./utilities.js');
var language = require('./language.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var t__namespace = /*#__PURE__*/_interopNamespace(t);
var babelGenerator__default = /*#__PURE__*/_interopDefaultLegacy(babelGenerator);

var _default;

// The version of @babel/generator we depend on has a strange build process
// that doesnâ€™t work consistently in ESM and non-ESM consumers. This hacky bit of
// code makes sure we get the actual `generate()` function in both runtimes.
const generate = (_default = babelGenerator__default["default"].default) !== null && _default !== void 0 ? _default : babelGenerator__default["default"];
function printDocument({
  path,
  operation,
  fragments
}, ast, options) {
  const file = new context.FileContext(path, options);
  if (operation == null) {
    const fileBody = fragments.reduce((statements, fragment) => {
      const context$1 = new context.OperationContext(fragment, ast, options, file);
      const body = language.tsInterfaceBodyForObjectField(fragment, fragment.typeCondition, new utilities.ObjectStack(fragment.typeCondition), context$1);
      const {
        namespace
      } = context$1;
      return [...statements, ...(namespace ? [t__namespace.exportNamedDeclaration(namespace, [])] : []), t__namespace.exportNamedDeclaration(t__namespace.tsInterfaceDeclaration(t__namespace.identifier(context$1.typeName), null, null, body), [])];
    }, []);
    const {
      schemaImports
    } = file;
    if (schemaImports) {
      fileBody.unshift(schemaImports);
    }
    return generate(t__namespace.file(t__namespace.program(fileBody), [], [])).code;
  }
  const context$1 = new context.OperationContext(operation, ast, options, file);
  const partialContext = new context.OperationContext(operation, ast, {
    ...options,
    partial: true
  }, file);
  let rootType;
  if (operation.operationType === graphqlToolUtilities.OperationType.Query) {
    rootType = ast.schema.getQueryType();
  } else if (operation.operationType === graphqlToolUtilities.OperationType.Mutation) {
    rootType = ast.schema.getMutationType();
  } else {
    rootType = ast.schema.getSubscriptionType();
  }
  const variables = operation.variables.filter(graphqlToolUtilities.isTypedVariable).length > 0 ? context$1.export(language.variablesInterface(operation.variables, context$1)) : null;
  const operationInterface = t__namespace.tsInterfaceDeclaration(t__namespace.identifier(context$1.typeName), null, null, language.tsInterfaceBodyForObjectField(operation, rootType, new utilities.ObjectStack(rootType), context$1));
  const operationPartialInterface = t__namespace.tsInterfaceDeclaration(t__namespace.identifier(partialContext.typeName), null, null, language.tsInterfaceBodyForObjectField(operation, rootType, new utilities.ObjectStack(rootType), partialContext));
  const {
    schemaImports
  } = file;
  const {
    namespace
  } = context$1;
  const {
    namespace: partialNamespace
  } = partialContext;
  const {
    exportFormat = types.ExportFormat.Document
  } = options;
  const graphqlTypedDocumentType = exportFormat === types.ExportFormat.Simple ? 'SimpleDocument' : 'DocumentNode';
  const includeGraphqlTyped = [types.ExportFormat.Document, types.ExportFormat.DocumentWithTypedDocumentNode, types.ExportFormat.Simple].includes(exportFormat);
  const includeTypedDocumentNode = [types.ExportFormat.TypedDocumentNode, types.ExportFormat.DocumentWithTypedDocumentNode].includes(exportFormat);
  const graphqlTypedImport = () => {
    const identifier = t__namespace.identifier(graphqlTypedDocumentType);
    return t__namespace.importDeclaration([t__namespace.importSpecifier(identifier, identifier)], t__namespace.stringLiteral('graphql-typed'));
  };
  const typedDocumentNodeImport = () => {
    const identifier = t__namespace.identifier('TypedDocumentNode');
    return t__namespace.importDeclaration([t__namespace.importSpecifier(identifier, identifier)], t__namespace.stringLiteral('@graphql-typed-document-node/core'));
  };
  const emptyObjectTypeLiteral = () => t__namespace.tsTypeLiteral([t__namespace.tsIndexSignature([{
    ...t__namespace.identifier('key'),
    typeAnnotation: t__namespace.tsTypeAnnotation(t__namespace.tsStringKeyword())
  }], t__namespace.tsTypeAnnotation(t__namespace.tsNeverKeyword()))]);
  const graphqlTypedTypeReference = () => t__namespace.tsTypeReference(t__namespace.identifier(graphqlTypedDocumentType), t__namespace.tsTypeParameterInstantiation([t__namespace.tsTypeReference(t__namespace.identifier(context$1.typeName)), variables || t__namespace.tsNeverKeyword(), t__namespace.tsTypeReference(t__namespace.identifier(partialContext.typeName))]));

  // `@graphql-codegen`'s typed-document-node plugin states that when no
  // variables are present they should be typed as an "empty object" -
  // `TypedDocumentNode<Result, {[key: string]: never;}>`
  // This differs from the behaviour of graphql-typed which uses never for
  // absent variables - `DocumentNode<Result, never, PartialData>`.
  // "empty object" is slightly more lax - it allows doing
  // `useQuery(myQuery, {variables: {}})`. I think this is more intuitive as it
  // says "Variables are always an object, it might not have any keys though"
  // See www.graphql-code-generator.com/plugins/typed-document-node
  const graphqlTypedDocumentNodeReference = () => t__namespace.tsTypeReference(t__namespace.identifier('TypedDocumentNode'), t__namespace.tsTypeParameterInstantiation([t__namespace.tsTypeReference(t__namespace.identifier(context$1.typeName)), variables || emptyObjectTypeLiteral()]));
  const documentTypeTypeAnnotation = (() => {
    const annotations = [];
    if (includeGraphqlTyped) {
      annotations.push(graphqlTypedTypeReference());
    }
    if (includeTypedDocumentNode) {
      annotations.push(graphqlTypedDocumentNodeReference());
    }
    if (annotations.length === 0) {
      throw new Error("Couldn't find any annotation to use");
    }
    if (annotations.length === 1) {
      return annotations[0];
    }
    return t__namespace.tsIntersectionType(annotations);
  })();
  const documentNodeDeclaratorIdentifier = {
    ...t__namespace.identifier('document'),
    typeAnnotation: t__namespace.tsTypeAnnotation(documentTypeTypeAnnotation)
  };
  const documentNodeDeclaration = t__namespace.variableDeclaration('const', [t__namespace.variableDeclarator(documentNodeDeclaratorIdentifier)]);
  documentNodeDeclaration.declare = true;
  const documentNodeExport = t__namespace.exportDefaultDeclaration(t__namespace.identifier('document'));
  const fileBody = [];
  if (includeGraphqlTyped) {
    fileBody.push(graphqlTypedImport());
  }
  if (includeTypedDocumentNode) {
    fileBody.push(typedDocumentNodeImport());
  }
  if (schemaImports) {
    fileBody.push(schemaImports);
  }
  if (partialNamespace) {
    fileBody.push(t__namespace.exportNamedDeclaration(partialNamespace, []));
  }
  fileBody.push(t__namespace.exportNamedDeclaration(operationPartialInterface, []));
  if (namespace) {
    fileBody.push(t__namespace.exportNamedDeclaration(namespace, []));
  }
  fileBody.push(t__namespace.exportNamedDeclaration(operationInterface, []), documentNodeDeclaration, documentNodeExport);
  return generate(t__namespace.file(t__namespace.program(fileBody), [], [])).code;
}

exports.printDocument = printDocument;
