'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var path = require('path');
var t = require('@babel/types');
var graphqlToolUtilities = require('graphql-tool-utilities');
var utilities = require('./utilities.js');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var t__namespace = /*#__PURE__*/_interopNamespace(t);

class FileContext {
  get schemaImports() {
    const {
      path,
      importedTypes,
      options: {
        schemaTypesPath
      }
    } = this;
    return importedTypes.size > 0 ? t__namespace.importDeclaration([...importedTypes].map(type => t__namespace.importSpecifier(t__namespace.identifier(type), t__namespace.identifier(type))), t__namespace.stringLiteral(importPath(path, schemaTypesPath))) : null;
  }
  constructor(path, options) {
    this.importedTypes = new Set();
    this.path = path;
    this.options = options;
  }
  import(type) {
    this.importedTypes.add(type);
  }
}
class OperationContext {
  get typeName() {
    let typeName;
    if (graphqlToolUtilities.isOperation(this.operation)) {
      const {
        operationName,
        operationType
      } = this.operation;
      typeName = `${utilities.upperCaseFirst(operationName)}${utilities.upperCaseFirst(operationType)}Data`;
    } else {
      const {
        fragmentName
      } = this.operation;
      typeName = `${utilities.upperCaseFirst(fragmentName)}FragmentData`;
    }
    return this.options.partial ? typeName.replace(/Data$/, 'PartialData') : typeName;
  }
  get namespace() {
    const {
      exported,
      typeName
    } = this;
    return exported.length > 0 ? t__namespace.tsModuleDeclaration(t__namespace.identifier(typeName), t__namespace.tsModuleBlock(exported.map(type => t__namespace.exportNamedDeclaration(type, [])))) : null;
  }
  get exported() {
    return this.exportedTypes;
  }
  constructor(operation, ast, options, file) {
    this.exportedTypes = [];
    this.operation = operation;
    this.ast = ast;
    this.options = options;
    this.file = file;
  }
  export(type) {
    this.exportedTypes.push(type);
    return t__namespace.tsTypeReference(t__namespace.tsQualifiedName(t__namespace.identifier(this.typeName), t__namespace.identifier(type.id.name)));
  }
}
function importPath(from, to) {
  const relativePath = path.relative(path.dirname(from), to);
  const normalizedPath = relativePath.startsWith('..') ? relativePath : `./${relativePath}`;
  return normalizedPath.replace(/\.ts$/, '');
}

exports.FileContext = FileContext;
exports.OperationContext = OperationContext;
